num_players_info = [
	{
		name = qs(0xe39e174e)
		checksum = num_2
		num = 2
	}
	{
		name = qs(0x0ccca1af)
		checksum = num_3
		num = 3
	}
	{
		name = qs(0xede2abcb)
		checksum = num_4
		num = 4
	}
	{
		name = qs(0xe836c048)
		checksum = num_6
		num = 6
	}
	{
		name = qs(0xf11bd2c1)
		checksum = num_8
		num = 8
	}
]
num_private_slots = [
	{
		name = qs(0xe64a7ccd)
		checksum = num_0
		num = 0
	}
	{
		name = qs(0x0918ca2c)
		checksum = num_1
		num = 1
	}
]
ranked_info = [
	{
		name = qs(0x3489402d)
		checksum = player
		num = 1
	}
	{
		name = qs(0xd6e06d82)
		checksum = ranked
		num = 0
	}
]
join_in_progress_info = [
	{
		name = qs(0xefa31a4a)
		num = 0
		checksum = no
	}
	{
		name = qs(0xe5fd67fa)
		num = 1
		checksum = yes
	}
]
filtertypes = {
	diff = {
		values = [
			qs(0x9a8b4e86)
			qs(0x8d657387)
			qs(0x6ef11a01)
			qs(0x51b06d2f)
			qs(0x334908ac)
		]
		checksum = [
			dont_care
			easy
			medium
			hard
			expert
		]
	}
	mode = {
		values = [
			qs(0x9a8b4e86)
			qs(0x0952b48b)
			qs(0x46577877)
			qs(0x33b59779)
			qs(0x5bbbf8bc)
		]
		checksum = [
			dont_care
			p2_faceoff
			p2_pro_faceoff
			p2_battle
			p2_coop
		]
	}
	type = {
		values = [
			qs(0xd6268827)
			qs(0x444599e3)
		]
		checksum = [
			player
			ranked
		]
	}
	num_songs = {
		values = [
			qs(0x9a8b4e86)
			qs(0x22ee76e7)
			qs(0x1985c05b)
			qs(0x4fdf67dd)
			qs(0x7de9055f)
		]
		checksum = [
			dont_care
			num_1
			num_3
			num_5
			num_7
		]
	}
	tie = {
		values = [
			qs(0x9a8b4e86)
			qs(0x99c4796b)
			qs(0x8b0a4ef9)
			qs(0x0b6c701b)
		]
		checksum = [
			dont_care
			host
			client
			song_rand
		]
	}
	search = {
		values = [
			qs(0x9f61d184)
			qs(0x8dc9f66d)
			qs(0xd2cabff7)
		]
	}
	song_type = {
		values = [
			qs(0xab226a7d)
			qs(0xdc5d0ed4)
		]
	}
	vport = {
		values = [
			qs(0xdb64e332)
			qs(0xdfe62bc8)
		]
	}
	lb_diff = {
		values = [
			qs(0x8d657387)
			qs(0x6ef11a01)
			qs(0x51b06d2f)
			qs(0x334908ac)
		]
	}
}
leaderboard_difficulty_lookup_table = {
	easy = 'easy'
	medium = 'medium'
	hard = 'hard'
	expert = 'expert'
}
controller_lookup_table = {
	controller = 'Vocal'
	guitar = 'Guitar'
	drum = 'Drum'
	bass = 'Bass'
	vocals = 'Vocal'
}
online_light_purple = [
	190
	180
	205
	250
]
online_dark_purple = [
	70
	40
	70
	250
]
online_light_blue = [
	180
	230
	250
	250
]
online_medium_blue = [
	35
	130
	175
	250
]
online_dark_blue = [
	0
	70
	100
	250
]
online_score_bars = [
	60
	50
	70
	128
]
online_trans_grey = [
	0
	0
	0
	200
]
online_grey = [
	75
	75
	75
	250
]
online_light_grey = [
	75
	75
	75
	150
]
online_red = [
	255
	0
	0
	255
]
online_yellow = [
	210
	210
	0
	255
]
online_orange = [
	255
	165
	0
	255
]
online_green = [
	0
	150
	0
	255
]
online_general_menu_pos = (640.0, 75.0)
online_general_menu_hi_lite_ypos = [
	0.0
	0.0
	0.0
	0.0
]
net_new_matchmaking_ui_flag = 0
net_permision_to_select_song = 0
net_can_send_approval = 1
net_safe_to_enter_net_play = 1
net_pause = 0
net_num_players_data_ack = 0
net_num_players_data_needed = 0
net_dropped_players_flag = 0
recovered_dropped_players = 0
player1_song_selections = [
	null
	null
	null
]
player2_song_selections = [
	null
	null
	null
]
tie_breaker_song = bullsonparade
match_type = player
private_match = public
net_grouping = band
online_song_count = 0
player2_present = 0
player1_max_song_selections = 0
player1_current_song_selections = 0
player2_max_song_selections = 0
player2_current_song_selections = 0
player1_selected_guitar = instrument_les_paul_black
player1_selected_bass = instrument_lp_vbrst
player2_selected_guitar = instrument_les_paul_black
player2_selected_bass = instrument_lp_vbrst
retrieved_message_of_the_day = 0
message_of_the_day = qs(0x00000000)
online_song_choice_id = 0
ps3_non_primary_controller_id = qs(0xee4339cd)
agora_failed_attempts = 0
optionsgamemodevalue = 0
optionsdifficultyvalue = 0
optionsnumsongsvalue = 0
optionstiebreakervalue = 0
optionshighwayvalue = 0
leaderboardsearchvalue = 0
leaderboardsongtypevalue = 0
leaderboarddiffvalue = 3
copyofglobal = 0
searchmatchtypevalue = 0
searchgamemodevalue = 0
searchdifficultyvalue = 0
searchnumsongsvalue = 0
searchtiebreakervalue = 0
tempgamemodevalue = 0
tempdifficultyvalue = 0
tempnumsongsvalue = 0
temptiebreakervalue = 0
temphighwayvalue = 0
ps3_invite_postion = (255.0, 96.0)
net_drop_packet_percentage = 0
net_game_type_info = [
	{
		name = qs(0x46577877)
		description = qs(0xb96bc46d)
		checksum = p2_pro_faceoff
		func = is_gamemode_visible
		search_chk = p2_pro_faceoff
	}
	{
		name = qs(0x0952b48b)
		description = qs(0xb5b1d856)
		checksum = p2_faceoff
		func = is_gamemode_visible
		search_chk = p2_faceoff
	}
	{
		name = qs(0x98fa7ed6)
		description = qs(0x2d3d2fa9)
		checksum = p4_quickplay
		func = is_gamemode_visible
		search_chk = p4_quickplay
	}
	{
		name = qs(0x148d4f57)
		description = qs(0x2d3d2fa9)
		checksum = p2_quickplay
		func = is_gamemode_visible
		search_chk = p2_coop
	}
	{
		name = qs(0x67d8da9b)
		description = qs(0xb96bc46d)
		checksum = p4_pro_faceoff
		func = is_gamemode_visible
		search_chk = p4_pro_faceoff
	}
	{
		name = qs(0xbae36279)
		description = qs(0x323709dd)
		checksum = p8_pro_faceoff
		func = is_gamemode_visible
		search_chk = p8_pro_faceoff
	}
	{
		name = qs(0x33b59779)
		description = qs(0x82ab3ffb)
		checksum = p2_battle
		func = is_gamemode_visible
		search_chk = p2_battle
	}
	{
		name = qs(0x2a7276c2)
		description = qs(0xb96bc46d)
		checksum = p2_pro_faceoff
		func = is_gamemode_visible
		search_chk = p2_pro_faceoff_bass
	}
	{
		name = qs(0x27e2aa54)
		description = qs(0x62c7ead3)
		checksum = p2_faceoff
		func = is_gamemode_visible
		search_chk = p2_faceoff_bass
	}
	{
		name = qs(0x7c4bcefd)
		description = qs(0xb96bc46d)
		checksum = p2_pro_faceoff
		func = is_gamemode_visible
		search_chk = p2_pro_faceoff_drums
	}
	{
		name = qs(0xd435700e)
		description = qs(0x04bdd449)
		checksum = p2_faceoff
		func = is_gamemode_visible
		search_chk = mode_extra_1
	}
	{
		name = qs(0xdf90fff4)
		description = qs(0x655c34df)
		checksum = p4_career
		func = is_gamemode_visible
		search_chk = p4_career
	}
]
beta_net_game_type_info = [
	{
		name = qs(0x899a96c8)
		description = qs(0xb96bc46d)
		checksum = p2_pro_faceoff
		func = is_gamemode_visible
	}
	{
		name = qs(0x425b9950)
		description = qs(0xb96bc46d)
		checksum = p4_pro_faceoff
		func = is_gamemode_visible
	}
]
net_guitar_part_info = [
	{
		name = qs(0x0cc7d9b2)
		checksum = guitar
	}
	{
		name = qs(0x7d4f9214)
		checksum = bass
	}
]
xenon_invite_confirm_title = qs(0xf3c9603f)
xenon_invite_confirm_dialog = qs(0xb202cc8b)
xenon_invite_confirm_yes = qs(0xb73cb78f)
xenon_invite_confirm_no = qs(0xf7723015)
xenon_invite_disallowed_title = qs(0xf3c9603f)
xenon_invite_disallowed_dialog = qs(0xc9d447ca)
xenon_invite_disallowed_ok = qs(0x0e41fe46)
no_net_mode = 0
lan_mode = 1
internet_mode = 2
net_autolaunch_role = none
net_popup_active = 0

script net_autolaunch_spawned 
	mode = ($game_mode)
	ui_event_block \{event = menu_change
		data = {
			state = uistate_mainmenu
			base_name = 'mainmenu'
			selected_index = 3
			clear_previous_stack
		}}
	change game_mode = <mode>
	netoptions :pref_choose name = game_modes checksum = ($game_mode)
	main_menu_select_online
	block \{type = online_menu_created}
	add_active_controllers
	start_matchmaking device_num = ($primary_controller)
endscript

script al_refresh 
	ui_event \{event = menu_replace
		data = {
			state = uistate_net_debug_lobby
			mode = client
		}}
	al_get_server_list
endscript

script al_get_server_list 
	printf \{qs(0x6c672f1c)}
	al_get_preferences
	get_server_list \{callback = autolaunch_add_server
		callback_complete = autoloaunch_results_stop}
endscript

script get_server_list \{callback = empty_script
		callback_complete = empty_script}
	change \{xboxlive_num_results = 0}
	netsessionfunc \{obj = match
		func = stop_server_list}
	netsessionfunc \{obj = match
		func = free_server_list}
	net_dummy_get_needed_search_params
	netsessionfunc obj = match func = set_search_params params = <...>
	netsessionfunc \{obj = match
		func = set_server_list_mode
		params = {
			optimatch
		}}
	netsessionfunc {
		obj = match
		func = start_server_list
		params = {
			callback = <callback>
			callback_complete = <callback_complete>
		}
	}
endscript

script al_get_preferences 
	return {
		difficulty = ($net_autolaunch_parms.difficulty)
		gamemode = ($net_autolaunch_parms.gamemode)
		num_songs = ($net_autolaunch_parms.num_songs)
	}
endscript

script autolaunch_add_server 
	printf \{qs(0x1cb462bf)}
	change xboxlive_num_results = (($xboxlive_num_results) + 1)
	add_menu_item text = <server_name> pad_choose_script = net_al_choose_server pad_choose_params = {server_name = <server_name> server_id = <server_id>}
endscript

script autolaunch_results_stop 
	if gotparam \{xboxlive_num_results}
		change xboxlive_num_results = <xboxlive_num_results>
	endif
	printf qs(0xef0ddf26) d = ($xboxlive_num_results)
endscript

script net_al_choose_server 
	printf qs(0x4c82f9cb) s = <server_name> d = <server_id>
	netsessionfunc obj = match func = choose_server params = {id = <server_id>}
	ui_event event = menu_change data = {state = uistate_net_debug_lobby_join server_name = <server_name>}
endscript

script setup_and_post_game 
	netsessionfunc \{obj = match
		func = stop_server_list}
	netsessionfunc \{obj = match
		func = free_server_list}
	<rand> = 0
	getrandomvalue \{name = rand
		integer
		a = 0
		b = 1}
	get_number_of_songs
	if ((<rand> = 0) || ($game_mode = p2_coop) || (<num_songs> = 1))
		change \{tie_breaker = host}
	else
		change \{tie_breaker = client}
	endif
	if ishost
		resethubstates
	endif
	post_network_game controller = <device_num>
endscript

script quit_network_game 
	printf \{qs(0xffb8716a)}
	killspawnedscript \{name = loading_screen_crowd_swell}
	killspawnedscript \{name = crowd_loading_whistle}
	leaveserver
	removetimesynctask
	clear_wait_for_net_match_available_items
	netsessionfunc \{obj = session
		func = unpost_game}
	endgamenetscriptpump
	change \{battle_do_or_die = 0}
	change \{battle_do_or_die_speed_scale = 1.0}
	change \{battle_do_or_die_attack_scale = 1.0}
	if ($game_mode = p2_battle)
		change \{save_current_powerups_p1 = [
				0
				0
				0
			]}
		change \{save_current_powerups_p2 = [
				0
				0
				0
			]}
		change \{structurename = player1_status
			save_num_powerups = 0}
		change \{structurename = player2_status
			save_num_powerups = 0}
		change \{structurename = player1_status
			save_health = 0.0}
		change \{structurename = player2_status
			save_health = 0.0}
	endif
	netoptions :pref_choose \{name = private_slots
		value = 0}
	netoptions :pref_choose \{name = ranked
		checksum = player}
	change \{current_num_players = 1}
	change \{player2_present = 0}
	change \{g_tie_breaker_song = 0}
	change \{net_can_send_approval = 1}
	reset_setlist
	reset_net_stats_menu
	change \{net_song_num = 0}
	if NOT ($game_mode = p2_coop)
		change \{structurename = player1_status
			part = guitar}
		change \{structurename = player2_status
			part = guitar}
	endif
endscript

script handle_matchmaking_handoff_failed 
	printf \{qs(0xe8e7935e)}
	quit_network_game
	ui_event_get_top
	continue_script = nullscript
	if (<base_name> = 'online')
		continue_script = handle_matchmaking_handoff_failed_continue_online
	elseif (<base_name> = 'band_mode')
		ui_band_mode_change_menu_focus_all \{focus_type = unfocus}
		continue_script = handle_matchmaking_handoff_failed_continue_band_mode
	else
		printf \{qs(0x72e1c381)}
		return
	endif
	destroy_popup_warning_menu
	if isxenon
		popup_text = qs(0xeba184f9)
	else
		popup_text = qs(0x93a3822e)
	endif
	create_popup_warning_menu {
		title = qs(0x1d13706e)
		textblock = {
			text = <popup_text>
		}
		no_background
		options = [
			{
				func = <continue_script>
				text = qs(0x182f0173)
			}
		]
	}
endscript

script handle_matchmaking_handoff_failed_continue_band_mode 
	printf \{qs(0x78a057d3)}
	if ($ui_band_mode_hit_force_completion = 0)
		destroy_popup_warning_menu
		change num_players_in_band = ($num_players_in_band_old)
		change \{career_matchmaking_complete = 0}
		ui_event \{event = menu_refresh}
	else
		generic_event_back \{state = uistate_group_play}
	endif
	change \{ui_band_mode_hit_force_completion = 0}
endscript

script handle_matchmaking_handoff_failed_continue_online 
	printf \{qs(0xb7dda6e3)}
	destroy_popup_warning_menu
	net_clear_all_remote_player_status
	ui_event \{event = menu_refresh}
endscript

script net_clear_player_status 
	requireparams \{[
			player_index
		]}
	printf qs(0x7500e57a) d = <player_index>
	setplayerinfo <player_index> is_local_client = 1
	setplayerinfo <player_index> net_id_first = 0
	setplayerinfo <player_index> net_id_second = 0
	setplayerinfo <player_index> net_obj_id = -1
	setplayerinfo <player_index> team = 0
	setplayerinfo <player_index> party_id = -1
	formattext checksumname = gamertag 'gamertag_%d' d = (<player_index> - 1)
	change globalname = <gamertag> newvalue = qs(0x00000000)
	controller = (<player_index> -1)
	if (<controller> > 3)
		controller = 3
	endif
	setplayerinfo <player_index> controller = <controller>
endscript

script net_clear_all_remote_player_status 
	player = 1
	begin
	getplayerinfo <player> is_local_client
	if (<is_local_client> = 0)
		net_clear_player_status player_index = <player>
	else
		setplayerinfo <player> team = 0
	endif
	<player> = (<player> + 1)
	repeat 8
endscript

script shut_down_net_play 
	change \{is_network_game = 0}
	setnetworkmode
	netsessionfunc \{obj = match
		func = stop_server_list}
	netsessionfunc \{obj = match
		func = free_server_list}
	netsessionfunc \{func = stats_uninit}
	destroy_gamertags
	destroy_net_popup
	cleanup_sessionfuncs
	setup_sessionfuncs
	net_clear_all_remote_player_status
	change \{structurename = player1_status
		highway_layout = default_highway}
	change \{structurename = player2_status
		highway_layout = default_highway}
	destroy_player_drop_events
endscript

script select_quit_network_game 
	if screenelementexists \{id = yourock_text}
		destroyscreenelement \{id = yourock_text}
	endif
	if screenelementexists \{id = yourock_text_2}
		destroyscreenelement \{id = yourock_text_2}
	endif
	if ($net_popup_active = 0)
		gamemode_gettype
		if (<type> = career)
			if ($special_event_stage != 0)
				reset_current_special_event_percentages
			endif
		endif
		if gotparam \{from_fail_menu}
			generic_event_choose state = uistate_online_quit_warning data = {player_device = <device_num>}
		else
			generic_event_choose state = uistate_online_quit_warning data = {is_popup player_device = <device_num>}
		endif
	endif
endscript

script quit_network_game_early 
	change \{disable_attacks = 1}
	if NOT ($is_network_game)
		return
	endif
	pausegame
	if (compositeobjectexists ui)
		ui :unpause
	endif
	quit_network_game
	if gotparam \{signin_change}
		shut_down_net_play
	else
		if ($playing_song = 1)
			kill_gem_scroller
		endif
	endif
endscript

script cancel_join_server 
	printf \{qs(0x8a62650c)}
	leaveserver
	netsessionfunc \{obj = session
		func = unpost_game}
	netsessionfunc \{obj = match
		func = free_server_list}
endscript

script post_network_game 
	if (netsessionfunc obj = match func = get_gamertag params = {controller = <controller>})
		change default_network_id = <name>
		change default_server_id = <name>
	endif
	netsessionfunc obj = session func = post_game params = {controller_index = <controller>}
	setservermode
	startserver
	setjoinmode \{$join_mode_play}
	joinserver
endscript

script set_match_values 
	set_network_preferences \{dont_set}
	net_dummy_get_needed_search_params
	return {
		difficulty = ($player1_status.difficulty)
		gamemode = <gamemode>
		num_songs = ($num_songs)
		scoring_mode = <scoring_mode>
	}
endscript

script set_network_preferences 
	netoptions :pref_getstruct \{name = game_modes}
	netoptions :pref_get \{name = game_modes}
	if NOT gotparam \{dont_set}
		change game_mode = <checksum>
		gamemode_getnumplayers
		printf qs(0x8429c652) s = <num_players>
		netoptions :pref_choose name = num_players value = <num_players>
	endif
	return {
		gamemode = (<pref_struct>.search_chk)
		difficulty = ($player1_status.difficulty)
		num_songs = dont_care
	}
endscript

script set_netgame_globals 
	printf \{qs(0xc7b8dbb0)}
	printstruct <...>
	change game_mode = <game_mode>
	change current_level = <level>
	gamemode_getnumplayers
	change current_num_players = <num_players>
endscript

script prepare_lobby_message 
	switch ($game_mode)
		case p2_faceoff
		<game_mode_index> = 1
		case p2_pro_faceoff
		<game_mode_index> = 2
		case p2_battle
		<game_mode_index> = 3
		case p2_coop
		<game_mode_index> = 4
	endswitch
	switch ($player1_status.difficulty)
		case easy
		<difficulty_index> = 1
		case medium
		<difficulty_index> = 2
		case hard
		<difficulty_index> = 3
		case expert
		<difficulty_index> = 4
	endswitch
	switch ($num_songs)
		case num_1
		<number_of_songs_index> = 1
		case num_3
		<number_of_songs_index> = 3
		case num_5
		<number_of_songs_index> = 5
		case num_7
		<number_of_songs_index> = 7
	endswitch
	switch ($tie_breaker)
		case host
		<tie_breaker_index> = 1
		case client
		<tie_breaker_index> = 2
	endswitch
	switch ($ui_flow_manager_state [0])
		case online_character_select_fs
		<flow_state> = 1
		case online_character_hub_fs
		<flow_state> = 2
		case online_select_outfit_fs
		<flow_state> = 3
		case online_select_style_fs
		<flow_state> = 4
		case online_select_guitar_fs
		<flow_state> = 5
		case online_select_guitar_finish_fs
		<flow_state> = 6
		case online_select_bass_fs
		<flow_state> = 7
	endswitch
	return {
		game_mode_index = <game_mode_index>
		difficulty_index = <difficulty_index>
		number_of_songs_index = <number_of_songs_index>
		tie_breaker_index = <tie_breaker_index>
		flow_state = <flow_state>
	}
endscript

script cleanup_sessionfuncs 
	printf \{qs(0x7abbf921)}
	netsessionfunc \{func = match_uninit}
	netsessionfunc \{func = stats_uninit}
endscript

script setup_sessionfuncs 
	printf \{qs(0x6deffbba)}
	netsessionfunc \{func = match_init}
	netsessionfunc \{func = stats_init}
	netsessionfunc \{func = voice_init}
	netsessionfunc \{func = motd_init}
	netsessionfunc \{obj = voice
		func = enable}
	if netsessionfunc \{obj = match
			func = get_gamertag}
		change default_network_id = <name>
		change default_server_id = <name>
	endif
endscript

script get_current_level_name 
	return level_name = ($levelzones.($current_level).title) level = 1
endscript

script getcurrentareastringandchecksum 
	<area_string> = 'z_online_venue'
	<area_checksum> = dummy_value
endscript

script launch_game 
	gamemode_gettype
	if (<type> = career)
		ui_event event = menu_change data = {state = uistate_play_song progression_flag = ($current_progression_flag) gig_num = ($current_gig_number) song_checksum = ($current_song) song_index = ($net_career_song_index)}
	else
		generic_event_choose \{state = uistate_play_song}
	endif
endscript

script load_and_sync_timing \{start_delay = 3000}
	endgamenetscriptpump
	printf \{qs(0x73081805)}
	load_venue
	printf \{qs(0x5b6fd41c)
		i = $current_level}
	gamemode_gettype
	if (<type> != career)
		change \{current_transition = fastintro}
		restart_gem_scroller song_name = ($current_song) difficulty = ($player1_status.difficulty) difficulty2 = ($player2_status.difficulty) starttime = 0 endtime = 999999999 device_num = ($player1_status.controller)
	else
		restart_gem_scroller song_name = ($current_song) difficulty = ($player1_status.difficulty) difficulty2 = ($player2_status.difficulty) starttime = 0 endtime = 999999999 device_num = ($player1_status.controller) loading_transition = 0
		($default_loading_screen.destroy)
	endif
endscript

script launch_network_game 
	change \{net_ready_to_start = 1}
endscript

script ranked_quit_fix_scores 
	get_number_of_songs
	song_index = 0
	begin
	if ($game_mode = p2_battle)
		setarrayelement arrayname = g_p1_scores globalarray index = <song_index> newvalue = 8
		setarrayelement arrayname = g_p2_scores globalarray index = <song_index> newvalue = -1
	else
		setarrayelement arrayname = g_p2_scores globalarray index = <song_index> newvalue = 0
	endif
	<song_index> = (<song_index> + 1)
	repeat <num_songs>
endscript

script net_check_buttons 
	get_song_prefix song = <song_name>
	formattext checksumname = guitar_stream '%s_guitar' s = <song_prefix> addtostringlookup
	guitarinputlogicinit player_status = <player_status> guitar_stream = <guitar_stream> time_offset = <time_offset>
	extendcrc button_up_pixel_array ($<player_status>.text) out = pixel_array
	<player_text> = ($<player_status>.text)
	getarraysize \{$gem_colors}
	begin
	array_count = 0
	begin
	color = ($gem_colors [<array_count>])
	pixels = ($<pixel_array> [<array_count>])
	button_lip_name = (($button_up_models [(<player> -1)]).<color>.name)
	extendcrc <button_lip_name> '_lip' out = button_lip_name
	extendcrc <button_lip_name> <player_text> out = button_lip_name
	button_mid_name = (($button_up_models [(<player> -1)]).<color>.name)
	extendcrc <button_mid_name> '_mid' out = button_mid_name
	extendcrc <button_mid_name> <player_text> out = button_mid_name
	button_neck_name = (($button_up_models [(<player> -1)]).<color>.name)
	extendcrc <button_neck_name> '_neck' out = button_neck_name
	extendcrc <button_neck_name> <player_text> out = button_neck_name
	button_head_name = (($button_up_models [(<player> -1)]).<color>.name)
	extendcrc <button_head_name> '_head' out = button_head_name
	extendcrc <button_head_name> <player_text> out = button_head_name
	pos_table = ($highway_pos_table [(<player> -1)])
	now_scale = (((<pos_table>.nowbar_scale_x) * (1.0, 0.0)) + ((<pos_table>.nowbar_scale_y) * (0.0, 1.0)))
	if ($<player_status>.lefthanded_button_ups = 1)
		<pos2d> = (($button_up_models [(<player> -1)]).<color>.left_pos_2d)
	else
		<pos2d> = (($button_up_models [(<player> -1)]).<color>.pos_2d)
	endif
	if ($<player_status>.lefthanded_button_ups = 1)
		<playline_scale> = (((0 - <now_scale>.(1.0, 0.0)) * (1.0, 0.0)) + (<now_scale>.(0.0, 1.0) * (0.0, 1.0)))
	else
		<playline_scale> = <now_scale>
	endif
	<y_scale> = ((<pixels> + $neck_lip_add) / $neck_sprite_size)
	<neck_scale> = (((<playline_scale>.(1.0, 0.0)) * (1.0, 0.0)) + (<y_scale> * (0.0, 1.0)))
	<head_pos> = (<pos2d> - (<pixels> * (0.0, 1.0)))
	if screenelementexists id = <button_lip_name>
		setscreenelementprops id = <button_lip_name> z_priority = 4.9
	endif
	if screenelementexists id = <button_mid_name>
		setscreenelementprops id = <button_mid_name> z_priority = 4.6
	endif
	if screenelementexists id = <button_neck_name>
		setscreenelementprops id = <button_neck_name> z_priority = 4.7 scale = <neck_scale>
	endif
	if screenelementexists id = <button_head_name>
		setscreenelementprops id = <button_head_name> z_priority = 4.8 pos = <head_pos>
	endif
	array_count = (<array_count> + 1)
	repeat <array_size>
	array_count = 0
	getdeltatime
	sub_amount = (($button_up_pixels * <delta_time>) / $button_sink_time)
	begin
	pixels = ($<pixel_array> [<array_count>])
	pixels = (<pixels> - <sub_amount>)
	if (<pixels> < 0.0)
		<pixels> = 0.0
	endif
	setarrayelement arrayname = <pixel_array> globalarray index = <array_count> newvalue = <pixels>
	array_count = (<array_count> + 1)
	repeat <array_size>
	wait \{1
		gameframe}
	repeat
endscript

script net_check_note_hold 
	checknoteholdinit player = <player> player_status = <player_status> array_entry = <array_entry> time = <time> guitar_stream = <guitar_stream> song = <song> pattern = <pattern>
	begin
	if NOT checknoteholdwait player = <player>
		break
	endif
	wait \{1
		gameframe}
	repeat
	checknoteholdstart player = <player>
	spawnscriptlater net_control_whammy_pitch_loop params = {song = <song> array_entry = <array_entry> pattern = <pattern> player_status = <player_status> time = <time>}
	begin
	if NOT checknoteholdperframe player = <player>
		break
	endif
	wait \{1
		gameframe}
	repeat
	killspawnedscript \{name = net_whammy_pitch_shift}
	killspawnedscript \{name = net_control_whammy_pitch_loop}
	checknoteholdend player = <player>
endscript

script net_control_whammy_pitch_loop 
	change \{pitch_dirty = 1}
	formattext checksumname = net_update_event 'net_button_check_p%d' d = ($<player_status>.player) addtostringlookup = true
	begin
	getsongtime
	start_time = <songtime>
	block type = <net_update_event>
	getsongtime
	delta_time = (<songtime> - <start_time>)
	<time> = (<time> - (<delta_time> * 1000))
	killspawnedscript \{name = net_whammy_pitch_shift}
	spawnscriptnow net_whammy_pitch_shift params = {song = <song> array_entry = <array_entry> pattern = <pattern> player_status = <player_status> net_whammy_length = (<event_data>.net_whammy_length) time = <time>}
	repeat
	killspawnedscript \{name = net_whammy_pitch_shift}
endscript
pitch_dirty = 1
prev_len = 0

script net_whammy_pitch_shift 
	if ($pitch_dirty = 1)
		change \{pitch_dirty = 0}
		change prev_len = <net_whammy_length>
		begin
		controlwhammypitchshift player_status = <player_status> net_whammy_length = <net_whammy_length> time = <time>
		wait \{1
			gameframe}
		repeat
	else
		<len_delta> = (<net_whammy_length> - $prev_len)
		<len_base> = ($prev_len)
		change prev_len = <net_whammy_length>
		<frames> = 5
		<scale> = (1.0 / <frames>)
		<scale_step> = <scale>
		begin
		<len> = (<len_base> + (<len_delta> * <scale>))
		set_whammy_pitchshift control = <len> player_status = <player_status>
		<whammy_scale> = (((<len> * 0.5) + 0.5) * 2.0)
		setnewwhammyvalue value = <whammy_scale> time_remaining = <time> player_status = <player_status> player = ($<player_status>.player)
		<scale> = (<scale> + <scale_step>)
		wait \{1
			gameframe}
		repeat <frames>
		begin
		set_whammy_pitchshift control = <net_whammy_length> player_status = <player_status>
		<whammy_scale> = (((<net_whammy_length> * 0.5) + 0.5) * 2.0)
		setnewwhammyvalue value = <whammy_scale> time_remaining = <time> player_status = <player_status> player = ($<player_status>.player)
		wait \{1
			gameframe}
		repeat
	endif
endscript

script set_net_client_highway 
	change structurename = <player_status> highway_layout = <layout>
endscript

script set_net_client_lefty 
	change structurename = player2_status lefthanded_gems = <lefty_flip_p2>
	change structurename = player2_status lefthanded_button_ups = <lefty_flip_p2>
endscript

script net_copy_intial_params 
	change globalname = <copy_to> newvalue = $<copy_from>
endscript

script net_commit_or_reset_params 
	if gotparam \{commit}
		change globalname = <copy_to> newvalue = $<copy_from>
	else
		if (<type> = loc)
			<text> :se_setprops text = ($levelzones.($levelzonearray [$<global>]).title)
		else
			<text> :se_setprops text = ($filtertypes.<type>.values [$<global>])
		endif
	endif
	change_coop_value_if_ranked
endscript

script net_custom_up_down \{direction = up}
	if (<type> = loc)
		getarraysize ($levelzonearray)
	else
		getarraysize ($filtertypes.<type>.values)
	endif
	if (<direction> = up)
		if ((<array_size> -1) = $<global>)
			change globalname = <global> newvalue = 0
		else
			change globalname = <global> newvalue = ($<global> + 1)
		endif
	else
		if (0 = $<global>)
			change globalname = <global> newvalue = (<array_size> -1)
		else
			change globalname = <global> newvalue = (<global> - 1)
		endif
	endif
	if (<type> = loc)
		<text> :se_setprops text = ($levelzones.($levelzonearray [$<global>]).title) scale = 1.0
		fit_text_into_menu_item id = <text> max_width = 375
	else
		<text> :se_setprops text = ($filtertypes.<type>.values [$<global>]) scale = 1.0
		fit_text_into_menu_item id = <text> max_width = 375
	endif
	if (($searchmatchtypevalue = 1) && (<type> = mode) && ($<global> = 4) && ($ui_flow_manager_state [0] = custom_match_fs))
		net_custom_up_down <...>
	endif
	if (($<global> = 2) && (<type> = search))
		if NOT isxenon
			net_custom_up_down <...>
		endif
	endif
endscript

script change_coop_value_if_ranked 
	if (($searchmatchtypevalue = 1) && ($searchgamemodevalue = 4))
		net_custom_up_down \{direction = up
			type = mode
			global = searchgamemodevalue
			text = game_mode_selection_text}
	endif
endscript

script block_unblock_difficulty_actions \{diff_focus = off
		menu = search}
	if gotparam \{diff_focus}
		<change_color> = ($online_light_blue)
	else
		<change_color> = ($online_dark_purple)
	endif
	if (<menu> = search)
		<gamemode> = ($searchgamemodevalue)
		<new_text> = ($filtertypes.diff.values [($searchdifficultyvalue)])
	else
		<gamemode> = ($optionsgamemodevalue)
		<new_text> = ($filtertypes.diff.values [($optionsdifficultyvalue)])
	endif
	if ((<gamemode> = 0) || (<gamemode> = 2))
		if screenelementexists \{id = difficulty}
			difficulty :se_setprops rgba = <change_color> unblock_events
		endif
		if screenelementexists \{id = difficulty_selection_text}
			difficulty_selection_text :se_setprops rgba = <change_color> text = <new_text> unblock_events
		endif
	else
		if screenelementexists \{id = difficulty}
			difficulty :se_setprops rgba = ($online_grey) block_events
		endif
		if screenelementexists \{id = difficulty_selection_text}
			difficulty_selection_text :se_setprops rgba = ($online_grey) text = qs(0xe50e8cdd) block_events
		endif
	endif
endscript

script net_init 
	change \{is_network_game = 1}
	setnetworkmode \{$internet_mode}
	cleanup_sessionfuncs
	setup_sessionfuncs
	netsessionfunc \{func = getnumplayers}
	spawn_player_drop_listeners
endscript

script wait_for_dw_init 
	begin
	if ($demonware_is_ready = 1)
		break
	endif
	wait \{1
		frame}
	repeat
	add_active_controllers
	menu_net_matchmaking_init
	destroy_popup_warning_menu
endscript

script add_active_controllers 
	getactivecontrollers
	getarraysize <active_controllers>
	controller_index = 0
	begin
	if (<active_controllers> [<controller_index>] = 1)
		if checkforsignin controller_index = <controller_index>
			netsessionfunc func = addcontrollers params = {controller = <controller_index>}
		endif
	endif
	<controller_index> = (<controller_index> + 1)
	repeat <array_size>
endscript

script add_active_controllers_local 
	getactivecontrollers
	getarraysize <active_controllers>
	controller_index = 0
	begin
	if (<active_controllers> [<controller_index>] = 1)
		if checkforsignin local controller_index = <controller_index>
			netsessionfunc func = addcontrollers params = {controller = <controller_index>}
		endif
	endif
	<controller_index> = (<controller_index> + 1)
	repeat <array_size>
endscript

script update_ingame_controllers 
	if ($is_network_game = 0)
		if gotparam \{controller}
			netsessionfunc \{func = removeallcontrollers}
			if isarray <controller>
				getarraysize <controller>
				if (<array_size> > 0)
					<i> = 0
					begin
					<c> = (<controller> [<i>])
					netsessionfunc func = addcontrollers params = {controller = <c>}
					<i> = (<i> + 1)
					repeat <array_size>
				endif
			else
				netsessionfunc func = addcontrollers params = {controller = <controller>}
			endif
		else
			add_active_controllers_local
		endif
	endif
endscript

script setup_online_player_settings 
	getglobaltags \{user_options}
	switch (<online_highway>)
		case 0
		change \{structurename = player1_status
			highway_layout = default_highway}
		case 1
		change \{structurename = player1_status
			highway_layout = solo_highway}
	endswitch
endscript

script get_random_song 
	first_song_index = (-1)
	last_song_index = (-1)
	array_entry = 0
	getarraysize \{$gh_songlist}
	begin
	song_checksum = ($gh_songlist [<array_entry>])
	get_song_version song = <song_checksum>
	if (<song_version> = $current_song_version)
		if (<first_song_index> = (-1))
			<first_song_index> = <array_entry>
		endif
	endif
	<array_entry> = (<array_entry> + 1)
	repeat <array_size>
	<last_song_index> = (<array_entry> - 1)
	getrandomvalue name = random_value integer a = <first_song_index> b = <last_song_index>
	return random_song = ($gh_songlist [<random_value>])
endscript

script start_network_game 
	if ishost
		startnetworkgame
	endif
endscript

script check_for_final_song_selection 
	if (($tie_breaker) = song_rand)
		return \{can_select_final_song = false}
	elseif (($tie_breaker) = host)
		if ishost
			return \{can_select_final_song = true}
		else
			return \{can_select_final_song = false}
		endif
	elseif (($tie_breaker) = client)
		if ishost
			return \{can_select_final_song = false}
		else
			return \{can_select_final_song = true}
		endif
	endif
endscript

script online_fail_song 
	printf \{qs(0x34e995d3)}
	change \{disable_attacks = 1}
	if ((gameisover) || (sessionisover))
		return
	endif
	netfailsong
endscript

script online_win_song 
	if ($net_pause = 1)
		net_unpausegh
	endif
	disable_pause
	printf \{qs(0x311200b2)}
	change \{disable_attacks = 1}
	change structurename = <player_status> best_run = <note_streak>
	change structurename = <player_status> total_notes = <total_notes>
	change structurename = <player_status> notes_hit = <notes_hit>
	if (<quit_early>)
		change \{player2_present = 0}
		if ($match_type = ranked)
			ranked_quit_fix_scores
		endif
		if ($game_mode = p2_battle)
			change \{structurename = player1_status
				current_health = 1.0}
			change \{structurename = player2_status
				current_health = 0.0}
		else
			change \{structurename = player2_status
				score = 0.0}
		endif
		wait_for_net_popup
	endif
	player_text = ($<player_status>.text)
endscript

script broadcast_received_winner_stats 
	change structurename = <player_status> best_run = <note_streak>
	change structurename = <player_status> total_notes = <total_notes>
	change structurename = <player_status> notes_hit = <notes_hit>
	if ($game_mode = p2_battle)
		record_net_statistics
	endif
endscript

script set_rich_presence_searching 
endscript

script set_rich_presence_game_mode \{online = 0}
	if screenelementexists \{id = metallifacts_container}
		change \{rich_presence_context = presence_gigboard_and_setlist}
		return
	endif
	if (<online>)
		change \{rich_presence_context = presence_online}
	elseif ($rich_presence_context != presence_music_studio)
		switch ($game_mode)
			case p1_career
			change \{rich_presence_context = presence_career}
			case p2_career
			case p3_career
			case p4_career
			change \{rich_presence_context = presence_band_career}
			case p1_quickplay
			case p2_quickplay
			case p3_quickplay
			case p4_quickplay
			change \{rich_presence_context = presence_quickplay}
			case p2_pro_faceoff
			case p2_faceoff
			case p2_battle
			change \{rich_presence_context = presence_head_to_head}
			case training
			change \{rich_presence_context = presence_practice}
			case tutorial
			change \{rich_presence_context = presence_tutorial}
		endswitch
	endif
endscript

script get_custom_match_search_params 
	if (($searchgamemodevalue = 0) || ($searchgamemodevalue = 2))
		difficulty_checksum = ($filtertypes.diff.checksum [($searchdifficultyvalue)])
	else
		difficulty_checksum = dont_care
	endif
	return {
		difficulty = <difficulty_checksum>
		gamemode = ($filtertypes.mode.checksum [($searchgamemodevalue)])
		num_songs = ($filtertypes.num_songs.checksum [($searchnumsongsvalue)])
	}
endscript

script get_quick_match_search_params 
	scriptassert \{qs(0x26e58e31)}
endscript
bps3singlesignoncheckcomplete = 0

script xenon_singleplayer_session_init \{ps3_signin_callback = xenon_singleplayer_session_init}
	if checkforsignin
		netsessionfunc \{func = stats_uninit}
		netsessionfunc \{func = stats_init}
		netsessionfunc \{func = motd_init}
		if isxenon
			netsessionfunc \{func = start_singleplayer_session
				obj = session}
		endif
	else
		if NOT isxenon
			if ($is_attract_mode = 0)
				if NOT gotparam \{from_callback}
					if (0 = $bps3singlesignoncheckcomplete)
						netsessionfunc func = onlinesignin params = {callback = <ps3_signin_callback>}
						change \{bps3singlesignoncheckcomplete = 1}
					endif
				else
					printf \{qs(0x2d9e8584)}
					change \{ps3_signin_complete = 1}
				endif
			endif
		endif
	endif
endscript

script begin_singleplayer_game 
	if ($is_network_game = 1)
		if ishost
			if netsessionfunc \{obj = session
					func = has_active_session}
				netsessionfunc \{obj = session
					func = begin_singleplayer_game}
			endif
		endif
	else
		if netsessionfunc \{obj = session
				func = has_active_session}
			netsessionfunc \{obj = session
				func = begin_singleplayer_game}
		endif
	endif
endscript

script end_singleplayer_game 
	if netsessionfunc \{obj = session
			func = has_active_session}
		netsessionfunc \{obj = session
			func = end_singleplayer_game}
	endif
endscript

script xenon_singleplayer_session_begin_uninit 
	printscriptinfo \{qs(0x41f0baf1)}
	if isxenon
		if netsessionfunc \{obj = session
				func = is_singleplayer_session}
			netsessionfunc \{func = stop_singleplayer_session
				obj = session}
		endif
	endif
endscript

script xenon_singleplayer_session_complete_uninit 
	change \{net_safe_to_enter_net_play = 0}
	if NOT gotparam \{song_failed}
		wait \{3
			seconds}
	endif
	netsessionfunc \{obj = session
		func = unpost_game}
	change \{net_safe_to_enter_net_play = 1}
endscript

script send_leader_board_message 
	requireparams \{[
			song_checksum
		]
		all}
	<guitar_rating> = 0
	<bass_rating> = 0
	<drum_rating> = 0
	<vocals_rating> = 0
	<band_rating> = 5
	gamemode_getnumplayers
	players_on_team = (<num_players> / 2)
	if gamemode_iscooperative
		<players_on_team> = <num_players>
	endif
	if (<players_on_team> > 0)
		i = 1
		begin
		getplayerinfo <i> part
		getplayerinfo <i> difficulty
		switch (<difficulty>)
			case easy_rhythm
			<rating> = 1
			case easy
			<rating> = 2
			case medium
			<rating> = 3
			case hard
			<rating> = 4
			case expert
			<rating> = 5
		endswitch
		switch (<part>)
			case guitar
			<guitar_rating> = <rating>
			case bass
			<bass_rating> = <rating>
			case drum
			<drum_rating> = <rating>
			case vocals
			<vocals_rating> = <rating>
		endswitch
		if (<rating> < <band_rating>)
			<band_rating> = <rating>
		endif
		<i> = (<i> + 1)
		repeat (<players_on_team>)
	endif
	if (<bass_rating> = 0 || <drum_rating> = 0 || <vocals_rating> = 0 || <guitar_rating> = 0)
		<band_rating> = 0
	endif
	if ($game_mode = p1_career)
		get_single_career_lb_stats <...>
	elseif (($game_mode = p2_career || $game_mode = p3_career || $game_mode = p4_career) && ($coop_dlc_active = 0))
		get_multiplayer_career_lb_stats <...>
	else
		get_non_career_lb_stats <...>
	endif
	if NOT gotparam \{player_list}
		if NOT gotparam \{end_session}
			return
		elseif (<end_session> = 1)
			xenon_singleplayer_session_begin_uninit
			return
		else
			return
		endif
	endif
	printstruct channel = net <...>
	if NOT gotparam \{end_session}
		netsessionfunc func = stats_write_multiplayer obj = stats params = {player_list = <player_list>}
	else
		if (<end_session> = 1)
			netsessionfunc func = stats_write_multiplayer obj = stats params = {player_list = <player_list>}
		else
			netsessionfunc func = stats_write_multiplayer obj = stats params = {player_list = <player_list> dontendsessionafterwrite}
		endif
	endif
endscript

script get_single_career_lb_stats 
	printf \{channel = net
		qs(0xe7829c12)}
	player1_xuid = [0 0]
	get_player_num_from_controller controller_index = ($primary_controller)
	if (<player_num> = -1)
		if (<end_session> = 1)
			xenon_singleplayer_session_begin_uninit
		endif
		return
	endif
	getplayerinfo <player_num> difficulty
	if checksumequals a = <difficulty> b = easy_rhythm
		if (<end_session> = 1)
			xenon_singleplayer_session_begin_uninit
		endif
		return
	endif
	get_savegame_from_controller controller = ($primary_controller)
	get_current_band_info
	getglobaltags savegame = <savegame> <band_info> param = career_earnings
	controller = ($primary_controller)
	if checkforsignin controller_index = <controller>
		getnetid controller_index = <controller>
		setarrayelement arrayname = player1_xuid index = 0 newvalue = <net_id_first>
		setarrayelement arrayname = player1_xuid index = 1 newvalue = <net_id_second>
		getplayerinfo <player_num> part
		switch (<part>)
			case guitar
			career_leaderboard_id = lb_career_guitar
			case bass
			career_leaderboard_id = lb_career_bass
			case drum
			career_leaderboard_id = lb_career_drum
			case vocals
			career_leaderboard_id = lb_career_vocals
		endswitch
		get_progression_globals game_mode = ($game_mode) ($current_progression_flag)
		summation_career_score tier_global = <tier_global>
		getplayerinfo <player_num> score
		casttointeger \{score}
		switch (<difficulty>)
			case easy
			<rating> = 1
			<easy_score> = <score>
			<medium_score> = 0
			<hard_score> = 0
			<expert_score> = 0
			case medium
			<rating> = 2
			<easy_score> = 0
			<medium_score> = <score>
			<hard_score> = 0
			<expert_score> = 0
			case hard
			<rating> = 3
			<easy_score> = 0
			<medium_score> = 0
			<hard_score> = <score>
			<expert_score> = 0
			case expert
			<rating> = 4
			<easy_score> = 0
			<medium_score> = 0
			<hard_score> = 0
			<expert_score> = <score>
			default
			printf \{qs(0x8dd38a7c)}
		endswitch
		if (<score> > 0)
			player_list = [
				{
					player_xuid = <player1_xuid>
					team = 0
					leaderboards = [
						{
							leaderboard_id = <leaderboard_id>
							rating = <rating>
							score = <score>
							write_type = max
							columns = [
								{score = <easy_score>}
								{score = <medium_score>}
								{score = <hard_score>}
								{score = <expert_score>}
							]
						}
						{
							leaderboard_id = <career_leaderboard_id>
							rating = 0
							score = <career_score>
							write_type = max
							columns = [
								{score = <career_score>}
								{score = <career_score>}
								{score = <career_score>}
								{score = <career_score>}
							]
						}
						{
							leaderboard_id = lb_career_cash
							rating = 0
							score = <career_earnings>
							write_type = max
							columns = [
								{score = <career_earnings>}
								{score = <career_earnings>}
								{score = <career_earnings>}
								{score = <career_earnings>}
							]
						}
					]
				}
			]
			return player_list = <player_list>
		endif
	endif
endscript

script get_multiplayer_career_lb_stats 
	requireparams \{[
			song_checksum
		]
		all}
	printf \{channel = net
		qs(0xc6e29d1e)}
	career_leaderboard_id = lb_career_band
	get_progression_globals game_mode = ($game_mode) ($current_progression_flag)
	player_xuid = [0 0]
	player_list = []
	band_score = ($band1_status.score)
	casttointeger \{band_score}
	index = 1
	gamemode_getnumplayers
	begin
	<player_xuid> = [0 0]
	<rating> = 0
	<easy_score> = 0
	<medium_score> = 0
	<hard_score> = 0
	<expert_score> = 0
	getplayerinfo <index> is_local_client
	if ($is_network_game = 0 || ($is_network_game = 1 && <is_local_client> = 1))
		getplayerinfo <index> difficulty
		if NOT checksumequals a = <difficulty> b = easy_rhythm
			getplayerinfo <index> controller
			if checkforsignin controller_index = <controller>
				getnetid controller_index = <controller>
				setarrayelement arrayname = player_xuid index = 0 newvalue = <net_id_first>
				setarrayelement arrayname = player_xuid index = 1 newvalue = <net_id_second>
				summation_career_score tier_global = <tier_global>
				get_savegame_from_controller controller = <controller>
				get_current_band_info
				getglobaltags savegame = <savegame> <band_info> param = career_earnings
				getplayerinfo <index> part
				switch (<part>)
					case guitar
					part_text = 'guitar'
					case bass
					part_text = 'backup'
					case drum
					part_text = 'drums'
					case vocals
					part_text = 'mic'
					case rhythm
					part_text = 'backup'
					default
					part_text = 'none'
				endswitch
				get_song_struct song = <song_checksum>
				formattext checksumname = lb_song_id '%s_%p' s = (<song_struct>.name) p = <part_text>
				formattext checksumname = lb_band_song_id '%s_band' s = (<song_struct>.name)
				getplayerinfo <index> score
				casttointeger \{score}
				switch (<difficulty>)
					case easy
					<rating> = 1
					<easy_score> = <score>
					<medium_score> = 0
					<hard_score> = 0
					<expert_score> = 0
					case medium
					<rating> = 2
					<easy_score> = 0
					<medium_score> = <score>
					<hard_score> = 0
					<expert_score> = 0
					case hard
					<rating> = 3
					<easy_score> = 0
					<medium_score> = 0
					<hard_score> = <score>
					<expert_score> = 0
					case expert
					<rating> = 4
					<easy_score> = 0
					<medium_score> = 0
					<hard_score> = 0
					<expert_score> = <score>
				endswitch
				printf qs(0xf06e3e10) i = <index> p = <part> s = <score>
				if (<band_score> > 0)
					new_player_info = {
						player_xuid = <player_xuid>
						team = 0
						leaderboards = [
							{
								leaderboard_id = <career_leaderboard_id>
								rating = 0
								score = <career_score>
								write_type = max
								columns = [
									{score = <career_score>}
									{score = <career_score>}
									{score = <career_score>}
									{score = <career_score>}
								]
							}
							{
								leaderboard_id = <lb_band_song_id>
								rating = <band_rating>
								score = <band_score>
								write_type = max
								columns = [
									{score = <guitar_rating>}
									{score = <bass_rating>}
									{score = <drum_rating>}
									{score = <vocals_rating>}
								]
							}
							{
								leaderboard_id = lb_career_cash
								rating = 0
								score = <career_earnings>
								write_type = max
								columns = [
									{score = <career_earnings>}
									{score = <career_earnings>}
									{score = <career_earnings>}
									{score = <career_earnings>}
								]
							}
						]
					}
					addarrayelement array = <player_list> element = <new_player_info>
					<player_list> = <array>
				endif
			endif
		endif
	endif
	<index> = (<index> + 1)
	repeat <num_players>
	return player_list = <player_list>
endscript

script get_non_career_lb_stats 
	requireparams \{[
			song_checksum
		]
		all}
	printf \{channel = net
		qs(0x70f1fd94)}
	player_list = []
	<player_xuid> = [0 0]
	index = 1
	gamemode_getnumplayers
	begin
	<player_xuid> = [0 0]
	<rating> = 0
	<easy_score> = 0
	<medium_score> = 0
	<hard_score> = 0
	<expert_score> = 0
	getplayerinfo <index> is_local_client
	if ($is_network_game = 0 || ($is_network_game = 1 && <is_local_client> = 1))
		getplayerinfo <index> difficulty
		if NOT checksumequals a = <difficulty> b = easy_rhythm
			getplayerinfo <index> controller
			if checkforsignin controller_index = <controller>
				getnetid controller_index = <controller>
				setarrayelement arrayname = player_xuid index = 0 newvalue = <net_id_first>
				setarrayelement arrayname = player_xuid index = 1 newvalue = <net_id_second>
				get_savegame_from_controller controller = <controller>
				get_current_band_info
				getglobaltags savegame = <savegame> <band_info> param = career_earnings
				getplayerinfo <index> score
				casttointeger \{score}
				switch (<difficulty>)
					case easy
					<rating> = 1
					<easy_score> = <score>
					<medium_score> = 0
					<hard_score> = 0
					<expert_score> = 0
					case medium
					<rating> = 2
					<easy_score> = 0
					<medium_score> = <score>
					<hard_score> = 0
					<expert_score> = 0
					case hard
					<rating> = 3
					<easy_score> = 0
					<medium_score> = 0
					<hard_score> = <score>
					<expert_score> = 0
					case expert
					<rating> = 4
					<easy_score> = 0
					<medium_score> = 0
					<hard_score> = 0
					<expert_score> = <score>
				endswitch
				get_song_struct song = <song_checksum>
				getplayerinfo <index> part
				switch (<part>)
					case guitar
					part_text = 'guitar'
					case bass
					part_text = 'backup'
					case drum
					part_text = 'drums'
					case vocals
					part_text = 'mic'
					case rhythm
					part_text = 'backup'
					default
					part_text = 'none'
				endswitch
				formattext checksumname = lb_song_id '%s_%p' s = (<song_struct>.name) p = <part_text>
				formattext checksumname = lb_band_song_id '%s_band' s = (<song_struct>.name)
				printf qs(0xf06e3e10) i = <index> p = <part> s = <score>
				gamemode_gettype
				if (<num_players> > 1 && <type> = quickplay)
					band_score = ($band1_status.score)
					casttointeger \{band_score}
					if (<band_score> > 0)
						new_player_info = {
							player_xuid = <player_xuid>
							team = 0
							leaderboards = [
								{
									leaderboard_id = <lb_band_song_id>
									rating = <band_rating>
									score = <band_score>
									write_type = max
									columns = [
										{score = <guitar_rating>}
										{score = <bass_rating>}
										{score = <drum_rating>}
										{score = <vocals_rating>}
									]
								}
								{
									leaderboard_id = lb_career_cash
									rating = 0
									score = <career_earnings>
									write_type = max
									columns = [
										{score = <career_earnings>}
										{score = <career_earnings>}
										{score = <career_earnings>}
										{score = <career_earnings>}
									]
								}
							]
						}
						addarrayelement array = <player_list> element = <new_player_info>
						<player_list> = <array>
					endif
				else
					if (<score> > 0)
						new_player_info = {
							player_xuid = <player_xuid>
							team = 0
							leaderboards = [
								{
									leaderboard_id = <lb_song_id>
									rating = <rating>
									score = <score>
									write_type = max
									columns = [
										{score = <easy_score>}
										{score = <medium_score>}
										{score = <hard_score>}
										{score = <expert_score>}
									]
								}
								{
									leaderboard_id = lb_career_cash
									rating = 0
									score = <career_earnings>
									write_type = max
									columns = [
										{score = <career_earnings>}
										{score = <career_earnings>}
										{score = <career_earnings>}
										{score = <career_earnings>}
									]
								}
							]
						}
						addarrayelement array = <player_list> element = <new_player_info>
						<player_list> = <array>
					endif
				endif
			endif
		endif
	endif
	<index> = (<index> + 1)
	repeat <num_players>
	return player_list = <player_list>
endscript

script net_write_single_player_stats 
	printf \{channel = net
		qs(0xca49d267)}
	requireparams \{[
			song_checksum
		]
		all}
	net_retrieve_controller_scores
	if (<total_score> > 0)
		if achievements_ischeatingautokick
			autokick_cheating = 1
		else
			autokick_cheating = 0
		endif
		if NOT (($game_mode = p2_battle) || ($game_mode = practice) || $cheat_freedrum = 1 || $cheat_alwaysslide = 1 || (<autokick_cheating> = 1) || ($game_mode = p2_faceoff))
			if ($game_mode = p2_career || $game_mode = p3_career || $game_mode = p4_career)
				casttointeger \{total_score}
				get_song_struct song = <song_checksum>
				formattext checksumname = band_song_checksum '%s_band' s = (<song_struct>.name)
				send_leader_board_message score = <total_score> leaderboard_id = <band_song_checksum> end_session = <end_session> song_checksum = <song_checksum>
			else
				primary_player_score = (<scores> [<primary_index>])
				casttointeger \{primary_player_score}
				net_retrieve_primary_controller_part
				primary_player_part = <primary_part>
				switch (<primary_player_part>)
					case guitar
					part = 'guitar'
					case bass
					part = 'backup'
					case drum
					part = 'drums'
					case vocals
					part = 'mic'
					case rhythm
					part = 'backup'
					default
					part = 'none'
				endswitch
				get_song_struct song = <song_checksum>
				formattext checksumname = lb_song_id '%s_%p' s = (<song_struct>.name) p = <part>
				send_leader_board_message score = <primary_player_score> leaderboard_id = <lb_song_id> end_session = <end_session> song_checksum = <song_checksum>
			endif
		else
			if (<end_session> = 1)
				printstruct <...>
				xenon_singleplayer_session_begin_uninit
			endif
		endif
	else
		if (<end_session> = 1)
			printstruct <...>
			xenon_singleplayer_session_begin_uninit
		endif
	endif
endscript

script net_retrieve_controller_scores 
	gamemode_getnumplayers
	total_score = 0
	index = 1
	primary_index = 0
	<array> = []
	begin
	getplayerinfo <index> score
	casttointeger \{score}
	getplayerinfo <index> controller
	if (<controller> = $primary_controller)
		<primary_index> = (<index> - 1)
	endif
	addarrayelement array = <array> element = <score>
	<total_score> = (<total_score> + <score>)
	printstruct <...>
	<index> = (<index> + 1)
	repeat <num_players>
	player_scores = <array>
	return {
		scores = <player_scores>
		total_score = <total_score>
		primary_index = <primary_index>
	}
endscript

script net_retrieve_primary_controller_part 
	if (($player1_status.controller) = ($primary_controller))
		return primary_part = ($player1_status.part)
	elseif (($player2_status.controller) = ($primary_controller))
		return primary_part = ($player2_status.part)
	else
		return \{primary_part = guitar}
	endif
endscript

script summation_career_score 
	printf \{channel = net
		qs(0x05b1d75d)}
	setlist_prefix = ($<tier_global>.prefix)
	printstruct channel = net <...>
	career_score = 0
	tier = 1
	begin
	formattext checksumname = tiername '%ptier%i' p = <setlist_prefix> i = <tier>
	formattext checksumname = tier_checksum 'tier%s' s = <tier>
	getarraysize ($<tier_global>.<tier_checksum>.songs)
	array_count = 0
	begin
	<best_score> = 0
	diff_index = 0
	begin
	format_globaltag_song_checksum part = ($<tier_global>.part) song = ($<tier_global>.<tier_checksum>.songs [<array_count>]) difficulty_index = <diff_index>
	getglobaltags <song_checksum> params = score
	if (<score> > <best_score>)
		<best_score> = <score>
	endif
	<diff_index> = (<diff_index> + 1)
	repeat 5
	printf channel = net qs(0x50cabb73) s = <best_score> a = <song_checksum> c = <career_score>
	<career_score> = (<career_score> + <best_score>)
	array_count = (<array_count> + 1)
	repeat <array_size>
	tier = (<tier> + 1)
	repeat ($<tier_global>.num_tiers)
	casttointeger \{career_score}
	printf qs(0xd5a77f29) c = <career_score>
	return career_score = <career_score>
endscript

script online_song_end_write_stats 
	requireparams \{[
			song_checksum
		]
		all}
	printf \{qs(0x2b1ceec3)}
	player_xuid = [0 0]
	player_list = []
	guitar_rating = 0
	bass_rating = 0
	drum_rating = 0
	vocals_rating = 0
	band_rating = 5
	gamemode_getnumplayers
	players_on_team = (<num_players> / 2)
	if gamemode_iscooperative
		<players_on_team> = <num_players>
	endif
	i = 1
	begin
	getplayerinfo <i> part
	getplayerinfo <i> difficulty
	switch (<difficulty>)
		case easy_rhythm
		<rating> = 1
		case easy
		<rating> = 2
		case medium
		<rating> = 3
		case hard
		<rating> = 4
		case expert
		<rating> = 5
	endswitch
	switch (<part>)
		case guitar
		<guitar_rating> = <rating>
		case bass
		<bass_rating> = <rating>
		case drum
		<drum_rating> = <rating>
		case vocals
		<vocals_rating> = <rating>
	endswitch
	if (<rating> < <band_rating>)
		<band_rating> = <rating>
	endif
	<i> = (<i> + 1)
	repeat (<players_on_team>)
	if (<bass_rating> = 0 || <drum_rating> = 0 || <vocals_rating> = 0 || <guitar_rating> = 0)
		<band_rating> = 0
	endif
	gamemode_gettype
	if (<type> = quickplay)
		band_score = ($band1_status.score)
		casttointeger \{band_score}
		index = 1
		begin
		<player_xuid> = [0 0]
		<rating> = 0
		<easy_score> = 0
		<medium_score> = 0
		<hard_score> = 0
		<expert_score> = 0
		getplayerinfo <index> is_local_client
		if (<is_local_client> = 1)
			getplayerinfo <index> difficulty
			if NOT checksumequals a = <difficulty> b = easy_rhythm
				getplayerinfo <index> net_id_first
				getplayerinfo <index> net_id_second
				setarrayelement arrayname = player_xuid index = 0 newvalue = <net_id_first>
				setarrayelement arrayname = player_xuid index = 1 newvalue = <net_id_second>
				getplayerinfo <index> part
				switch (<part>)
					case guitar
					part_text = 'guitar'
					case bass
					part_text = 'backup'
					case drum
					part_text = 'drums'
					case vocals
					part_text = 'mic'
					case rhythm
					part_text = 'backup'
					default
					part_text = 'none'
				endswitch
				get_song_struct song = <song_checksum>
				formattext checksumname = lb_song_id '%s_%p' s = (<song_struct>.name) p = <part_text>
				formattext checksumname = lb_band_song_id '%s_band' s = (<song_struct>.name)
				getplayerinfo <index> score
				casttointeger \{score}
				switch (<difficulty>)
					case easy
					<rating> = 1
					<easy_score> = <score>
					<medium_score> = 0
					<hard_score> = 0
					<expert_score> = 0
					case medium
					<rating> = 2
					<easy_score> = 0
					<medium_score> = <score>
					<hard_score> = 0
					<expert_score> = 0
					case hard
					<rating> = 3
					<easy_score> = 0
					<medium_score> = 0
					<hard_score> = <score>
					<expert_score> = 0
					case expert
					<rating> = 4
					<easy_score> = 0
					<medium_score> = 0
					<hard_score> = 0
					<expert_score> = <score>
				endswitch
				if (<score> > 0)
					gamemode_gettype
					if (<num_players> > 1)
						getplayerinfo <index> controller
						get_savegame_from_controller controller = <controller>
						get_current_band_info
						getglobaltags savegame = <savegame> <band_info> param = career_earnings
						new_player_info = {
							player_xuid = <player_xuid>
							team = 0
							leaderboards = [
								{
									leaderboard_id = <lb_band_song_id>
									rating = <band_rating>
									score = <band_score>
									write_type = max
									columns = [
										{score = <guitar_rating>}
										{score = <bass_rating>}
										{score = <drum_rating>}
										{score = <vocals_rating>}
									]
								}
								{
									leaderboard_id = lb_career_cash
									rating = 0
									score = <career_earnings>
									write_type = max
									columns = [
										{score = <career_earnings>}
										{score = <career_earnings>}
										{score = <career_earnings>}
										{score = <career_earnings>}
									]
								}
							]
						}
					endif
					addarrayelement array = <player_list> element = <new_player_info>
					<player_list> = <array>
				endif
			endif
		endif
		<index> = (<index> + 1)
		repeat <num_players>
	endif
	if gotparam \{player_list}
		netsessionfunc func = stats_write_multiplayer obj = stats params = {player_list = <player_list>}
	else
		netsessionfunc \{obj = session
			func = end_active_session}
	endif
endscript

script online_match_end_write_stats 
	write_stats = 0
	if isxenon
		if (netsessionfunc func = isranked obj = match)
			write_stats = 1
		endif
	else
		if ($game_mode = p2_coop)
			write_stats = 0
		else
			write_stats = 1
		endif
	endif
	if (<write_stats> = 1)
		getglobaltags \{net}
		net_get_game_mode_leaderboard_id
		switch ($game_mode)
			case p2_faceoff
			<total_win_lose_leaderboard_id> = lb_faceoff_winratio
			<streak_leaderboard_id> = lb_faceoff_win_streak
			<streak_score> = <face_off_streak>
			<wins> = <faceoff_wins>
			<loses> = <faceoff_loses>
			case p2_pro_faceoff
			<total_win_lose_leaderboard_id> = lb_pro_faceoff_winratio
			<streak_leaderboard_id> = lb_pro_faceoff_win_streak
			<streak_score> = <pro_face_off_streak>
			<wins> = <pro_faceoff_wins>
			<loses> = <pro_faceoff_loses>
			case p2_battle
			<total_win_lose_leaderboard_id> = lb_battle_winratio
			<streak_leaderboard_id> = lb_battle_win_streak
			<streak_score> = <battle_streak>
			<wins> = <battle_wins>
			<loses> = <battle_loses>
			default
			total_win_lose_leaderboard_id = lb_faceoff_winratio
			streak_leaderboard_id = lb_faceoff_win_streak
			streak_score = 0
			wins = 0
			loses = 0
		endswitch
		prepare_player_list_array {
			p1_leaderboard_id = <p1_leaderboard_id>
			p2_leaderboard_id = <p2_leaderboard_id>
			total_win_lose_leaderboard_id = <total_win_lose_leaderboard_id>
			streak_leaderboard_id = <streak_leaderboard_id>
			streak_score = <streak_score>
			wins = <wins>
			loses = <loses>
		}
		if gotparam \{player_list}
			netsessionfunc func = stats_write_multiplayer obj = stats params = {player_list = <player_list>}
		endif
	endif
	wait \{3
		seconds}
	netsessionfunc \{obj = stats
		func = end_write_stats}
endscript

script net_get_highest_coop_difficulty 
	if ((($player1_status.difficulty) = expert) || (($player2_status.difficulty) = expert))
		return \{highest_diff = expert}
	endif
	if ((($player1_status.difficulty) = hard) || (($player2_status.difficulty) = hard))
		return \{highest_diff = hard}
	endif
	if ((($player1_status.difficulty) = medium) || (($player2_status.difficulty) = medium))
		return \{highest_diff = medium}
	endif
	return \{highest_diff = easy}
endscript

script online_set_win_losses_streak \{out_come = lose}
	getglobaltags \{net}
	switch ($game_mode)
		case p2_battle
		if (<out_come> = win)
			setglobaltags net params = {battle_streak = (<battle_streak> + 1) battle_wins = (<battle_wins> + 1)}
		else
			setglobaltags net params = {battle_streak = 0 battle_loses = (<battle_loses> + 1)}
		endif
		case p2_faceoff
		if (<out_come> = win)
			setglobaltags net params = {face_off_streak = (<face_off_streak> + 1) faceoff_wins = (<faceoff_wins> + 1)}
		else
			setglobaltags net params = {face_off_streak = 0 faceoff_loses = (<faceoff_loses> + 1)}
		endif
		case p2_pro_faceoff
		if (<out_come> = win)
			setglobaltags net params = {pro_face_off_streak = (<pro_face_off_streak> + 1) pro_faceoff_wins = (<pro_faceoff_wins> + 1)}
		else
			setglobaltags net params = {pro_face_off_streak = 0 pro_faceoff_loses = (<pro_faceoff_loses> + 1)}
		endif
	endswitch
endscript

script net_get_game_mode_leaderboard_id 
	switch ($game_mode)
		case p2_faceoff
		formattext checksumname = leaderboard_id_p1 'lb_faceoff_%s' s = ($leaderboard_difficulty_lookup_table.($player1_status.difficulty))
		formattext checksumname = leaderboard_id_p2 'lb_faceoff_%s' s = ($leaderboard_difficulty_lookup_table.($player2_status.difficulty))
		case p2_pro_faceoff
		formattext checksumname = leaderboard_id_p1 'lb_pro_faceoff_%s' s = ($leaderboard_difficulty_lookup_table.($player1_status.difficulty))
		formattext checksumname = leaderboard_id_p2 'lb_pro_faceoff_%s' s = ($leaderboard_difficulty_lookup_table.($player2_status.difficulty))
		case p2_battle
		formattext checksumname = leaderboard_id_p1 'lb_battle_%s' s = ($leaderboard_difficulty_lookup_table.($player1_status.difficulty))
		formattext checksumname = leaderboard_id_p2 'lb_battle_%s' s = ($leaderboard_difficulty_lookup_table.($player2_status.difficulty))
	endswitch
	return {p1_leaderboard_id = <leaderboard_id_p1> p2_leaderboard_id = <leaderboard_id_p2>}
endscript

script prepare_player_list_array 
	net_stats_calculate_wins
	player1_xuid = [0 0]
	player2_xuid = [0 0]
	setarrayelement arrayname = player1_xuid index = 0 newvalue = ($player1_status.net_id_first)
	setarrayelement arrayname = player1_xuid index = 1 newvalue = ($player1_status.net_id_second)
	setarrayelement arrayname = player2_xuid index = 0 newvalue = ($player2_status.net_id_first)
	setarrayelement arrayname = player2_xuid index = 1 newvalue = ($player2_status.net_id_second)
	if (<p1_wins> = <p2_wins>)
		return
	elseif (<p1_wins> > <p2_wins>)
		return
		get_match_type_leaderboard_info \{p1_wins_value = 1
			p1_loses_value = 0
			p2_wins_value = 0
			p2_loses_value = 1}
		getleaderboardwinlosevalue win = (<wins> + 1) lose = <loses>
		online_set_win_losses_streak \{out_come = win}
		player_list = [
			{
				player_xuid = <player1_xuid>
				team = 0
				leaderboards = [
					{
						leaderboard_id = <p1_leaderboard_id>
						rating = 0
						score = <score1>
						write_type = <write_type>
						columns = [
							{score = <attrib_acum1>}
							{score = <attrib_score1>}
							{score = <attrib_tot1>}
						]
					}
					{
						leaderboard_id = <total_win_lose_leaderboard_id>
						rating = 0
						score = <winlosevalue>
						write_type = last
						columns = [
							{score = <winlosevalue>}
							{score = <winlosevalue>}
							{score = <winlosevalue>}
						]
					}
					{
						leaderboard_id = <streak_leaderboard_id>
						rating = 0
						score = (<streak_score> + 1)
						write_type = last
						columns = [
							{score = (<streak_score> + 1)}
							{score = (<streak_score> + 1)}
							{score = (<streak_score> + 1)}
						]
					}
				]
			}
			{
				player_xuid = <player2_xuid>
				team = 0
				leaderboards = [
					{
						leaderboard_id = <p2_leaderboard_id>
						rating = 0
						score = <score2>
						write_type = <write_type>
						columns =
						[
							{score = <attrib_acum2>}
							{score = <attrib_score2>}
							{score = <attrib_tot2>}
						]
					}
				]
			}
		]
	elseif (<p1_wins> < <p2_wins>)
		return
		get_match_type_leaderboard_info \{p1_wins_value = 0
			p1_loses_value = 1
			p2_wins_value = 1
			p2_loses_value = 0}
		getleaderboardwinlosevalue win = <wins> lose = (<loses> + 1)
		online_set_win_losses_streak \{outcome = lose}
		player_list = [
			{
				player_xuid = <player2_xuid>
				team = 0
				leaderboards = [
					{
						leaderboard_id = <p2_leaderboard_id>
						rating = 0
						score = <score2>
						write_type = <write_type>
						columns = [
							{score = <attrib_acum2>}
							{score = <attrib_score2>}
							{score = <attrib_tot2>}
						]
					}
				]
			}
			{
				player_xuid = <player1_xuid>
				team = 0
				leaderboards = [
					{
						leaderboard_id = <p1_leaderboard_id>
						rating = 0
						score = <score1>
						write_type = <write_type>
						columns = [
							{score = <attrib_acum1>}
							{score = <attrib_score1>}
							{score = <attrib_tot1>}
						]
					}
					{
						leaderboard_id = <total_win_lose_leaderboard_id>
						rating = 0
						score = <winlosevalue>
						write_type = last
						columns = [
							{score = <winlosevalue>}
							{score = <winlosevalue>}
							{score = <winlosevalue>}
						]
					}
					{
						leaderboard_id = <streak_leaderboard_id>
						rating = 0
						score = 0
						write_type = last
						columns = [
							{score = 0}
							{score = 0}
							{score = 0}
						]
					}
				]
			}
		]
	endif
	return player_list = <player_list>
endscript

script get_match_type_leaderboard_info 
	if NOT ($game_mode = p2_battle)
		net_stats_calculate_total_scores
		player1_score = <p1_score>
		casttointeger \{player1_score}
		player2_score = <p2_score>
		casttointeger \{player2_score}
		return {
			write_type = max
			score1 = <player1_score>
			attrib_acum1 = <player1_score>
			attrib_score1 = <player1_score>
			attrib_tot1 = 0
			score2 = <player2_score>
			attrib_acum2 = <player2_score>
			attrib_score2 = <player2_score>
			attrib_tot2 = 0
		}
	else
		return {
			write_type = accumulate
			score1 = <p1_wins_value>
			attrib_acum1 = <p1_wins_value>
			attrib_score1 = <p1_wins_value>
			attrib_tot1 = 0
			score2 = <p2_wins_value>
			attrib_acum2 = <p2_wins_value>
			attrib_score2 = <p2_wins_value>
			attrib_tot2 = 0
		}
	endif
endscript

script network_player_lobby_message 
	if NOT ((<type> = open_comm) || (<type> = ready_up))
		return
	endif
	switch <type>
		case character_select
		<selection_type> = 0
		case character_hub_select
		<selection_type> = 1
		case outfit_select
		<selection_type> = 2
		case style_select
		<selection_type> = 3
		case guitar_select
		<selection_type> = 4
		case skin_select
		<selection_type> = 5
		case song_select
		<selection_type> = 6
		case ready_up
		<selection_type> = 7
		case open_comm
		<selection_type> = 8
	endswitch
	switch <action>
		case update
		<selection_action> = 0
		case deselect
		<selection_action> = 1
		case select
		<selection_action> = 2
	endswitch
	if gotparam \{value1}
		<selection_index1> = <value1>
	else
		<selection_index1> = 0
	endif
	if gotparam \{value2}
		<selection_index2> = <value2>
	else
		<selection_index2> = 0
	endif
	if gotparam \{checksum}
		<checksum_value> = <checksum>
	else
		<checksum_value> = null
	endif
	lobby_data = {
		selection_type = <selection_type>
		selection_action = <selection_action>
		selection_index1 = <selection_index1>
		selection_index2 = <selection_index2>
		net_checksum = <checksum_value>
	}
	sendstructure callback = network_player_lobby_update data_to_send = {lobby_data = <lobby_data>}
endscript

script net_request_play_show 
	if (($p1_ready = 1) && ($p2_ready = 1))
		return
	endif
	if (<action> = 1)
		if ($p1_ready = 0)
			if screenelementexists \{id = vmenu_character_hub_p1}
				launchevent \{type = unfocus
					target = vmenu_character_hub_p1}
			endif
			sendnetmessage {
				type = lobby_ready
				ready_status = <action>
			}
		endif
	else
		if ($p1_ready = 1)
			if screenelementexists \{id = vmenu_character_hub_p1}
				launchevent \{type = unfocus
					target = vmenu_character_hub_p1}
			endif
			sendnetmessage {
				type = lobby_ready
				ready_status = <action>
			}
		else
			character_hub_go_back \{player = 1}
		endif
	endif
endscript

script net_request_play_show_ack 
	if (($p1_ready = 1) && ($p2_ready = 1))
		return
	endif
	if gotparam \{action}
		if (<action> = 0)
			if (<player> = 1)
				character_hub_go_back player = <player>
			else
				character_hub_net_ready_back
			endif
		else
			if (<player> = 1)
				character_hub_select_play_show player = <player>
				if screenelementexists \{id = vmenu_character_hub_p1}
					launchevent \{type = focus
						target = vmenu_character_hub_p1}
				endif
			else
				character_hub_net_ready
			endif
		endif
	endif
endscript

script net_pausegh 
	printf \{qs(0x13c91937)}
	change \{net_pause = 1}
	broadcastevent \{type = event_pause_game}
	generic_event_choose \{state = uistate_pausemenu}
	wait \{1
		gameframe}
endscript

script net_unpausegh 
	printf \{qs(0x8609ed1f)}
	ui_event \{event = menu_back
		data = {
			state = uistate_gameplay
		}}
	wait \{1
		gameframe}
	change \{net_pause = 0}
endscript

script gameinvite_server_unavailable 
	printf \{qs(0x071785f3)}
	net_party_attempted_join_result \{join_result = 0
		join_mode = failed_invite_search
		reason = bad_state}
endscript

script destroy_join_refuse_dialog 
	destroy_connection_dialog_scroller
	destroy_popup_warning_menu
endscript

script createjoinrefuseddialog 
	scriptassert \{qs(0x2c2b1078)}
endscript

script create_net_popup \{title = qs(0x00000000)
		popup_text = qs(0x00000000)}
	destroy_net_popup
	change \{net_popup_active = 1}
	create_popup_warning_menu {
		title = <title>
		textblock = {
			text = <popup_text>
		}
		no_background
	}
endscript

script append_animating_dots 
	printf \{qs(0xcbc6ba89)}
	num_dots = 0
	if screenelementexists id = <id>
		begin
		formattext textname = new_text qs(0x5994d4f6) a = <text> b = ($dots_array [<num_dots>])
		<id> :se_setprops text = <new_text>
		if (<num_dots> = 3)
			<num_dots> = 0
		else
			<num_dots> = (<num_dots> + 1)
		endif
		wait \{0.5
			second}
		repeat
	endif
endscript

script destroy_net_popup 
	change \{net_popup_active = 0}
	destroy_popup_warning_menu
endscript

script showjointimeoutnotice 
	cancel_join_server
	setup_sessionfuncs
	spawnscriptnow \{timeout_connection_attempt}
endscript

script timeout_connection_attempt 
	create_timeout_dialog
	ui_flow_manager_respond_to_action \{action = timeout}
	net_repeat_last_search
endscript

script failedtocreategame 
	cancel_join_server
	setup_sessionfuncs
	create_failed_connection_dialog
endscript

script destroy_connection_dialog_scroller 
	if screenelementexists \{id = connection_dialog_scroller}
		destroyscreenelement \{id = connection_dialog_scroller}
	endif
	destroy_net_popup
endscript

script create_timeout_dialog 
	destroy_pause_menu_frame
	destroy_menu \{menu_id = pu_warning_scroll}
	destroy_menu \{menu_id = popup_warning_container}
	createscreenelement \{type = vscrollingmenu
		parent = root_window
		id = connection_dialog_scroller
		just = [
			center
			top
		]
		dims = (400.0, 480.0)
		pos = (640.0, 400.0)
		z_priority = 1.0}
	createscreenelement {
		type = vmenu
		parent = connection_dialog_scroller
		id = connection_dialog_vmenu
		pos = (0.0, 0.0)
		just = [left top]
		internal_just = [center top]
		dims = (400.0, 480.0)
		event_handlers = [
			{pad_choose ui_flow_manager_respond_to_action params = {action = go_back}}
			{pad_choose destroy_connection_dialog_scroller}
		]
		exclusive_device = ($primary_controller)
	}
	add_searching_menu_item \{vmenu_id = connection_dialog_vmenu
		choose_script = empty_script
		z = 200.1
		text = qs(0x182f0173)}
	createscreenelement \{type = containerelement
		parent = root_window
		id = net_popup_container
		just = [
			center
			center
		]
		pos = (0.0, 0.0)}
	createscreenelement {
		type = textblockelement
		parent = net_popup_container
		font = fontgrid_title_a1
		scale = 1.0
		rgba = ($online_light_blue)
		text = qs(0x8a2924d4)
		pos = (640.0, 300.0)
		dims = (375.0, 200.0)
		z_priority = 200.0
		just = [center center]
	}
	launchevent \{type = focus
		target = connection_dialog_vmenu}
endscript

script create_failed_connection_dialog 
	destroy_pause_menu_frame
	destroy_menu \{menu_id = pu_warning_scroll}
	destroy_menu \{menu_id = popup_warning_container}
	createscreenelement \{type = vscrollingmenu
		parent = root_window
		id = connection_dialog_scroller
		just = [
			center
			top
		]
		dims = (400.0, 480.0)
		pos = (640.0, 400.0)
		z_priority = 1.0}
	createscreenelement {
		type = vmenu
		parent = connection_dialog_scroller
		id = connection_dialog_vmenu
		pos = (0.0, 0.0)
		just = [left top]
		internal_just = [center top]
		dims = (400.0, 480.0)
		event_handlers = [
			{pad_choose ui_flow_manager_respond_to_action params = {action = go_back}}
			{pad_choose cancel_join_server}
			{pad_choose destroy_connection_dialog_scroller}
		]
		exclusive_device = ($primary_controller)
	}
	add_searching_menu_item \{vmenu_id = connection_dialog_vmenu
		choose_script = empty_script
		z = 200.1
		text = qs(0x182f0173)}
	createscreenelement \{type = containerelement
		parent = root_window
		id = net_popup_container
		just = [
			center
			center
		]
		pos = (0.0, 0.0)}
	createscreenelement {
		type = textblockelement
		parent = net_popup_container
		font = fontgrid_title_a1
		scale = 1.0
		rgba = ($online_light_blue)
		text = qs(0x2677f0a3)
		pos = (640.0, 315.0)
		dims = (375.0, 200.0)
		z_priority = 200.0
		just = [center center]
	}
	launchevent \{type = focus
		target = connection_dialog_vmenu}
endscript

script net_repeat_last_search 
	wait \{1
		gameframe}
	ui_flow_manager_respond_to_action \{action = select_done}
endscript

script check_if_selecting_tie_breaker \{player = 1}
	if ishost
		if (($tie_breaker = host) && (<player> = 1))
			return \{selecting_tiebreaker = 1}
		endif
		if (($tie_breaker = client) && (<player> = 2))
			return \{selecting_tiebreaker = 1}
		endif
	else
		if (($tie_breaker = host) && (<player> = 2))
			return \{selecting_tiebreaker = 1}
		endif
		if (($tie_breaker = client) && (<player> = 1))
			return \{selecting_tiebreaker = 1}
		endif
	endif
	return \{selecting_tiebreaker = 0}
endscript

script test_events \{passed_in_value = 'test value'}
	printf \{qs(0x37c22cf4)}
	printstruct <...>
	netsessionfunc \{obj = stats
		func = write_key_value
		params = {
			wtf_value = 'test value'
			key = 'test key'
		}}
endscript

script net_failed_signin 
	printf \{qs(0xa15e7d04)}
	if ($respond_to_signin_changed = 0)
		return
	endif
	if (($ui_flow_manager_state [0]) = online_signin_fs)
		ui_flow_manager_respond_to_action \{action = go_back}
	endif
endscript

script xbox360_live_not_allowed 
	printf \{'xbox360_live_not_allowed'}
	clean_up_user_control_helpers
	destroy_menu_backdrop
	if screenelementexists \{id = warning_message_container}
		destroyscreenelement \{id = warning_message_container}
	endif
	create_menu_backdrop \{texture = xb_online_bg}
	event_handlers = [
		{pad_up generic_menu_up_or_down_sound params = {up}}
		{pad_down generic_menu_up_or_down_sound params = {down}}
		{pad_back online_signin_select_cancel}
	]
	z = 100.0
	<menu_pos> = (640.0, 465.0)
	<bookend_r_pos> = (710.0, 533.0)
	<bookend_l_pos> = (500.0, 533.0)
	new_menu scrollid = sign_in_scoller vmenuid = sign_in_vmenu use_backdrop = (0) menu_pos = <menu_pos> just = [left top] event_handlers = <event_handlers> spacing = -45
	createscreenelement \{type = containerelement
		parent = root_window
		id = signin_container
		pos = (0.0, 0.0)}
	change \{menu_focus_color = [
			180
			50
			50
			255
		]}
	change \{menu_unfocus_color = [
			0
			0
			0
			255
		]}
	create_pause_menu_frame \{parent = signin_container
		z = 5}
	displaysprite \{parent = signin_container
		tex = dialog_title_bg
		dims = (224.0, 224.0)
		z = 9
		pos = (640.0, 100.0)
		just = [
			right
			top
		]
		flip_v}
	displaysprite \{parent = signin_container
		tex = dialog_title_bg
		dims = (224.0, 224.0)
		z = 9
		pos = (640.0, 100.0)
		just = [
			left
			top
		]}
	displaysprite \{parent = signin_container
		id = options_bg_1
		tex = dialog_menu_bg
		pos = (640.0, 500.0)
		dims = (320.0, 64.0)
		z = 9
		just = [
			center
			botom
		]}
	displaysprite \{parent = signin_container
		id = options_bg_2
		tex = dialog_menu_bg
		pos = (640.0, 530.0)
		dims = (320.0, 64.0)
		z = 9
		just = [
			center
			top
		]
		flip_h}
	createscreenelement \{type = textelement
		parent = signin_container
		font = fontgrid_title_a1
		scale = 1.3
		rgba = [
			223
			223
			223
			250
		]
		text = qs(0xaa163738)
		just = [
			center
			top
		]
		z_priority = 10.0
		pos = (640.0, 175.0)
		shadow
		shadow_offs = (3.0, 3.0)
		shadow_rgba = [
			0
			0
			0
			255
		]}
	if isxenon
		<sign_in_text> = qs(0x076f1bf2)
	else
		if gotparam \{age_restricted}
			<sign_in_text> = qs(0x052f0757)
		else
			<sign_in_text> = qs(0xb7c0cb6f)
		endif
	endif
	scale = 1
	stringlength string = <sign_in_text>
	printf qs(0xc76cea38) d = <str_len>
	if (<str_len> >= 135)
		<scale> = 0.8
	endif
	createscreenelement {
		type = textblockelement
		parent = signin_container
		font = fontgrid_title_a1
		scale = 0.6
		rgba = [210 210 210 250]
		text = <sign_in_text>
		just = [center top]
		internal_just = [center top]
		internal_scale = <scale>
		z_priority = 10.0
		pos = (640.0, 310.0)
		dims = (800.0, 320.0)
		line_spacing = 1.0
	}
	createscreenelement \{type = containerelement
		parent = sign_in_vmenu
		dims = (0.0, 100.0)
		event_handlers = [
			{
				focus
				net_warning_focus
			}
			{
				unfocus
				net_warning_unfocus
			}
			{
				pad_choose
				ui_flow_manager_respond_to_action
				params = {
					action = go_back
				}
			}
		]}
	container_id = <id>
	createscreenelement {
		type = textelement
		parent = <container_id>
		local_id = text
		font = fontgrid_title_a1
		scale = 0.85
		rgba = ($menu_unfocus_color)
		text = qs(0x182f0173)
		just = [center top]
		z_priority = (<z> + 5)
	}
	fit_text_into_menu_item id = <id> max_width = 240
	getscreenelementdims id = <id>
	createscreenelement {
		type = spriteelement
		parent = <container_id>
		local_id = bookend_left
		texture = dialog_menu_hilight
		just = [right center]
		pos = ((0.0, 20.0) + (1.0, 0.0) * (<width> / (-2)))
		alpha = 0.0
		z_priority = (<z> + 6)
		scale = (1.0, 1.0)
		flip_v
	}
	createscreenelement {
		type = spriteelement
		parent = <container_id>
		local_id = bookend_right
		texture = dialog_menu_hilight
		just = [left center]
		pos = ((0.0, 20.0) + (1.0, 0.0) * (<width> / (2)))
		alpha = 0.0
		z_priority = (<z> + 6)
		scale = (1.0, 1.0)
	}
	add_user_control_helper \{text = qs(0xc18d5e76)
		button = green
		z = 100}
	add_user_control_helper \{text = qs(0xaf4d5dd2)
		button = red
		z = 100}
	launchevent \{type = focus
		target = sign_in_vmenu}
endscript

script xenon_auto_load_progress 
	printf \{qs(0x280d9b3b)}
	if (($ui_flow_manager_state [0]) = online_signin_fs)
		if ($online_signin_autoload_required = 1)
			change \{online_signin_autoload_required = 0}
			change \{respond_to_signin_changed = 0}
			printf \{'respond_to_signin_changed = 0'}
			printscriptinfo
			fadetoblack \{on
				time = 0
				alpha = 1.0
				z_priority = 20000
				id = invite_screenfader}
			wait \{1
				gameframe}
			stoprendering
			shutdown_game_for_signin_change \{signin_change = 1}
			launchevent \{type = unfocus
				target = root_window}
			startrendering
			wait \{1
				gameframe}
			fadetoblack \{off
				time = 0
				id = invite_screenfader}
			wait \{1
				gameframe}
			change invite_controller = ($primary_controller)
			ui_event \{event = menu_change
				data = {
					state = uistate_boot_iis
					clear_previous_stack
				}}
		else
			ui_flow_manager_respond_to_action \{action = online_enabled}
		endif
	endif
endscript

script scale_element_to_size \{time = 0}
	if NOT gotparam \{id}
		printf \{'Did not pass in id to scale_element_to_size! Returning'}
		return
	endif
	getscreenelementdims id = <id>
	orig_height = <height>
	orig_width = <width>
	if NOT gotparam \{target_width}
		target_width = <orig_width>
	endif
	if NOT gotparam \{target_height}
		target_height = <orig_height>
	endif
	xscale = (<target_width> / (<orig_width> * 1.0))
	yscale = (<target_height> / (<orig_height> * 1.0))
	<id> :legacydomorph scale = (<xscale> * (1.0, 0.0) + <yscale> * (0.0, 1.0)) time = <time>
endscript

script translate_screen_element \{time = 0}
	if NOT gotparam \{id}
		printf \{'Did not pass in id to translate_screen_element! Returning'}
		return
	endif
	if NOT gotparam \{pos}
		getscreenelementposition id = <id>
		new_position = <screenelementpos>
	else
		new_position = <pos>
	endif
	<id> :legacydomorph pos = <new_position> time = <time>
endscript

script get_my_highway_layout 
	player = 1
	begin
	formattext checksumname = player_status 'player%p_status' p = <player>
	if ($<player_status>.is_local_client)
		return my_highway = ($<player_status>.highway_layout)
	endif
	<player> = (<player> + 1)
	repeat 2
endscript

script agora_update 
	if ($coop_dlc_active = 1)
		return
	endif
	get_game_mode_name
	get_current_band_info
	getglobaltags <band_info>
	band_id = <band_unique_id>
	formattext textname = band_name '%s' s = <name>
	progression_info = {}
	if NOT gotparam \{new_band}
		get_completed_percentage \{part = guitar}
		appendstruct {
			struct = progression_info
			field = guitar_career
			params = {
				score = 0
				percent_complete = <completed_percentage>
			}
		}
		get_completed_percentage \{part = bass}
		appendstruct {
			struct = progression_info
			field = bass_career
			params = {
				score = 0
				percent_complete = <completed_percentage>
			}
		}
		get_completed_percentage \{part = drum}
		appendstruct {
			struct = progression_info
			field = drum_career
			params = {
				score = 0
				percent_complete = <completed_percentage>
			}
		}
		get_completed_percentage \{part = vocals}
		appendstruct {
			struct = progression_info
			field = vocals_career
			params = {
				score = 0
				percent_complete = <completed_percentage>
			}
		}
		get_completed_percentage \{part = band}
		appendstruct {
			struct = progression_info
			field = band_career
			params = {
				score = 0
				percent_complete = <completed_percentage>
			}
		}
	endif
	getglobaltags \{achievement_info}
	achievements = 'what achievements?'
	purchases = 'test purchases'
	writeupdate {progression_info = <progression_info> band_name = <band_name> band_id = <band_id> cash = <cash>}
endscript

script net_get_character_name \{player = 1
		check_profanity = 1}
	requireparams \{[
			player
		]
		all}
	formattext checksumname = player_status 'player%p_status' p = <player>
	if (($<player_status>.is_local_client) = 1)
		get_savegame_from_player_status player_status = <player_status>
	else
		get_savegame_from_controller controller = ($primary_controller)
	endif
	id = ($<player_status>.character_id)
	if searchmusicianprofilearray array_name = net_musician_profiles id = <id>
		id = (($net_musician_profiles [<index>]).old_character_id)
	endif
	resolve_guest_character_id id = <id>
	if band_builder_is_random character_id = <id>
		id = customcharacter
	endif
	if (<check_profanity> = 1)
		get_fullname_of_character id = <id> savegame = <savegame>
	else
		get_fullname_of_character id = <id> savegame = <savegame> profanity_allowed
	endif
	printstruct <...>
	return display_name = <fullname> character_id = <id>
endscript

script agora_write_stats 
	requireparams \{[
			song_checksum
		]
		all}
	printf \{qs(0xab65adaf)
		s = $game_mode}
	if ($boss_battle = 1)
		return
	endif
	if ($is_network_game)
		getplayerinfo \{1
			gamertag}
		p1_name = $<gamertag>
		getplayerinfo \{2
			gamertag}
		p2_name = $<gamertag>
		retrieve_player_net_id \{player = 2}
		player_id2 = <net_id>
	else
		player_id2 = ($player2_status.controller)
	endif
	venue = (($levelzones.$current_level).name)
	get_song_prefix song = <song_checksum>
	title = <song_prefix>
	get_current_band_info
	getglobaltags <band_info>
	band_id = <band_unique_id>
	gamemode_gettype
	switch (<type>)
		case quickplay
		mode = 'quickplay'
		case faceoff
		mode = 'faceoff'
		case pro_faceoff
		mode = 'pro_faceoff'
		case career
		mode = 'career'
		case battle
		mode = 'battle'
		default
		mode = 'quickplay'
	endswitch
	gamemode_getnumplayers
	if (<num_players> > 1)
		participants_info = []
		index = 1
		begin
		getplayerinfo <index> score
		getplayerinfo <index> stars
		getplayerinfo <index> notes_hit
		getplayerinfo <index> total_notes
		getplayerinfo <index> best_run
		getplayerinfo <index> sp_phrases_hit
		getplayerinfo <index> sp_phrases_total
		getplayerinfo <index> difficulty
		getplayerinfo <index> part
		getplayerinfo <index> lefty_flip
		get_difficulty_text_nl difficulty = <difficulty>
		difficulty_text = <difficulty_text_nl>
		get_part_text_nl part = <part>
		getplayerinfo <index> controller
		<net_id> = [0 0]
		getplayerinfo <index> is_local_client
		if (<is_local_client> = 1)
			if (<controller> > 3)
				<controller> = (<controller> - 4)
			endif
			getnetid controller_index = <controller>
		else
			getplayerinfo <index> net_id_first
			getplayerinfo <index> net_id_second
		endif
		setarrayelement arrayname = net_id index = 0 newvalue = <net_id_first>
		setarrayelement arrayname = net_id index = 1 newvalue = <net_id_second>
		if gamemode_iscooperative
			<winner> = 1
			score = ($band1_status.score)
		else
			if (<num_players> > 2)
				getplayerinfo \{1
					team}
				<player1_team> = <team>
				getplayerinfo <index> team
				if (<player1_team> = <team>)
					score = ($band1_status.score)
					if (($band1_status.score) > ($band2_status.score))
						<winner> = 1
					else
						<winner> = 0
					endif
				else
					score = ($band2_status.score)
					if (($band2_status.score) > ($band1_status.score))
						<winner> = 1
					else
						<winner> = 0
					endif
				endif
			else
				if (<type> = battle)
					if ($is_network_game = 1)
						getplayerinfo \{1
							save_health}
						player1_score = <save_health>
						getplayerinfo \{2
							save_health}
						player2_score = <save_health>
					else
						getplayerinfo \{1
							current_health}
						player1_score = <current_health>
						getplayerinfo \{2
							current_health}
						player2_score = <current_health>
					endif
					getplayerinfo <index> score
					if (<index> = 1)
						if (<player1_score> > <player2_score>)
							<winner> = 1
						else
							<winner> = 0
						endif
					else
						if (<player2_score> > <player1_score>)
							<winner> = 1
						else
							<winner> = 0
						endif
					endif
				else
					getplayerinfo \{1
						score}
					player1_score = <score>
					getplayerinfo \{2
						score}
					player2_score = <score>
					if (<index> = 1)
						<score> = <player1_score>
						if (<player1_score> > <player2_score>)
							<winner> = 1
						else
							<winner> = 0
						endif
					else
						<score> = <player2_score>
						if (<player2_score> > <player1_score>)
							<winner> = 1
						else
							<winner> = 0
						endif
					endif
				endif
			endif
		endif
		casttointeger \{score}
		create_agora_character_struct player = <index>
		new_participant_info = {
			player_id = <net_id>
			score = <score>
			winner = <winner>
			stars = <stars>
			notes_hit = <notes_hit>
			notes_missed = (<total_notes> - <notes_hit>)
			best_streak = <best_run>
			failed_attempts = ($agora_failed_attempts)
			sp_phrases_hit = <sp_phrases_hit>
			sp_phrases_total = <sp_phrases_total>
			difficulty = <difficulty_text>
			part = <part_text>
			lefty_flip = <lefty_flip>
			character = <agora_character>
		}
		addarrayelement array = <participants_info> element = <new_participant_info>
		<participants_info> = <array>
		<index> = (<index> + 1)
		repeat <num_players>
		if gotparam \{jam_info}
			writemultiperformance participants_info = <participants_info> title = <title> venue = <venue> mode = <mode> winner = <winner> jam_info = <jam_info>
		else
			writemultiperformance participants_info = <participants_info> title = <title> venue = <venue> mode = <mode> winner = <winner>
		endif
	else
		index = 1
		getplayerinfo <index> score
		getplayerinfo <index> stars
		getplayerinfo <index> notes_hit
		getplayerinfo <index> total_notes
		getplayerinfo <index> best_run
		getplayerinfo <index> sp_phrases_hit
		getplayerinfo <index> sp_phrases_total
		getplayerinfo <index> difficulty
		getplayerinfo <index> part
		getplayerinfo <index> lefty_flip
		get_difficulty_text_nl difficulty = <difficulty>
		difficulty_text = <difficulty_text_nl>
		get_part_text_nl part = <part>
		retrieve_player_net_id player = <index>
		casttointeger \{score}
		<net_id> = [0 0]
		getplayerinfo <index> is_local_client
		if (<is_local_client> = 1)
			getnetid controller_index = <controller>
		else
			getplayerinfo <index> net_id_first
			getplayerinfo <index> net_id_second
		endif
		setarrayelement arrayname = net_id index = 0 newvalue = <net_id_first>
		setarrayelement arrayname = net_id index = 1 newvalue = <net_id_second>
		create_agora_character_struct player = <index>
		participant_info = {
			player_id = <net_id>
			score = <score>
			winner = 1
			stars = <stars>
			notes_hit = <notes_hit>
			notes_missed = (<total_notes> - <notes_hit>)
			best_streak = <best_run>
			failed_attempts = ($agora_failed_attempts)
			sp_phrases_hit = <sp_phrases_hit>
			sp_phrases_total = <sp_phrases_total>
			difficulty = <difficulty_text>
			part = <part_text>
			lefty_flip = <lefty_flip>
			character = <agora_character>
		}
		if gotparam \{jam_info}
			writeperformance mode = <mode> title = <title> participant_info = <participant_info> band_id = <band_id> venue = <venue> jam_info = <jam_info>
		else
			writeperformance mode = <mode> title = <title> participant_info = <participant_info> band_id = <band_id> venue = <venue>
		endif
	endif
	change \{agora_failed_attempts = 0}
endscript

script writeperformance 
	if ($cheat_airguitar = 1)
		air_guitar_active = air_guitar_active
	endif
	if ($cheat_performancemode = 1)
		performance_mode = performance_mode
	endif
	printf \{qs(0x91d6b9d1)}
	printstruct <...>
	netsessionfunc obj = xmlkeyarchive func = writeagora params = {write_type = writeperformance <...>}
endscript

script writemultiperformance 
	printf \{qs(0x2aa91cf6)}
	printstruct <...>
	netsessionfunc obj = xmlkeyarchive func = writeagora params = {write_type = writemultiplayermatch <...>}
endscript

script writeupdate \{band_id = 0
		band_name = 'test name'
		cash = 100
		achievements = 'temp achievement string'}
	printf \{qs(0xfa3358a6)}
	printstruct <...>
	netsessionfunc obj = xmlkeyarchive func = writeagora params = {write_type = writeupdate <...>}
endscript

script invite_accepted 
	if scriptisrunning \{do_join_invite_stuff}
		printf 'invite_accepted - replaced old invite for controller %c' c = ($invite_controller)
		killspawnedscript \{name = do_join_invite_stuff}
	endif
	printf 'invite_accepted - controllerID %c' c = <controllerid>
	change invite_controller = <controllerid>
	if ($primary_controller_assigned = 0)
		printf \{'invite_accepted - primary controller not yet assigned!'}
		return
	else
		printf 'invite_accepted - $primary_controller %p' p = ($primary_controller)
	endif
	do_join_invite_stuff <...> accepted_invite
endscript

script send_fail_song_message \{wait_frames = 30
		quit_early = 0}
	if (ishost)
		loser = 0
	else
		loser = 1
	endif
	gamemode_getnumplayersshown
	begin
	sendnetmessage {
		type = fail_song
		note_streak = ($player1_status.best_run)
		notes_hit = ($player1_status.notes_hit)
		total_notes = ($player1_status.total_notes)
		quit_early_flag = <quit_early>
		loser = <loser>
	}
	repeat <num_players_shown>
	wait <wait_frames> gameframes
endscript

script join_invite_stuff_check_for_bad_ui_state 
	if NOT ui_event_exists_in_stack \{name = 'memcard'}
		if NOT ui_event_exists_in_stack \{name = 'boot_download_scan'}
			if NOT ui_event_exists_in_stack \{name = 'signin'}
				return \{false}
			endif
		endif
	endif
	return \{true}
endscript

script do_join_invite_stuff 
	printf \{'do_join_invite_stuff'}
	if gotparam \{accepted_invite}
		if ($signin_jam_mode = 1)
			return
		endif
		ui_event_get_top
		if (<base_name> = 'online_quit_warning')
			ui_event_block \{event = menu_back}
		endif
		if (($primary_controller_assigned = 1) && ($invite_controller = $primary_controller))
			getglobaltags \{user_options}
			if (<autosave> = 1)
				if current_band_save_created controller = ($primary_controller)
					<invited_primary_controller> = true
				else
					<invited_primary_controller> = false
				endif
			else
				<invited_primary_controller> = true
			endif
		else
			<invited_primary_controller> = false
		endif
		printf qs(0x867bec5c) i = <invited_primary_controller>
		change \{online_signin_autoload_required = 0}
		wait_for_safe_shutdown
		if ($signin_change_happening = 1)
			return
		endif
		printf \{qs(0x1c9bd5e2)}
		disable_pause
		if isps3
			netsessionfunc \{obj = party
				func = leave_party}
		endif
		quit_network_game_early
		unpausespawnedscript \{ui_event_block}
		if (<invited_primary_controller> = true)
			if ($cas_heap_state = in_cas)
				create_loading_screen_empty
			else
				killallmovies
				waitforallmoviestofinish
				set_bink_heap_state \{state = small}
				create_loading_screen \{no_bink}
			endif
		endif
		ui_event_wait_for_safe
		end_singleplayer_game
		if islocallysignedin controller = ($primary_controller)
			if checkforsignin controller_index = ($primary_controller)
				net_init
			endif
		endif
		change \{has_invite_join_result_callback_completed = 0}
		startrendering
		if (<invited_primary_controller> = true)
			destroy_popup_warning_menu
			setbuttoneventmappings \{block_menu_input}
			create_loading_screen \{wait}
			ui_event \{event = menu_replace
				data = {
					state = uistate_mainmenu
					base_name = 'mainmenu'
					selected_index = 3
					clear_previous_stack
					ignore_camera = 1
				}}
			block \{type = mainmenu_invite_finished}
			ui_event_remove_params \{param = ignore_camera}
			printf \{'do_join_invite_stuff - start waiting for frontend anims...'}
			begin
			if frontend_anim_paks_are_loaded
				printf \{'do_join_invite_stuff - frontend anims are now loaded'}
				break
			endif
			wait \{1
				gameframe}
			repeat 1200
			printf \{'do_join_invite_stuff - done waiting for anims'}
			if (netsessionfunc func = is_cable_unplugged)
				change \{invite_controller = -1}
				sysnotify_handle_connection_loss \{cable_unplugged}
				return
			endif
			if NOT checkforsignin controller_index = ($primary_controller)
				change \{invite_controller = -1}
				handle_signin_changed
				return
			endif
			destroy_loading_screen
			setbuttoneventmappings \{unblock_menu_input}
		else
			unpausegame
			unpausespawnedscript \{ui_event_block}
			begin
			<has_waited_for_invalid_ui_state> = 0
			begin
			ui_event_wait_for_safe
			if join_invite_stuff_check_for_bad_ui_state
				<has_waited_for_invalid_ui_state> = 1
			else
				break
			endif
			wait \{1
				gameframes}
			repeat
			if (<has_waited_for_invalid_ui_state> = 0)
				break
			endif
			wait \{1
				seconds}
			repeat
			destroy_popup_warning_menu
			if (netsessionfunc func = is_cable_unplugged)
				change \{invite_controller = -1}
				sysnotify_handle_connection_loss \{cable_unplugged}
				return
			endif
			if checkforsignin controller_index = ($invite_controller)
				ui_event_block event = menu_replace data = {state = uistate_signin device_num = ($invite_controller) clear_previous_stack}
			else
				change \{invite_controller = -1}
				handle_signin_changed
			endif
			return
		endif
		if NOT netsessionfunc func = iscontrolleringame params = {controller = ($invite_controller)}
			netsessionfunc func = addcontrollers params = {controller = ($invite_controller)}
		endif
		change \{invite_controller = -1}
		printstruct <...>
		xenon_singleplayer_session_begin_uninit
		unpausegame
		getactivecontrollers
		<controller_idx> = 0
		begin
		if netsessionfunc func = iscontrolleringame params = {controller = <controller_idx>}
			if NOT checkforsignin controller_index = <controller_idx>
				printf 'do_join_invite_stuff - removed controller %c, not signed in' c = <controller_idx>
				netsessionfunc func = removecontroller params = {controller = <controller_idx>}
			endif
			if (<active_controllers> [<controller_idx>] = 0)
				netsessionfunc func = removecontroller params = {controller = <controller_idx>}
			endif
		endif
		<controller_idx> = (<controller_idx> + 1)
		repeat 4
		joininviteserver
	else
		printf \{'do_join_invite_stuff - not accepted'}
		ui_event_block \{event = menu_replace
			data = {
				state = uistate_mainmenu
				base_name = 'mainmenu'
				selected_index = 3
				clear_previous_stack
			}}
	endif
endscript

script ui_print_gamertags \{pos1 = (235.0, 100.0)
		pos2 = (1045.0, 100.0)
		just1 = [
			left
			top
		]
		just2 = [
			right
			top
		]
		offscreen = 0}
endscript

script ui_print_gamertag start_pos = (235.0, 100.0) color = ($player1_color) player = 1 dims = (450.0, 35.0) z = 60 offscreen = 0
	return
	if NOT gotparam \{name}
		net_get_character_name player = <player>
		name = <display_name>
	endif
	if NOT screenelementexists \{id = gamertag_container}
		if (<offscreen> = 1)
			createscreenelement {
				type = containerelement
				id = gamertag_container
				parent = root_window
				pos = (0.0, -400.0)
				just = [center center]
				z_priority = <z>
			}
		else
			createscreenelement {
				type = containerelement
				id = gamertag_container
				parent = root_window
				pos = (0.0, 0.0)
				just = [center center]
				z_priority = <z>
			}
		endif
	endif
	formattext checksumname = gamertag_text_px 'gamertag_text_p%d' d = <player>
	formattext checksumname = debug_gamertag_container_px 'debug_gamertag_container_p%d' d = <player>
	formattext checksumname = gt_frame_top 'gt_frame_top_p%d' d = <player>
	formattext checksumname = gt_frame_top_fill 'gt_frame_top_fill_p%d' d = <player>
	formattext checksumname = gt_frame_bottom 'gt_frame_bottom_p%d' d = <player>
	formattext checksumname = gt_frame_bottom_fill 'gt_frame_bottom_fill_p%d' d = <player>
	if (screenelementexists id = <gamertag_text_px>)
		if screenelementexists \{id = gamertag_icon_container}
			setscreenelementprops \{id = gamertag_icon_container
				alpha = 1}
		endif
		return
	endif
	createscreenelement {
		type = textelement
		parent = gamertag_container
		font = fontgrid_title_a1
		rgba = <color>
		text = <name>
		id = <gamertag_text_px>
		pos = (<start_pos> + (0.0, 3.0))
		just = <just>
		scale = 0.75
		z_priority = (<z> + 1)
	}
	getscreenelementdims id = <gamertag_text_px>
	x_dim = ((<dims>.(1.0, 0.0)) * 0.5625)
	y_dim = (<dims>.(0.0, 1.0) * 0.75)
	x_scale = 1.0
	y_scale = 1.0
	if (<width> > <x_dim>)
		<x_scale> = (<x_dim> / <width>)
	endif
	if (<height> > <y_dim>)
		<y_scale> = (<y_dim> / <height>)
	endif
	scale_pair = ((1.0, 0.0) * <x_scale> + (0.0, 1.0) * <y_scale>)
	setscreenelementprops {id = <gamertag_text_px> scale = <scale_pair>}
	getscreenelementdims id = <gamertag_text_px>
	text_w = (<width> + 80)
	text_h = (<dims>.(0.0, 1.0) + 10)
	getscreenelementdims id = <gt_frame_top>
	frame_w = (<width> / 1.0)
	frame_h = (<height> / 1.0)
	frame_scale_x = (<text_w> / <frame_w>)
	frame_scale_y = (<text_h> / <frame_h>)
	frame_scale = ((<frame_scale_x> * (1.0, 0.0)) + (<frame_scale_y> * (0.0, 0.5625)))
	setscreenelementprops {id = <gt_frame_top> scale = <frame_scale>}
	setscreenelementprops {id = <gt_frame_top_fill> scale = <frame_scale>}
	x_adjust = (0.0, 0.0)
	y_adjust = (0.0, 0.0)
	y_adjust = ((0.0, 1.0) * ((-5 * <y_scale>) -5))
	if ((<just> [0]) = right)
		x_adjust = ((1.0, 0.0) * 40)
	elseif ((<just> [0]) = left)
		x_adjust = ((1.0, 0.0) * -40)
	endif
	new_pos = (<start_pos> + (<x_adjust> + <y_adjust>))
	setscreenelementprops {id = <gt_frame_top> pos = <new_pos>}
	setscreenelementprops {id = <gt_frame_top_fill> pos = <new_pos>}
	getscreenelementprops id = <gt_frame_top>
	getscreenelementdims id = <gt_frame_top>
	getplatform
	if (<player> = 2 && <platform> = xenon)
		getscreenelementdims id = <id>
		tag_width = 0
		if ((<just> [0]) = -1)
			<tag_width> = <width>
		elseif ((<just> [0]) = 0)
			<tag_width> = (<width> * 0.5)
		endif
		createscreenelement {
			type = containerelement
			parent = gamertag_container
			id = gamertag_icon_container
			pos = (<pos> + (<height> * (0.0, 1.0)) + (<tag_width> * (1.0, 0.0)) + (-40.0, 23.0))
		}
		displaytext {
			parent = gamertag_icon_container
			text = qs(0x9a7d1fe5)
			just = [right top]
			rgba = [0 0 0 255]
			noshadow
			pos = (0.0, 5.0)
			scale = 0.5
			font = ($user_control_text_font)
			z = (<z> + 200)
		}
		getscreenelementdims id = <id>
		text_end = (<width> * (1.0, 0.0) + (20.0, 0.0))
		text_begin = ((-30.0, 0.0) - (<width> * (1.0, 0.0)))
		displaytext {
			parent = gamertag_icon_container
			text = qs(0x57ea8b0f)
			pos = (<text_begin> + (20.0, -1.0))
			just = [right top]
			font = ($gh3_button_font)
			scale = 0.5
			z = (<z> + 200)
		}
		displaysprite {
			parent = gamertag_icon_container
			tex = helper_pill_end
			pos = (10.0, 15.0)
			just = [right center]
			dims = (16.0, 32.0)
			rgba = [180 180 180 255]
			z = (<z> + 100)
		}
		displaysprite {
			parent = gamertag_icon_container
			tex = helper_pill_body
			pos = (0.0, 15.0)
			just = [right center]
			dims = ((32.0, 32.0) + <width> * (1.0, 0.0))
			rgba = [180 180 180 255]
			z = (<z> + 100)
		}
		displaysprite {
			parent = gamertag_icon_container
			tex = helper_pill_end
			pos = ((0.0, -2.0) - <width> * (1.0, 0.0) - (32.0, 0.0))
			just = [right top]
			dims = (16.0, 32.0)
			rgba = [180 180 180 255]
			z = (<z> + 100)
			flip_v
		}
	endif
endscript

script destroy_gamertags 
	if screenelementexists \{id = gamertag_container}
		destroyscreenelement \{id = gamertag_container}
	endif
	if screenelementexists \{id = gamertag_container_p1}
		destroyscreenelement \{id = gamertag_container_p1}
	endif
	if screenelementexists \{id = gamertag_container_p2}
		destroyscreenelement \{id = gamertag_container_p2}
	endif
	if screenelementexists \{id = debug_gamertag_container_p1}
		destroyscreenelement \{id = debug_gamertag_container_p1}
	endif
	if screenelementexists \{id = debug_gamertag_container_p2}
		destroyscreenelement \{id = debug_gamertag_container_p2}
	endif
endscript

script destroy_gamertag_container \{player = 1}
	formattext checksumname = gamertag_container 'gamertag_container_p%d' d = <player>
	if screenelementexists id = <gamertag_container>
		destroyscreenelement id = <gamertag_container>
	endif
endscript

script morph_gamertags 
	if screenelementexists \{id = gamertag_container}
		move_gamertag_pos = ((1.0 - <delta>) * (($g_hud_2d_struct_used).offscreen_gamertag_pos) + (<delta> * ((($g_hud_2d_struct_used).final_gamertag_pos) + <off_set>)))
		legacydoscreenelementmorph id = gamertag_container pos = <move_gamertag_pos> time = <time_to_move>
		if screenelementexists \{id = gamertag_icon_container}
			setscreenelementprops \{id = gamertag_icon_container
				alpha = 0}
		endif
	endif
endscript

script test_write_leaderboards 
	printf \{qs(0xdf4178e8)}
	begin_singleplayer_game
	wait \{0.3
		seconds
		ignoreslomo}
	if NOT should_update_stats_leader_board
		return
	endif
	netsessionfunc obj = stats func = write_stats params = {leaderboard_id = anarchy_in_the_uk score = 10000 rating = <rating_val>}
endscript

script test_read_leaderboards 
	netsessionfunc \{obj = stats
		func = get_stats
		params = {
			leaderboard_id = m_test_gh3
			callback = test_callback
			num_rows = 10
			listtype = rating
			rating_val = 5
			columns = 0
		}}
endscript

script menu_show_gamercard 
	if NOT (($is_network_game) && (isxenon))
		return
	endif
	retrieve_player_net_id \{player = 2}
	netsessionfunc func = showgamercard params = {player_xuid = <net_id>}
endscript

script menu_show_gamercard_from_netid 
	requireparams \{[
			device_num
		]
		all}
	if checkforsignin controller_index = <device_num>
		if NOT ($is_network_game = 1)
			return
		endif
		if gotparam \{net_id}
			netsessionfunc func = showgamercard params = {player_xuid = <net_id> controller_index = <device_num>}
		endif
	endif
endscript

script win_now 
	extendcrc \{song_won
		'p1'
		out = type}
	broadcastevent type = <type> data = {song_complete = 1}
endscript
new_message_of_the_day = 0

script splash_callback 
	printf \{qs(0x7cd3e629)}
	printstruct <...>
	if gotparam \{motd_text}
		change \{new_message_of_the_day = 1}
	else
		change \{new_message_of_the_day = 0}
	endif
endscript

script test_send 
	test1 = 'does this get sent?'
	test2 = doesthisgetsent
	test3 = doesthisgetsent2
	printstruct <...>
	sendstructure callback = test_callback data_to_send = <...>
endscript

script test_callback 
	printf \{qs(0xebc04aee)}
	printstruct <...>
endscript

script cleanup_online_lobby_select 
	destroy_pause_menu_frame \{container_id = net_quit_warning}
	if screenelementexists \{id = ready_container_p1}
		destroyscreenelement \{id = ready_container_p1}
	endif
	if screenelementexists \{id = ready_container_p2}
		destroyscreenelement \{id = ready_container_p2}
	endif
	destroy_pause_menu_frame
	if screenelementexists \{id = warning_message_container}
		destroyscreenelement \{id = warning_message_container}
	endif
	if screenelementexists \{id = leaving_lobby_dialog_menu}
		destroyscreenelement \{id = leaving_lobby_dialog_menu}
	endif
	destroy_gamertags
	shut_down_flow_manager \{player = 2}
	clean_up_user_control_helpers
	destroy_menu \{menu_id = scrolling_character_hub_p1}
	destroy_menu \{menu_id = character_hub_p1_container}
	destroy_menu \{menu_id = scrolling_character_hub_p2}
	destroy_menu \{menu_id = character_hub_p2_container}
	killcamanim \{name = gs_view_cam}
	<player> = 1
	begin
	formattext checksumname = scrolling_select_outfit 'scrolling_select_outfit_p%i' i = <player>
	formattext checksumname = s_container 's_container_p%i' i = <player>
	destroy_menu menu_id = <scrolling_select_outfit>
	destroy_menu menu_id = <s_container>
	<player> = (<player> + 1)
	repeat 2
	<player> = 1
	begin
	formattext checksumname = scrolling_select_style 'scrolling_select_style_p%i' i = <player>
	formattext checksumname = s_container 's_container_p%i' i = <player>
	destroy_menu menu_id = <scrolling_select_style>
	destroy_menu menu_id = <s_container>
	<player> = (<player> + 1)
	repeat 2
	destroy_menu \{menu_id = scrolling_select_guitar_p1}
	destroy_menu \{menu_id = scrolling_guitar_finish_menu_p1}
	destroy_menu \{menu_id = gs_instrument_info_scroll_window}
	destroy_menu \{menu_id = select_guitar_container}
	destroy_menu \{menu_id = select_finish_container}
	destroy_menu \{menu_id = scrolling_select_guitar_p2}
	destroy_menu \{menu_id = scrolling_guitar_finish_menu_p2}
	destroy_menu \{menu_id = select_guitar_container_p2}
	destroy_menu \{menu_id = select_finish_container_p2}
	<player> = 1
	begin
	formattext checksumname = player_status 'player%i_status' i = <player>
	<band_member> = ($<player_status>.band_member)
	if compositeobjectexists name = <band_member>
		if <band_member> :anim_animnodeexists id = bodytimer
			<band_member> :anim_command target = bodytimer command = timer_setspeed params = {speed = 1.0}
		endif
	endif
	<player> = (<player> + 1)
	repeat 2
	<player> = 1
	begin
	formattext checksumname = scrolling_select_finish 'scrolling_select_finish_p%i' i = <player>
	destroy_menu menu_id = <scrolling_select_finish>
	<player> = (<player> + 1)
	repeat 2
	ui_flow_manager_respond_to_action \{action = continue}
endscript

script removeobserverbg 
endscript

script net_disable_pause 
	if ($net_pause = 1)
		net_unpausegh
	endif
	disable_pause
endscript

script net_fail_coop_song 
	printf \{qs(0x4a48ff2b)}
	net_disable_pause
	change \{disable_attacks = 1}
	change \{recovered_dropped_players = 0}
	change \{net_num_players_data_ack = 0}
	if (ishost)
		i = 1
		gamemode_getnumplayersshown
		begin
		formattext checksumname = player_status 'player%d_status' d = <i>
		if (($<player_status>.is_local_client) = 1)
			change net_num_players_data_ack = ($net_num_players_data_ack + 1)
		endif
		i = (<i> + 1)
		repeat <num_players_shown>
		getnumplayers
		change net_num_players_data_needed = <num_players>
		sendstructure callback = set_client_band_score data_to_send = {band_score = ($band1_status.score)}
	else
		player_data = {}
		i = 1
		gamemode_getnumplayersshown
		begin
		formattext checksumname = player_status 'player%d_status' d = <i>
		if (($<player_status>.is_local_client) = 1)
			appendstruct {
				struct = player_data
				field = <player_status>
				params = {
					obj_id = ($<player_status>.net_obj_id)
					score = ($<player_status>.score)
					best_run = ($<player_status>.best_run)
					max_notes = ($<player_status>.max_notes)
					notes_hit = ($<player_status>.notes_hit)
					stars = ($<player_status>.stars)
					vocal_streak_phrases = ($<player_status>.vocal_streak_phrases)
					vocal_phrase_quality = ($<player_status>.vocal_phrase_quality)
					vocal_phrase_max_qual = ($<player_status>.vocal_phrase_max_qual)
					total_notes = ($<player_status>.total_notes)
					new_cash = ($<player_status>.new_cash)
					career_earnings = ($<player_status>.career_earnings)
					cash_rank_up = ($<player_status>.cash_rank_up)
				}
			}
		endif
		i = (<i> + 1)
		repeat <num_players_shown>
		sendstructure callback = player_data_request_ack data_to_send = {player_data = <player_data>} to_server
	endif
	killspawnedscript \{name = guitarevent_songwon_spawned}
	spawnscriptnow \{guitarevent_songfailed_spawned}
endscript

script set_client_band_score 
	if gotparam \{band_score}
		printf qs(0x287bc806) s = <band_score>
		change structurename = band1_status score = <band_score>
	endif
endscript

script net_battle_win_song 
	printf \{qs(0xea72635e)}
	net_disable_pause
	change \{disable_attacks = 1}
	if (<losing_player> = 1)
		change \{structurename = player1_status
			current_health = 0.0}
		change \{structurename = player2_status
			current_health = 1.0}
	else
		change \{structurename = player1_status
			current_health = 1.0}
		change \{structurename = player2_status
			current_health = 0.0}
	endif
	if NOT ($is_attract_mode = 1)
		achievements_update
	endif
	guitarevent_songwon \{battle_win = 1}
endscript

script add_searching_menu_item \{z = 2.1}
	if gotparam \{vmenu_id}
		createscreenelement {
			type = containerelement
			parent = <vmenu_id>
			dims = (210.0, 35.0)
			pos = (0.0, 0.0)
			just = [center top]
			internal_just = [center top]
		}
		<container_element> = <id>
		<id> :se_setprops {
			event_handlers = [
				{focus searching_menu_focus params = {parent = <id>}}
				{unfocus searching_menu_unfocus params = {parent = <id>}}
				{pad_choose <choose_script>}
			]
		}
		createscreenelement {
			type = textelement
			parent = <container_element>
			local_id = text_string
			font = fontgrid_title_a1
			scale = 0.65000004
			rgba = ($online_light_blue)
			text = <text>
			just = [center top]
			pos = (105.0, 0.0)
			z_priority = <z>
		}
		createscreenelement {
			type = spriteelement
			parent = <container_element>
			local_id = highlight_bar
			texture = white
			dims = (250.0, 35.0)
			rgba = ($online_light_blue)
			pos = (105.0, -3.0)
			just = [center top]
			z_priority = <z>
			alpha = 0.0
		}
		createscreenelement {
			type = spriteelement
			parent = <container_element>
			local_id = left_bookend
			texture = character_hub_hilite_bookend
			dims = (35.0, 35.0)
			rgba = ($online_light_blue)
			pos = (-20.0, -3.0)
			just = [center top]
			z_priority = <z>
			alpha = 0.0
		}
		createscreenelement {
			type = spriteelement
			parent = <container_element>
			local_id = right_bookend
			texture = character_hub_hilite_bookend
			dims = (35.0, 35.0)
			rgba = ($online_light_blue)
			pos = (240.0, -3.0)
			just = [center top]
			z_priority = <z>
			alpha = 0.0
		}
	endif
endscript

script searching_menu_focus 
	obj_getid
	if screenelementexists id = {<objid> child = text_string}
		legacydoscreenelementmorph id = {<objid> child = text_string} rgba = ($online_dark_purple)
	endif
	if screenelementexists id = {<objid> child = highlight_bar}
		legacydoscreenelementmorph id = {<objid> child = highlight_bar} alpha = 1.0
	endif
	if screenelementexists id = {<objid> child = left_bookend}
		legacydoscreenelementmorph id = {<objid> child = left_bookend} alpha = 1.0
	endif
	if screenelementexists id = {<objid> child = right_bookend}
		legacydoscreenelementmorph id = {<objid> child = right_bookend} alpha = 1.0
	endif
endscript

script searching_menu_unfocus 
	obj_getid
	if screenelementexists id = {<objid> child = text_string}
		legacydoscreenelementmorph id = {<objid> child = text_string} rgba = ($online_light_blue)
	endif
	if screenelementexists id = {<objid> child = highlight_bar}
		legacydoscreenelementmorph id = {<objid> child = highlight_bar} alpha = 0.0
	endif
	if screenelementexists id = {<objid> child = left_bookend}
		legacydoscreenelementmorph id = {<objid> child = left_bookend} alpha = 0.0
	endif
	if screenelementexists id = {<objid> child = right_bookend}
		legacydoscreenelementmorph id = {<objid> child = right_bookend} alpha = 0.0
	endif
endscript

script set_other_player_present 
	printf \{qs(0xa77d698c)}
	if NOT ($player2_present)
		change \{player2_present = 1}
		spawnscriptnow \{net_hub_stream}
	endif
	if screenelementexists \{id = character_hub_p1_continue}
		character_hub_p1_continue :se_setprops \{rgba = [
				180
				100
				60
				255
			]
			unblock_events}
	endif
endscript

script test_multi_leaderboards 
	player_list = [
		{
			leaderboards = [
				{
					write_type = max
					leaderboard_id = anarchyintheuk
					rating = 4
					score = 100
					columns = [
						{
							score = 100
						}
						{
							score = 200
						}
						{
							score = 300
						}
					]
				}
				{
					write_type = max
					leaderboard_id = avalancha
					rating = 3
					score = 100
					columns = [
						{
							score = 100
						}
						{
							score = 200
						}
						{
							score = 300
						}
					]
				}
			]
		}
	]
	netsessionfunc obj = stats func = stats_write_multiplayer params = {dontendsessionafterwrite <...>}
endscript

script retrieve_player_net_id 
	net_id = [0 0]
	if gotparam \{player}
		formattext checksumname = player_status 'player%i_status' i = <player>
		setarrayelement arrayname = net_id index = 0 newvalue = ($<player_status>.net_id_first)
		setarrayelement arrayname = net_id index = 1 newvalue = ($<player_status>.net_id_second)
	else
		setarrayelement arrayname = net_id index = 0 newvalue = ($player1_status.net_id_first)
		setarrayelement arrayname = net_id index = 1 newvalue = ($player1_status.net_id_second)
	endif
	printf \{qs(0xa9796959)}
	return net_id = <net_id>
endscript

script host_handle_dropped_client 
	printf \{qs(0x4409230f)}
endscript

script drop_client_from_character_select 
	destroy_gamertags
	if (netsessionfunc obj = match func = get_gamertag)
		ui_print_gamertag name = <name> start_pos = (235.0, 50.0) color = ($player1_color) player = 1 just = [left top] dims = (450.0, 35.0)
	endif
	killspawnedscript \{name = cs_rotate_hilites_p2}
	change \{g_cs_scroll_ready_p2 = 1}
	change \{g_cs_choose_ready_p2 = 0}
	destroy_menu \{menu_id = char_select_character_container_p2}
	destroy_menu \{menu_id = char_select_container_p2}
	destroy_menu \{menu_id = char_select_hilite_container_p2}
	destroy_menu \{menu_id = scrolling_character_select_p2}
	change \{player2_present = 0}
	destroy_menu \{menu_id = ready_container_p2}
	if compositeobjectexists \{name = bassist}
		bassist :hide
	endif
endscript

script host_wait_for_client 
	if NOT (ishost)
		return
	endif
	create_net_popup \{popup_text = qs(0xff7ee260)
		add_waiting_dots
		pos = (640.0, 275.0)}
	begin
	if ($player2_present = 1)
		break
	endif
	wait \{30
		gameframes}
	repeat
	destroy_net_popup
	cs_event_handlers = [
		{pad_up cs_scroll_up_or_down params = {player = 1 dir = up}}
		{pad_down cs_scroll_up_or_down params = {player = 1 dir = down}}
		{pad_back net_cs_go_back params = {player = 1}}
		{pad_choose character_select_choose params = {player = 1}}
		{pad_start menu_show_gamercard}
	]
	setscreenelementprops id = vmenu_character_select_p1 event_handlers = <cs_event_handlers> replace_handlers
endscript

script net_battle_select_icon 
	begin
	if screenelementexists id = <icon_id>
		<icon_id> :se_setprops texture = <icon_texture>
		return
	endif
	wait \{1
		gameframe}
	repeat 600
	printf qs(0x1da116d9) i = <icon_id>
endscript

script net_hub_stream 
	player_status = player1_status
	begin
	char_data = {
		char_id = ($player1_status.character_id)
	}
	sendstructure callback = update_net_character data_to_send = {char_data = <char_data>}
	wait \{1
		second}
	repeat
endscript

script update_net_character 
	player_status = player2_status
	change_made = 0
	char_id = (<char_data>.char_id)
	if NOT ($<player_status>.character_id = <char_id>)
		change structurename = <player_status> character_id = <char_id>
		<change_made> = 1
	endif
endscript

script character_hub_net_ready 
	if NOT (screenelementexists id = ready_container_p2)
		create_ready_icons \{pos2 = (825.0, 450.0)
			parent2 = root_window}
	endif
	if ($p2_ready = 0)
		change \{p2_ready = 1}
		if screenelementexists \{id = ready_container_p2}
			ready_container_p2 :obj_spawnscriptlater \{drop_in_ready_sign
				params = {
					player = 2
				}}
		endif
	endif
	if (($p1_ready = 1) && ($p2_ready = 1))
		if screenelementexists \{id = vmenu_character_hub_p1}
			launchevent \{type = unfocus
				target = vmenu_character_hub_p1}
		endif
		wait \{0.4
			seconds}
		clean_up_user_control_helpers
		shut_down_flow_manager \{player = 2}
		destroy_ready_icons
		change \{p1_ready = 0}
		change \{p2_ready = 0}
		killspawnedscript \{name = net_hub_stream}
		ui_flow_manager_respond_to_action \{action = select_ready
			player = 1
			create_params = {
				player = 1
			}}
	endif
endscript

script character_hub_net_ready_back 
	change \{p2_ready = 0}
	if NOT (screenelementexists id = ready_container_p2)
		create_ready_icons \{pos2 = (825.0, 450.0)
			parent2 = root_window}
	endif
	drop_out_ready_sign \{player = 2}
endscript

script debug_print_coop_stats \{identifier = qs(0x00000000)}
	printf qs(0x4ef48891) s = <identifier>
	p1_score = ($player1_status.score)
	p2_score = ($player2_status.score)
	p1_stars = ($player1_status.stars)
	p2_stars = ($player2_status.stars)
	p1_health = ($player1_status.current_health)
	p2_health = ($player2_status.current_health)
	p1_note_streak = ($player1_status.best_run)
	p2_note_streak = ($player2_status.best_run)
	p1_total_notes = ($player1_status.total_notes)
	p2_total_notes = ($player2_status.total_notes)
	<p1_percent_complete> = (100 * $player1_status.notes_hit / $player1_status.total_notes)
	<p2_percent_complete> = (100 * $player2_status.notes_hit / $player2_status.total_notes)
	printstruct <...>
endscript

script get_musician_instrument_type 
	get_musician_instrument_size
	index = 0
	begin
	get_musician_instrument_struct index = <index>
	if (<desc_id> = <info_struct>.desc_id)
		return instrument_type = (<info_struct>.type)
	endif
	index = (<index> + 1)
	repeat <array_size>
endscript

script scale_element_width_to_size \{max_text_width = 400}
	if NOT gotparam \{id}
		return
	endif
	getscreenelementdims id = <id>
	if (<width> > <max_text_width>)
		setscreenelementprops {
			id = <id>
			scale = ((1.0, 0.0) + (0.0, 1.0) * (<text_scale>.(0.0, 1.0)))
		}
		scale_element_to_size {
			id = <id>
			target_width = <max_text_width>
		}
	endif
endscript

script net_dl_content_compatabilty_warning_fade_out 
	wait \{10
		seconds}
	if screenelementexists id = <id>
		<id> :legacydomorph alpha = 0.0 time = 1.0
	endif
	wait \{1
		frame}
	if screenelementexists \{id = dl_content_warning}
		destroyscreenelement \{id = dl_content_warning}
	endif
endscript

script net_dl_content_compatabilty_warning \{z = 100
		pos = (0.0, 0.0)}
	if NOT gotparam \{parent}
		return
	endif
	if screenelementexists \{id = dl_content_warning}
		destroyscreenelement \{id = dl_content_warning}
	endif
	createscreenelement {
		type = containerelement
		id = dl_content_warning
		parent = <parent>
		pos = <pos>
	}
	menu_anchor = <id>
	if isxenon
	else
	endif
	createscreenelement {
		type = textblockelement
		parent = <menu_anchor>
		font = fontgrid_text_a8
		scale = (0.7, 0.55)
		rgba = ($online_light_blue)
		text = <text>
		just = [center top]
		z_priority = (<z> + 0.1)
		pos = (320.0, -55.0)
		dims = (830.0, 185.0)
		allow_expansion
	}
	<menu_anchor> :obj_spawnscriptlater net_dl_content_compatabilty_warning_fade_out params = {id = <menu_anchor>}
endscript

script fit_text_into_menu_item 
	if screenelementexists id = <id>
		getscreenelementdims id = <id>
		if (<width> > <max_width>)
			setscreenelementprops {
				id = <id>
				scale = 1.0
			}
			scale_element_to_size {
				id = <id>
				target_width = <max_width>
				target_height = <height>
			}
		endif
	endif
endscript

script net_coop_init_star_power 
	printf \{qs(0x188cbe2c)}
	if NOT (($player1_status.star_power_used = 1) || ($player2_status.star_power_used = 1))
		spawnscriptnow \{star_power_activate_and_drain
			params = {
				player_status = player1_status
				player = 1
				player_text = 'p1'
			}}
		spawnscriptnow \{star_power_activate_and_drain
			params = {
				player_status = player2_status
				player = 2
				player_text = 'p2'
			}}
	endif
endscript
demonware_is_ready = 1

script set_ready_for_input 
	change \{demonware_is_ready = 1}
endscript

script set_demonware_failed 
	change \{demonware_is_ready = 1}
endscript

script set_disable_demonware_input 
	change \{demonware_is_ready = 0}
endscript

script online_end_song 
	printf \{qs(0xdf6f59ee)}
	if ((gameisover) || (sessionisover))
		printf \{qs(0x27fd2f0c)}
		return
	endif
	change \{net_num_players_data_ack = 0}
	change \{recovered_dropped_players = 0}
	if (ishost)
		i = 1
		gamemode_getnumplayersshown
		begin
		formattext checksumname = player_status 'player%d_status' d = <i>
		if (($<player_status>.is_local_client) = 1)
			change net_num_players_data_ack = ($net_num_players_data_ack + 1)
		endif
		i = (<i> + 1)
		repeat <num_players_shown>
		getnumplayers
		change net_num_players_data_needed = <num_players>
		sendendsong
		client_handle_end_song
	endif
	printf qs(0x8110ad7a) d = ($net_num_players_data_ack)
endscript

script client_handle_end_song 
	printf \{qs(0xb4527a20)}
	extendcrc \{song_won
		'p1'
		out = type}
	broadcastevent type = <type> data = {song_complete = 1}
	change \{achievements_songwonflag = 1}
	if ($battle_do_or_die = 0)
		gamemode_gettype
		if (<type> = career || <type> = quickplay)
			progression_cashmilestonessongwon
		endif
	endif
	change \{recovered_dropped_players = 0}
	if NOT ishost
		player_data = {}
		i = 1
		gamemode_getnumplayersshown
		begin
		formattext checksumname = player_status 'player%d_status' d = <i>
		if (($<player_status>.is_local_client) = 1)
			appendstruct {
				struct = player_data
				field = <player_status>
				params = {
					obj_id = ($<player_status>.net_obj_id)
					score = ($<player_status>.score)
					best_run = ($<player_status>.best_run)
					max_notes = ($<player_status>.max_notes)
					notes_hit = ($<player_status>.notes_hit)
					stars = ($<player_status>.stars)
					vocal_streak_phrases = ($<player_status>.vocal_streak_phrases)
					vocal_phrase_quality = ($<player_status>.vocal_phrase_quality)
					vocal_phrase_max_qual = ($<player_status>.vocal_phrase_max_qual)
					total_notes = ($<player_status>.total_notes)
					new_cash = ($<player_status>.new_cash)
					career_earnings = ($<player_status>.career_earnings)
					cash_rank_up = ($<player_status>.cash_rank_up)
				}
			}
		endif
		i = (<i> + 1)
		repeat <num_players_shown>
		printf qs(0xc308da3b) d = ($<player_status>.player)
		sendstructure callback = player_data_request_ack data_to_send = {player_data = <player_data>} to_server
	endif
endscript

script player_data_request_ack 
	printf \{qs(0xb13dabc7)}
	getplayerinfo \{1
		team}
	host_team = <team>
	if gotparam \{player_data}
		num_local_players = 4
		i = 1
		begin
		formattext checksumname = player_status 'player%d_status' d = <i>
		if structurecontains structure = <player_data> <player_status>
			num_net_players = 8
			j = 1
			begin
			getplayerinfo <j> net_obj_id
			if (<net_obj_id> = <player_data>.<player_status>.obj_id)
				change net_num_players_data_ack = ($net_num_players_data_ack + 1)
				printf qs(0x83a3ff30) d = <j> a = ($net_num_players_data_ack)
				setplayerinfo <j> score = (<player_data>.<player_status>.score)
				setplayerinfo <j> best_run = (<player_data>.<player_status>.best_run)
				setplayerinfo <j> max_notes = (<player_data>.<player_status>.max_notes)
				setplayerinfo <j> notes_hit = (<player_data>.<player_status>.notes_hit)
				setplayerinfo <j> stars = (<player_data>.<player_status>.stars)
				setplayerinfo <j> vocal_streak_phrases = (<player_data>.<player_status>.vocal_streak_phrases)
				setplayerinfo <j> vocal_phrase_quality = (<player_data>.<player_status>.vocal_phrase_quality)
				setplayerinfo <j> vocal_phrase_max_qual = (<player_data>.<player_status>.vocal_phrase_max_qual)
				setplayerinfo <j> total_notes = (<player_data>.<player_status>.total_notes)
				setplayerinfo <j> new_cash = (<player_data>.<player_status>.new_cash)
				setplayerinfo <j> cash_rank_up = (<player_data>.<player_status>.cash_rank_up)
				setplayerinfo <j> career_earnings = (<player_data>.<player_status>.career_earnings)
				break
			endif
			j = (<j> + 1)
			repeat <num_net_players>
		endif
		i = (<i> + 1)
		repeat <num_local_players>
	endif
	printf qs(0x70a2ef09) a = ($net_num_players_data_needed) b = ($net_num_players_data_ack)
	if (($net_num_players_data_needed) = ($net_num_players_data_ack))
		change \{net_num_players_data_ack = 0}
		player_data = {}
		i = 1
		begin
		formattext checksumname = player_status 'player%d_status' d = <i>
		getplayerinfo <i> team
		if (<team> = 1)
			<band_score> = ($band2_status.score)
		else
			<band_score> = ($band1_status.score)
		endif
		appendstruct {
			struct = player_data
			field = <player_status>
			params = {
				obj_id = ($<player_status>.net_obj_id)
				score = ($<player_status>.score)
				best_run = ($<player_status>.best_run)
				max_notes = ($<player_status>.max_notes)
				notes_hit = ($<player_status>.notes_hit)
				stars = ($<player_status>.stars)
				vocal_streak_phrases = ($<player_status>.vocal_streak_phrases)
				vocal_phrase_quality = ($<player_status>.vocal_phrase_quality)
				vocal_phrase_max_qual = ($<player_status>.vocal_phrase_max_qual)
				total_notes = ($<player_status>.total_notes)
				new_cash = ($<player_status>.new_cash)
				career_earnings = ($<player_status>.career_earnings)
				cash_rank_up = ($<player_status>.cash_rank_up)
			}
		}
		i = (<i> + 1)
		repeat ($net_num_players_data_needed)
		if NOT ($is_attract_mode = 1)
			gamemode_gettype
			if (<type> = career)
				if progression_check_for_gig_end
					change \{achievements_newgigwonflag = 1}
				endif
			endif
			achievements_update
			change \{achievements_songwonflag = 0}
			change \{achievements_newgigwonflag = 0}
		endif
		sendstructure callback = finish_player_data_sync data_to_send = {player_data = <player_data>}
	endif
endscript

script finish_player_data_sync 
	printf \{qs(0x2f12977f)}
	if gotparam \{player_data}
		num_net_players = 8
		i = 1
		begin
		formattext checksumname = player_status 'player%d_status' d = <i>
		if structurecontains structure = <player_data> <player_status>
			num_players = 8
			j = 1
			begin
			getplayerinfo <j> net_obj_id
			if (<net_obj_id> = <player_data>.<player_status>.obj_id)
				printf qs(0xe5e680fe) d = <j> a = ($net_num_players_data_ack)
				setplayerinfo <j> score = (<player_data>.<player_status>.score)
				setplayerinfo <j> best_run = (<player_data>.<player_status>.best_run)
				setplayerinfo <j> max_notes = (<player_data>.<player_status>.max_notes)
				setplayerinfo <j> notes_hit = (<player_data>.<player_status>.notes_hit)
				setplayerinfo <j> stars = (<player_data>.<player_status>.stars)
				setplayerinfo <j> vocal_streak_phrases = (<player_data>.<player_status>.vocal_streak_phrases)
				setplayerinfo <j> vocal_phrase_quality = (<player_data>.<player_status>.vocal_phrase_quality)
				setplayerinfo <j> vocal_phrase_max_qual = (<player_data>.<player_status>.vocal_phrase_max_qual)
				setplayerinfo <j> total_notes = (<player_data>.<player_status>.total_notes)
				setplayerinfo <j> new_cash = (<player_data>.<player_status>.new_cash)
				setplayerinfo <j> career_earnings = (<player_data>.<player_status>.career_earnings)
				setplayerinfo <j> cash_rank_up = (<player_data>.<player_status>.cash_rank_up)
				break
			endif
			j = (<j> + 1)
			repeat <num_players>
		endif
		i = (<i> + 1)
		repeat <num_net_players>
		if NOT ($is_attract_mode = 1)
			gamemode_gettype
			if (<type> = career)
				if progression_check_for_gig_end
					change \{achievements_newgigwonflag = 1}
				endif
			endif
			achievements_update
			change \{achievements_songwonflag = 0}
			change \{achievements_newgigwonflag = 0}
		endif
	endif
endscript

script net_load_preferences 
	netoptions :pref_add \{name = private_slots
		array = $num_private_slots
		index = 0
		value_field = num
		display_string_field = name}
	netoptions :pref_add \{name = ranked
		array = $ranked_info
		index = 0
		display_string_field = name}
	netoptions :pref_add \{name = join_in_progress
		array = $join_in_progress_info
		index = 0
		value_field = num
		display_string_field = name}
	netoptions :pref_add \{name = num_players
		array = $num_players_info
		index = 1
		value_field = num
		display_string_field = name}
	if ($is_multiplayer_beta = 0)
		netoptions :pref_add \{name = game_modes
			array = $net_game_type_info
			index = 0
			display_string_field = name}
	else
		netoptions :pref_add \{name = game_modes
			array = $beta_net_game_type_info
			index = 0
			display_string_field = name}
	endif
endscript

script new_net_player 
	printf \{qs(0xcc13a237)}
	formattext checksumname = gamertag_global 'gamertag_%d' d = (<player_num> - 1)
	printstruct <...>
	if (<local_client> = 1)
		transfer_controller_value_for_local_player <...>
	endif
	change globalname = <gamertag_global> newvalue = <gamertag_string>
	change structurename = <player_status> gamertag = <gamertag_global>
	change structurename = <player_status> net_id_first = <net_id_first>
	change structurename = <player_status> net_id_second = <net_id_second>
	change structurename = <player_status> is_local_client = <local_client>
	change structurename = <player_status> net_obj_id = <obj_id>
	change structurename = <player_status> part = <part>
	change structurename = <player_status> team = <team>
	change structurename = <player_status> difficulty = <difficulty>
	change structurename = <player_status> career_earnings = <career_cash>
	getglobaltags \{user_options}
	sendnetmessage {
		type = lefty_update
		lefty_flag = (<lefty_flip_p1>)
	}
endscript

script host_proceed_to_online_play 
	printf \{qs(0xb2b28b68)}
	gamemode_getnumplayers
	change current_num_players = <num_players>
	startnetworkgame
endscript

script setautolaunchhostnetlevel 
	printf \{qs(0xb5e0a9a1)}
	change \{net_autolaunch_role = host}
endscript

script setautolaunchclient 
	printf \{qs(0xc9e66c76)}
	change \{net_autolaunch_role = client}
endscript

script ps3_new_invitation_received 
	begin
	if NOT (screenelementexists id = invite_container)
		break
	endif
	wait \{1
		gameframe}
	repeat
	createscreenelement \{type = containerelement
		id = invite_container
		parent = root_window
		pos = (0.0, 0.0)
		z_priority = 100}
	invite_container :obj_spawnscriptnow ps3_process_invites params = {count = <count> invitelist = <invitelist>}
endscript

script ps3_process_invites 
	if gotparam \{invitelist}
		if (<count> > 0)
			i = 0
			begin
			createscreenelement \{type = containerelement
				id = ps3_invite_container
				parent = invite_container
				pos = $ps3_invite_postion
				alpha = 0.0}
			createscreenelement \{type = spriteelement
				parent = ps3_invite_container
				texture = white
				rgba = [
					139
					69
					0
					255
				]
				pos = (0.0, 0.0)
				dims = (200.0, 65.0)
				just = [
					left
					top
				]}
			formattext textname = item_text qs(0x7647d0c4) d = (<invitelist> [<i>])
			createscreenelement {
				type = textblockelement
				parent = ps3_invite_container
				font = fontgrid_title_a1
				pos = (5.0, 5.0)
				dims = (400.0, 160.0)
				scale = (0.5, 0.5)
				rgba = [255 222 173 255]
				text = <item_text>
				just = [left top]
			}
			runscriptonscreenelement \{id = ps3_invite_container
				ps3_display_invite_container}
			begin
			if NOT (screenelementexists id = ps3_invite_container)
				break
			endif
			wait \{1
				gameframe}
			repeat
			<i> = (<i> + 1)
			repeat <count>
		endif
	endif
	if screenelementexists \{id = invite_container}
		destroyscreenelement \{id = invite_container}
	endif
endscript

script ps3_display_invite_container 
	ps3_invite_container :legacydomorph \{alpha = 1.0
		time = 1.0}
	wait \{1.0
		seconds}
	ps3_invite_container :legacydomorph \{alpha = 0.0
		time = 1.0}
	if screenelementexists \{id = ps3_invite_container}
		destroyscreenelement \{id = ps3_invite_container}
	endif
endscript

script ps3_display_invite_callback 
	printf \{qs(0xfa79ba7a)}
	printstruct <...>
endscript

script net_custom_guide_view_user_songs 
	printf \{qs(0xa819dc71)}
	printstruct <...>
	printscriptinfo
endscript

script get_controller_type 
	if NOT gotparam \{controller_index}
		return \{controller_type = controller}
	endif
	getcontrollertype controller = <controller_index>
	if NOT iscontrollerpluggedin controller = <controller_index>
		if (<controller_type> = controller)
			get_player_num_from_controller controller_index = <controller_index>
			if (<player_num> != -1)
				getplayerinfo <player_num> part
				return controller_type = <part>
			endif
		endif
	endif
	return controller_type = <controller_type>
endscript

script test_sequenced_msgs 
	sendstructure \{callback = callback_test_sequenced_msgs
		data_to_send = {
			number = 1
		}}
endscript

script callback_test_sequenced_msgs 
	printf qs(0x848da1e2) i = <number>
endscript

script test_retrieve_friends_list 
	netsessionfunc \{func = friends_init}
	netsessionfunc \{obj = friends
		func = begin_retrieve_friends_list
		params = {
			callback = test_friends_callback
			callback_params = {
				none
			}
		}}
endscript

script test_friends_callback 
	printf \{qs(0x1336825d)}
	printstruct <...>
	netsessionfunc func = createcustommessage params = {devicenum = 0 userlist = <friendlist> title = qs(0x88482835) game_msg = qs(0x1a7c6769) button_text = qs(0x054c661b) game_specific = guitar}
endscript

script get_player_num_from_controller 
	if NOT gotparam \{controller_index}
		printf \{qs(0x83889e11)}
	endif
	num_local_controllers = 4
	player_num = -1
	i = 1
	begin
	getplayerinfo <i> controller
	getplayerinfo <i> bot_play
	if (<bot_play> = 1)
		getplayerinfo <i> bot_original_controller
		if (<bot_original_controller> != -1)
			controller = <bot_original_controller>
		endif
	endif
	if (<controller_index> = <controller>)
		player_num = <i>
		break
	endif
	i = (<i> + 1)
	repeat <num_local_controllers>
	return player_num = <player_num>
endscript

script net_dummy_get_needed_search_params 
	if ($game_mode = p4_career)
		guitars = 2
		drums = 1
		microphones = 1
		scoring_mode = career
	else
		guitars = 1
		drums = 0
		microphones = 0
		scoring_mode = competitive
	endif
	return needed_guitars = <guitars> needed_drums = <drums> needed_microphones = <microphones> scoring_mode = <scoring_mode>
endscript

script net_get_player_instrument 
	requireparams \{[
			controller_index
		]
		all}
	get_controller_type controller_index = <controller_index>
	rb_drums = 0
	if checksumequals a = <controller_type> b = drum
		if isrbdrum controller = <controller_index>
			rb_drums = 1
		endif
	endif
	return instrument = <controller_type> <...>
endscript

script net_get_player_guitar_flag 
	printf \{qs(0xde0d8e43)}
	requireparams \{[
			controller_index
		]
		all}
	get_player_num_from_controller controller_index = <controller_index>
	getplayerinfo <player_num> part
	if (<part> = bass)
		return \{flag = 1}
	else
		return \{flag = 0}
	endif
endscript

script net_get_player_cash 
	requireparams \{[
			controller_index
		]
		all}
	get_player_num_from_controller controller_index = <controller_index>
	cash_ranks_get_rank player = <player_num>
	return career_cash = <career_earnings>
endscript

script net_get_player_difficulty 
	requireparams \{[
			controller_index
		]
		all}
	get_player_num_from_controller controller_index = <controller_index>
	if (<player_num> != -1)
		getplayerinfo <player_num> difficulty
	else
		printf \{qs(0x87ee2a4c)}
		difficulty = easy
	endif
	return difficulty = <difficulty>
endscript

script get_local_players_in_game 
	printf \{qs(0xfccab215)}
	if isxenon
		max_local_players = 4
	else
		max_local_players = 7
	endif
	i = 0
	array = []
	num_local_players = 0
	begin
	netsessionfunc func = iscontrolleringame params = {controller = <i>}
	if gotparam \{isingame}
		addarrayelement array = <array> element = 1
		num_local_players = (<num_local_players> + 1)
		removeparameter \{isingame}
	else
		addarrayelement array = <array> element = 0
	endif
	i = (<i> + 1)
	repeat <max_local_players>
	return local_players = <array> num_local_players = <num_local_players>
endscript

script net_restore_player_status_structs 
	exception_index = -1
	if gotparam \{exception_indices}
		exception_index = (<exception_indices> [0])
		index = 0
	endif
	i = 0
	begin
	if NOT (<i> = <exception_index>)
		formattext checksumname = gamertag 'gamertag_%d' d = <i>
		change globalname = <gamertag> newvalue = qs(0x00000000)
		setplayerinfo (<i> + 1) net_id_first = 0
		setplayerinfo (<i> + 1) net_id_second = 0
		setplayerinfo (<i> + 1) team = 0
		setplayerinfo (<i> + 1) highway_layout = default_highway
		if (<i> < 4)
			setplayerinfo (<i> + 1) is_local_client = 1
			getplayerinfo (<i> + 1) controller
			if (<controller> > 3)
				controller = 3
				setplayerinfo (<i> + 1) controller = <controller>
			endif
		else
			setplayerinfo (<i> + 1) is_local_client = 0
		endif
	else
		if gotparam \{index}
			getarraysize <exception_indices>
			if ((<index> + 1) < <array_size>)
				index = (<index> + 1)
				exception_index = (<exception_indices> [<index>])
			else
				exception_index = -1
			endif
		endif
	endif
	i = (<i> + 1)
	repeat 8
endscript

script transfer_controller_value_for_local_player 
	printf \{qs(0x70e88519)}
	if isps3
		num_local_controllers = 7
	else
		num_local_controllers = 4
	endif
	i = 0
	begin
	if (($temp_net_id [<i>].net_id_first) = <net_id_first> && ($temp_net_id [<i>].net_id_second) = <net_id_second>)
		if isps3
			if localizedstringequals a = ($temp_net_id [<i>].name) b = <gamertag_string>
				change structurename = <player_status> controller = <i>
				restore_save_net_preferences controller_index = <i> player_status_index = ($<player_status>.player)
				player_found = 1
				break
			endif
		else
			change structurename = <player_status> controller = <i>
			restore_save_net_preferences controller_index = <i> player_status_index = ($<player_status>.player)
			player_found = 1
			break
		endif
	endif
	i = (<i> + 1)
	repeat <num_local_controllers>
	if NOT gotparam \{player_found}
		change structurename = <player_status> controller = 3
	endif
endscript

script net_choose_gamemode_from_players 
	printf \{qs(0x330f85fe)}
	printstruct <...>
	if checksumequals \{a = $game_mode
			b = p4_career}
		printf \{qs(0xd1270c2d)}
		switch <total_players>
			case 2
			printf \{qs(0x09c32524)}
			change \{game_mode = p2_career}
			change \{current_num_players = 2}
			case 3
			printf \{qs(0x10d81465)}
			change \{game_mode = p3_career}
			change \{current_num_players = 3}
			case 4
			printf \{qs(0x5f9982a2)}
			change \{game_mode = p4_career}
			change \{current_num_players = 4}
			default
			printf qs(0xc4b880c5) d = <total_players>
		endswitch
		change \{career_matchmaking_complete = 1}
	elseif checksumequals \{a = $game_mode
			b = p4_quickplay}
		printf \{qs(0x4e077ebc)}
		switch <total_players>
			case 2
			printf \{qs(0x09c32524)}
			change \{game_mode = p2_quickplay}
			change \{current_num_players = 2}
			case 3
			printf \{qs(0x10d81465)}
			change \{game_mode = p3_quickplay}
			change \{current_num_players = 3}
			default
			printf qs(0xc4b880c5) d = <total_players>
		endswitch
	elseif checksumequals \{a = $game_mode
			b = p8_pro_faceoff}
		printf \{qs(0x2bc53c10)}
		if NOT (<total_players> = 8)
			if NOT (<total_players> = 6)
				scriptassert 'trying to play band v band with %d playes (only 8 or 6 with no mics allowed)!' d = <total_players>
			endif
			printf \{qs(0x7f593fba)}
			change \{game_mode = p6_pro_faceoff_no_mics}
			change \{current_num_players = 6}
		else
			printf qs(0xc4b880c5) d = <total_players>
		endif
	endif
endscript

script net_party_can_accept_new_players 
	printf \{qs(0x2334dcd0)}
	netsessionfunc \{obj = party
		func = get_party_members}
	printstruct <...>
	can_join = 1
	check_insts = 0
	gamemode_gettype
	if (<type> = career)
		check_insts = 1
	endif
	if (<check_insts> = 1)
		num_guitars = 0
		num_mics = 0
		num_drums = 0
		getarraysize \{connections}
		if (<array_size> > 0)
			i = 0
			begin
			switch (<connections> [<i>].instrument)
				case eguitar
				num_guitars = (<num_guitars> + 1)
				case emicrophone
				num_mics = (<num_mics> + 1)
				case edrums
				num_drums = (<num_drums> + 1)
				default
				printf \{qs(0xf20fed67)}
			endswitch
			i = (<i> + 1)
			repeat <array_size>
		endif
		getarraysize \{new_connections}
		if (<array_size> > 0)
			i = 0
			begin
			switch (<new_connections> [<i>].instrument)
				case eguitar
				num_guitars = (<num_guitars> + 1)
				case emicrophone
				num_mics = (<num_mics> + 1)
				case edrums
				num_drums = (<num_drums> + 1)
				default
				printf \{qs(0xd922bea4)}
			endswitch
			i = (<i> + 1)
			repeat <array_size>
		endif
		can_join = 0
		if (<num_guitars> <= 2)
			if (<num_mics> <= 1)
				if (<num_drums> <= 1)
					can_join = 1
				endif
			endif
		endif
	endif
	return can_join = <can_join>
endscript

script spawn_player_drop_listeners 
	destroy_player_drop_events
	spawnscriptnow net_ui_player_drop_listeners params = {<...>}
endscript

script net_ui_player_drop_listeners \{drop_player_script = default_drop_player_script
		end_game_script = default_end_game_scr}
	printscriptinfo \{qs(0xeed0481c)}
	spawnscriptnow create_player_drop_events params = {<...>}
	spawnscriptnow create_end_game_events params = {<...>}
endscript

script create_player_drop_events 
	seteventhandler response = call_script event = drop_net_player scr = drop_script_spawner params = {spawn_script = <drop_player_script>}
	block
endscript

script create_end_game_events 
	seteventhandler response = call_script event = drop_player_end_game scr = drop_script_spawner params = {spawn_script = <end_game_script>}
	block
endscript

script end_game_kill_event_test 
	printf \{qs(0x43c62dae)}
	if (<is_game_over> = 1)
		printf \{qs(0xb76c91f9)}
	endif
endscript

script drop_script_spawner 
	if (1 = <is_game_over>)
		printf \{qs(0x80cfd935)}
		change \{net_ready_to_start = 1}
	endif
	spawnscriptnow <spawn_script> params = {<...>} id = ui_player_drop_scripts
endscript

script destroy_player_drop_events 
	printscriptinfo \{qs(0xb3fc45b9)}
	killspawnedscript \{name = create_player_drop_events}
	killspawnedscript \{name = create_end_game_events}
	killspawnedscript \{id = ui_player_drop_scripts}
endscript

script default_drop_player_script 
	warn_default_drop_script <...>
endscript

script default_end_game_scr 
	create_net_popup \{title = qs(0x5ca2c535)
		popup_text = qs(0x32f94482)}
	wait \{3
		seconds}
	destroy_net_popup
	quit_network_game
	generic_event_back \{state = uistate_online}
endscript

script warn_default_drop_script 
	printf \{qs(0x03ac90f0)}
	printf \{qs(0xbc5429e7)}
	printf \{qs(0xdd595c0d)}
	printf \{qs(0x9aeb32e8)}
	printf \{qs(0x838dd1ff)}
	printf \{qs(0x03ac90f0)}
	printstruct <...>
	ui_print_states
endscript

script wait_for_net_popup 
	begin
	if ($net_popup_active = 0)
		break
	endif
	wait \{1
		gameframe}
	repeat
endscript

script net_popup_game_over 
	if NOT ($net_popup_active)
		formattext textname = popup_text qs(0x5e34475d) s = <name_string>
		create_net_popup \{title = qs(0x5ca2c535)
			popup_text = wait
			3
			seconds}
		destroy_net_popup
	endif
endscript

script do_ps3_signin_state_change 
	printf \{qs(0x05f43ed9)}
	printstruct <...>
	if gotparam \{age_restricted}
		ui_event_wait event = menu_replace data = {state = <state> <params> require_live}
	elseif checkforsignin
		if gotparam \{going_to_career}
			change \{game_mode = p4_career}
			netoptions :pref_choose \{name = game_modes
				checksum = p4_career}
		endif
		netsessionfunc \{func = stats_init}
		netsessionfunc \{func = motd_uninit}
		netsessionfunc \{func = motd_init}
		netsessionfunc \{func = live_settings_init}
		ui_event_wait event = menu_replace state = $signin_continue_state data = ($signin_continue_data)
	else
		if gotparam \{state}
			ui_event_wait event = menu_replace data = {state = <state> <params> require_live}
		else
			sysnotify_handle_connection_loss \{cable_unplugged}
		endif
	endif
endscript

script net_party_leave_current_game 
	printf \{qs(0x33bef1ce)}
	destroy_player_drop_events
	quit_network_game_early
	net_clear_all_remote_player_status
	gamemode_gettype
	if (<type> = career)
		change \{net_band_mode_menu = invite}
		change \{num_players_in_band = 0}
		change \{net_band_members = [
			]}
		change \{net_num_joiners = 0}
		change \{career_matchmaking_complete = 0}
		change \{game_mode = p4_career}
		ui_event_get_stack
		found_state = 0
		ui_event_get_stack
		i = 0
		begin
		if ((<stack> [<i>].base_name) = 'band_mode')
			<found_state> = 1
			break
		endif
		i = (<i> + 1)
		repeat <stack_size>
		if (<found_state> = 1)
			generic_event_back data = {num_states = (<i> + 1)}
		else
			generic_event_back \{state = uistate_group_play}
		endif
		change \{net_popup_active = 0}
		unpausegame
	else
		startrendering
		destroy_net_popup
		change \{net_new_matchmaking_ui_flag = 0}
		unpausegame
		getglobaltags \{user_options}
		if ((<autosave> = 1) && (<type> = quickplay))
			ui_event_wait \{event = menu_replace
				data = {
					state = uistate_memcard
					type = autosave
					event_params = {
						event = menu_back
						data = {
							state = uistate_online
						}
					}
				}}
		else
			ui_event_wait \{event = menu_back
				state = uistate_online}
		endif
	endif
endscript

script net_party_host_cancel_matchmaking 
	printf \{qs(0x5d5cc043)}
	gamemode_gettype
	if (<type> = career)
		change \{net_band_mode_menu = invite}
		change \{net_band_members = [
			]}
		begin
		if NOT scriptisrunning \{ui_create_band_mode_spawned}
			ui_event_wait \{event = menu_back}
			break
		else
			wait \{1
				gameframe}
		endif
		repeat
	else
		printf \{qs(0xead951bb)}
	endif
endscript

script uisignin_motd_callback 
	printf \{qs(0xd00b2987)}
	if gotparam \{success}
		printf qs(0x2bbcd37a) d = ($motd_header)
		printf qs(0xa3db5484) d = ($motd_subject)
	else
		printf \{qs(0xce10362f)}
	endif
	printstruct <...>
endscript

script retrieved_live_settings_file 
endscript

script create_flaming_wait 
	printscriptinfo \{qs(0x470d8ce0)}
	createscreenelement {
		id = net_please_wait
		type = descinterface
		desc = 'net_please_wait'
		parent = root_window
		z_priority = <setlist_popup_z>
		alpha = 1.0
		not_focusable
		z_priority = 662
	}
	net_please_wait :se_setprops \{net_flame_message_text = qs(0xa4d1f3c3)}
endscript

script show_flaming_wait 
	wait \{2
		seconds}
	if screenelementexists \{id = net_please_wait}
		net_please_wait :se_setprops \{alpha = 1.0}
	endif
endscript

script destroy_flaming_wait 
	printscriptinfo \{qs(0x76965b35)}
	if screenelementexists \{id = net_please_wait}
		destroyscreenelement \{id = net_please_wait}
	endif
endscript

script net_dropped_player_recovery 
	change \{recovered_dropped_players = 1}
	printf \{qs(0x11894cb8)}
	gamemode_gettype
	if (<type> = career)
		formattext checksumname = mode 'p%d_career' d = ($current_num_players)
		change game_mode = <mode>
	endif
	if ($net_dropped_players_flag > 0)
		old_num_players_shown = (($current_num_players) + ($net_dropped_players_flag))
		gamemode_getnumplayersshown
		i = 1
		begin
		getplayerinfo <i> net_obj_id
		if (<net_obj_id> < 0)
			formattext checksumname = bogus_player_status 'player%d_status' d = <i>
			temp_bogus_gamertag = ($<bogus_player_status>.gamertag)
			temp_bogus_part = ($<bogus_player_status>.part)
			temp_bogus_character_id = ($<bogus_player_status>.character_id)
			temp_bogus_band_member = ($<bogus_player_status>.band_member)
			temp_bogus_difficulty = ($<bogus_player_status>.difficulty)
			temp_bogus_controller = ($<bogus_player_status>.controller)
			temp_bogus_fret_anims = ($<bogus_player_status>.fret_anims)
			temp_bogus_bot_play = ($<bogus_player_status>.bot_play)
			temp_bogus_bot_original_controller = ($<bogus_player_status>.bot_original_controller)
			temp_bogus_original_character_id = ($<bogus_player_status>.original_character_id)
			temp_bogus_lefty_flip = ($<bogus_player_status>.lefty_flip)
			temp_bogus_vocals_highway_view = ($<bogus_player_status>.vocals_highway_view)
			temp_bogus_lefthanded_gems = ($<bogus_player_status>.lefthanded_gems)
			temp_bogus_lefthanded_button_ups = ($<bogus_player_status>.lefthanded_button_ups)
			temp_bogus_lefthanded_gems_flip_save = ($<bogus_player_status>.lefthanded_gems_flip_save)
			temp_bogus_lefthanded_button_ups_flip_save = ($<bogus_player_status>.lefthanded_button_ups_flip_save)
			temp_bogus_vocal_streak_phrases = ($<bogus_player_status>.vocal_streak_phrases)
			temp_bogus_vocal_phrase_quality = ($<bogus_player_status>.vocal_phrase_quality)
			temp_bogus_vocal_phrase_max_qual = ($<bogus_player_status>.vocal_phrase_max_qual)
			temp_bogus_vocals_sp_clap = ($<bogus_player_status>.vocals_sp_clap)
			temp_bogus_mic_type = ($<bogus_player_status>.mic_type)
			temp_bogus_mic_connected = ($<bogus_player_status>.mic_connected)
			temp_bogus_hyperspeed = ($<bogus_player_status>.hyperspeed)
			temp_bogus_net_whammy = ($<bogus_player_status>.net_whammy)
			temp_bogus_is_local_client = ($<bogus_player_status>.is_local_client)
			temp_bogus_highway_layout = ($<bogus_player_status>.highway_layout)
			temp_bogus_net_id_first = ($<bogus_player_status>.net_id_first)
			temp_bogus_net_id_second = ($<bogus_player_status>.net_id_second)
			temp_bogus_controller_type = ($<bogus_player_status>.controller_type)
			temp_bogus_net_obj_id = ($<bogus_player_status>.net_obj_id)
			temp_bogus_net_difficulty = ($<bogus_player_status>.net_difficulty)
			temp_bogus_net_venue = ($<bogus_player_status>.net_venue)
			temp_bogus_team = ($<bogus_player_status>.team)
			temp_bogus_party_id = ($<bogus_player_status>.party_id)
			temp_bogus_individual_band_score = ($<bogus_player_status>.individual_band_score)
			temp_bogus_cash = ($<bogus_player_status>.cash)
			temp_bogus_new_cash = ($<bogus_player_status>.new_cash)
			temp_bogus_cash_rank_up = ($<bogus_player_status>.cash_rank_up)
			temp_bogus_career_earnings = ($<bogus_player_status>.career_earnings)
			j = (<i> + 1)
			begin
			getplayerinfo <j> net_obj_id
			if (<net_obj_id> >= 0)
				formattext checksumname = valid_player_status 'player%d_status' d = <j>
				printf qs(0x1f1776f8) c = <bogus_player_status> d = <valid_player_status>
				updateplayernumobjidmapper old_player_num = <j> new_player_num = <i>
				change structurename = <bogus_player_status> gamertag = ($<valid_player_status>.gamertag)
				change structurename = <bogus_player_status> part = ($<valid_player_status>.part)
				change structurename = <bogus_player_status> character_id = ($<valid_player_status>.character_id)
				change structurename = <bogus_player_status> band_member = ($<valid_player_status>.band_member)
				change structurename = <bogus_player_status> difficulty = ($<valid_player_status>.difficulty)
				change structurename = <bogus_player_status> controller = ($<valid_player_status>.controller)
				change structurename = <bogus_player_status> fret_anims = ($<valid_player_status>.fret_anims)
				change structurename = <bogus_player_status> bot_play = ($<valid_player_status>.bot_play)
				change structurename = <bogus_player_status> bot_original_controller = ($<valid_player_status>.bot_original_controller)
				change structurename = <bogus_player_status> original_character_id = ($<valid_player_status>.original_character_id)
				change structurename = <bogus_player_status> lefty_flip = ($<valid_player_status>.lefty_flip)
				change structurename = <bogus_player_status> vocals_highway_view = ($<valid_player_status>.vocals_highway_view)
				change structurename = <bogus_player_status> lefthanded_gems = ($<valid_player_status>.lefthanded_gems)
				change structurename = <bogus_player_status> lefthanded_button_ups = ($<valid_player_status>.lefthanded_button_ups)
				change structurename = <bogus_player_status> lefthanded_gems_flip_save = ($<valid_player_status>.lefthanded_gems_flip_save)
				change structurename = <bogus_player_status> lefthanded_button_ups_flip_save = ($<valid_player_status>.lefthanded_button_ups_flip_save)
				change structurename = <bogus_player_status> vocal_streak_phrases = ($<valid_player_status>.vocal_streak_phrases)
				change structurename = <bogus_player_status> vocal_phrase_quality = ($<valid_player_status>.vocal_phrase_quality)
				change structurename = <bogus_player_status> vocal_phrase_max_qual = ($<valid_player_status>.vocal_phrase_max_qual)
				change structurename = <bogus_player_status> vocals_sp_clap = ($<valid_player_status>.vocals_sp_clap)
				change structurename = <bogus_player_status> mic_type = ($<valid_player_status>.mic_type)
				change structurename = <bogus_player_status> mic_connected = ($<valid_player_status>.mic_connected)
				change structurename = <bogus_player_status> hyperspeed = ($<valid_player_status>.hyperspeed)
				change structurename = <bogus_player_status> net_whammy = ($<valid_player_status>.net_whammy)
				change structurename = <bogus_player_status> is_local_client = ($<valid_player_status>.is_local_client)
				change structurename = <bogus_player_status> highway_layout = ($<valid_player_status>.highway_layout)
				change structurename = <bogus_player_status> net_id_first = ($<valid_player_status>.net_id_first)
				change structurename = <bogus_player_status> net_id_second = ($<valid_player_status>.net_id_second)
				change structurename = <bogus_player_status> controller_type = ($<valid_player_status>.controller_type)
				change structurename = <bogus_player_status> net_obj_id = ($<valid_player_status>.net_obj_id)
				change structurename = <bogus_player_status> net_difficulty = ($<valid_player_status>.net_difficulty)
				change structurename = <bogus_player_status> net_venue = ($<valid_player_status>.net_venue)
				change structurename = <bogus_player_status> team = ($<valid_player_status>.team)
				change structurename = <bogus_player_status> party_id = ($<valid_player_status>.party_id)
				change structurename = <bogus_player_status> individual_band_score = ($<valid_player_status>.individual_band_score)
				change structurename = <bogus_player_status> cash = ($<valid_player_status>.cash)
				change structurename = <bogus_player_status> new_cash = ($<valid_player_status>.new_cash)
				change structurename = <bogus_player_status> cash_rank_up = ($<valid_player_status>.cash_rank_up)
				change structurename = <bogus_player_status> career_earnings = ($<valid_player_status>.career_earnings)
				change structurename = <valid_player_status> gamertag = <temp_bogus_gamertag>
				change structurename = <valid_player_status> part = <temp_bogus_part>
				change structurename = <valid_player_status> character_id = <temp_bogus_character_id>
				change structurename = <valid_player_status> band_member = <temp_bogus_band_member>
				change structurename = <valid_player_status> difficulty = <temp_bogus_difficulty>
				change structurename = <valid_player_status> controller = <temp_bogus_controller>
				change structurename = <valid_player_status> fret_anims = <temp_bogus_fret_anims>
				change structurename = <valid_player_status> bot_play = <temp_bogus_bot_play>
				change structurename = <valid_player_status> bot_original_controller = <temp_bogus_bot_original_controller>
				change structurename = <valid_player_status> original_character_id = <temp_bogus_original_character_id>
				change structurename = <valid_player_status> lefty_flip = <temp_bogus_lefty_flip>
				change structurename = <valid_player_status> vocals_highway_view = <temp_bogus_vocals_highway_view>
				change structurename = <valid_player_status> lefthanded_gems = <temp_bogus_lefthanded_gems>
				change structurename = <valid_player_status> lefthanded_button_ups = <temp_bogus_lefthanded_button_ups>
				change structurename = <valid_player_status> lefthanded_gems_flip_save = <temp_bogus_lefthanded_gems_flip_save>
				change structurename = <valid_player_status> lefthanded_button_ups_flip_save = <temp_bogus_lefthanded_button_ups_flip_save>
				change structurename = <valid_player_status> vocal_streak_phrases = <temp_bogus_vocal_streak_phrases>
				change structurename = <valid_player_status> vocal_phrase_quality = <temp_bogus_vocal_phrase_quality>
				change structurename = <valid_player_status> vocal_phrase_max_qual = <temp_bogus_vocal_phrase_max_qual>
				change structurename = <valid_player_status> vocals_sp_clap = <temp_bogus_vocals_sp_clap>
				change structurename = <valid_player_status> mic_type = <temp_bogus_mic_type>
				change structurename = <valid_player_status> mic_connected = <temp_bogus_mic_connected>
				change structurename = <valid_player_status> hyperspeed = <temp_bogus_hyperspeed>
				change structurename = <valid_player_status> net_whammy = <temp_bogus_net_whammy>
				change structurename = <valid_player_status> is_local_client = <temp_bogus_is_local_client>
				change structurename = <valid_player_status> highway_layout = <temp_bogus_highway_layout>
				change structurename = <valid_player_status> net_id_first = <temp_bogus_net_id_first>
				change structurename = <valid_player_status> net_id_second = <temp_bogus_net_id_second>
				change structurename = <valid_player_status> controller_type = <temp_bogus_controller_type>
				change structurename = <valid_player_status> net_obj_id = <temp_bogus_net_obj_id>
				change structurename = <valid_player_status> net_difficulty = <temp_bogus_net_difficulty>
				change structurename = <valid_player_status> net_venue = <temp_bogus_net_venue>
				change structurename = <valid_player_status> team = <temp_bogus_team>
				change structurename = <valid_player_status> party_id = <temp_bogus_party_id>
				change structurename = <valid_player_status> individual_band_score = <temp_bogus_individual_band_score>
				change structurename = <valid_player_status> cash = <temp_bogus_cash>
				change structurename = <valid_player_status> new_cash = <temp_bogus_new_cash>
				change structurename = <valid_player_status> cash_rank_up = <temp_bogus_cash_rank_up>
				change structurename = <valid_player_status> career_earnings = <temp_bogus_career_earnings>
				break
			endif
			j = (<j> + 1)
			repeat (<old_num_players_shown> - <i>)
		endif
		i = (<i> + 1)
		repeat <num_players_shown>
		change \{net_dropped_players_flag = 0}
	endif
endscript
net_career_drop_msg_timer_count = 0

script net_create_player_drop_message_box 
	printf \{qs(0x0c498bd4)}
	requireparams \{[
			parent_element
			drop_msg
		]
		all}
	if screenelementexists id = <parent_element>
		if NOT screenelementexists \{id = net_player_drop_container}
			createscreenelement {
				type = containerelement
				id = net_player_drop_container
				parent = <parent_element>
				pos = (640.0, 320.0)
				alpha = 0.0
				z_priority = 1000
				internal_just = [center center]
			}
			createscreenelement {
				type = textblockelement
				id = net_player_drop_fail_msg_text
				parent = net_player_drop_container
				text = <drop_msg>
				font = fontgrid_text_a6
				fit_width = `scale each line if larger`
				fit_height = `scale down if larger`
				pos = (0.0, -5.0)
				dims = (540.0, 180.0)
				rgba = [200 200 200 250]
				internal_scale = 1.0
				just = [center bottom]
				internal_just = [center center]
				shadow
				shadow_rgba = [0 0 0 255]
				shadow_offs = (2.0, 2.0)
				z_priority = 1500.1
			}
			createscreenelement \{type = spriteelement
				parent = net_player_drop_container
				texture = message_container
				rgba = [
					255
					255
					255
					255
				]
				pos = (0.0, -100.0)
				dims = (600.0, 450.0)
				just = [
					center
					center
				]
				z_priority = 1500.0}
			net_player_drop_container :obj_spawnscriptnow \{display_net_dropped_player_msg}
		else
			net_player_drop_fail_msg_text :se_getprops
			formattext textname = drop_message qs(0x5d10c996) t = <text> d = <drop_msg>
			net_player_drop_fail_msg_text :se_setprops text = <drop_message>
			change net_career_drop_msg_timer_count = (($net_career_drop_msg_timer_count) + 1)
		endif
	endif
endscript

script display_net_dropped_player_msg 
	printf \{qs(0xf38b4635)}
	obj_getid
	change \{net_career_drop_msg_timer_count = 3}
	<objid> :se_setprops alpha = 1.0 time = 0.5
	<objid> :se_waitprops
	begin
	wait \{1
		second}
	if ($net_career_drop_msg_timer_count < 0)
		break
	endif
	change net_career_drop_msg_timer_count = (($net_career_drop_msg_timer_count) - 1)
	repeat
	<objid> :se_setprops alpha = 0.0 time = 0.8
	<objid> :se_waitprops
	if ($net_career_drop_msg_timer_count > 0)
		display_net_dropped_player_msg
		return
	endif
	<objid> :die
endscript
