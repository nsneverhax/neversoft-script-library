online_lockout_gamemode = `default`
g_matchmaking_difficulty_difference = 0
num_players_info = [
	{
		name = qs(0x576d469b)
		checksum = num_1
		num = 1
	}
	{
		name = qs(0xe39e174e)
		checksum = num_2
		num = 2
	}
	{
		name = qs(0x0ccca1af)
		checksum = num_3
		num = 3
	}
	{
		name = qs(0xede2abcb)
		checksum = num_4
		num = 4
	}
	{
		name = qs(0x02b01d2a)
		checksum = num_4
		num = 5
	}
	{
		name = qs(0xe836c048)
		checksum = num_6
		num = 6
	}
	{
		name = qs(0x076476a9)
		checksum = num_4
		num = 7
	}
	{
		name = qs(0xf11bd2c1)
		checksum = num_8
		num = 8
	}
]
num_private_slots = [
	{
		name = qs(0xe64a7ccd)
		checksum = num_0
		num = 0
	}
	{
		name = qs(0x0918ca2c)
		checksum = num_1
		num = 1
	}
]
ranked_info = [
	{
		name = qs(0x3489402d)
		checksum = player
		num = 1
	}
	{
		name = qs(0xd6e06d82)
		checksum = ranked
		num = 0
	}
]
join_in_progress_info = [
	{
		name = qs(0xefa31a4a)
		num = 0
		checksum = no
	}
	{
		name = qs(0xe5fd67fa)
		num = 1
		checksum = yes
	}
]
net_game_type_info = [
	{
		name = qs(0xfabdce2b)
		description = qs(0x03ac90f0)
		checksum = quickplay
		num = 0
	}
	{
		name = qs(0xde7ec8b3)
		description = qs(0x03ac90f0)
		checksum = career
		num = 1
	}
	{
		name = qs(0x4130c16d)
		description = qs(0x03ac90f0)
		checksum = compmega_guitar
		num = 2
	}
	{
		name = qs(0xbd037a48)
		description = qs(0x03ac90f0)
		checksum = compmega_bass
		num = 3
	}
	{
		name = qs(0x0f0463f9)
		description = qs(0x03ac90f0)
		checksum = compmega_drum
		num = 4
	}
	{
		name = qs(0xcfab17a3)
		description = qs(0x03ac90f0)
		checksum = compmega_vocals
		num = 5
	}
	{
		name = qs(0x0d53e374)
		description = qs(0x03ac90f0)
		checksum = fest_mode_guitar
		num = 6
	}
	{
		name = qs(0xb9e0b9e6)
		description = qs(0x03ac90f0)
		checksum = fest_mode_bass
		num = 7
	}
	{
		name = qs(0x0be7a057)
		description = qs(0x03ac90f0)
		checksum = fest_mode_drum
		num = 8
	}
	{
		name = qs(0x83c835ba)
		description = qs(0x03ac90f0)
		checksum = fest_mode_vocals
		num = 9
	}
	{
		name = qs(0xcfcc2860)
		description = qs(0x03ac90f0)
		checksum = fest_mode_team_guitar
		num = 10
	}
	{
		name = qs(0x2f574ad3)
		description = qs(0x03ac90f0)
		checksum = fest_mode_team_bass
		num = 11
	}
	{
		name = qs(0x9d505362)
		description = qs(0x03ac90f0)
		checksum = fest_mode_team_drum
		num = 12
	}
	{
		name = qs(0x4157feae)
		description = qs(0x03ac90f0)
		checksum = fest_mode_team_vocals
		num = 13
	}
	{
		name = qs(0x239c19c0)
		description = qs(0x03ac90f0)
		checksum = compmega_team
		num = 14
	}
	{
		name = qs(0xb39401d6)
		description = qs(0x03ac90f0)
		checksum = band_vs_band
		num = 15
	}
]
beta_net_game_type_info = [
]
net_guitar_part_info = [
	{
		name = qs(0x0cc7d9b2)
		checksum = guitar
	}
	{
		name = qs(0x7d4f9214)
		checksum = bass
	}
]
controller_lookup_table = {
	controller = 'Vocal'
	guitar = 'Guitar'
	drum = 'Drum'
	bass = 'Bass'
	vocals = 'Vocal'
}
net_group_list = [
	diff_beginner
	diff_easy
	diff_medium
	diff_hard
	diff_expert
	diff_expert_plus
	inst_guitar
	inst_bass
	inst_drums
	inst_vocals
	players_total
	players_online
	offline_party
	offline_quickplay
	offline_career
	offline_competitive
	online_career
	online_quickplay
	online_pro_faceoff_total
	online_pro_faceoff_guitar
	online_pro_faceoff_bass
	online_pro_faceoff_drums
	online_pro_faceoff_vocals
	online_rockfest_total
	online_rockfest_guitar
	online_rockfest_bass
	online_rockfest_drums
	online_rockfest_vocals
	online_team_rockfest_total
	online_team_rockfest_guitar
	online_team_rockfest_bass
	online_team_rockfest_drums
	online_team_rockfest_vocals
	online_band_v_band
	online_team_pro_faceoff
]
net_drop_packet_percentage = 0
no_net_mode = 0
lan_mode = 1
internet_mode = 2
net_permision_to_select_song = 0
net_pause = 0
net_num_players_data_ack = 0
net_num_players_data_needed = 0
net_dropped_players_flag = 0
recovered_dropped_players = 0
message_of_the_day = qs(0x00000000)
online_song_choice_id = 0
online_signin_autoload_required = 0
net_autolaunch_role = none
net_popup_active = 0
matchmaking_countdown_complete_callback = move_to_net_setlist
net_autolaunch_level = americanwoman
net_autolaunch_song = load_z_frathouse
net_song_breakdown_countdown_time = 10
xenon_invite_confirm_title = qs(0xf3c9603f)
xenon_invite_confirm_dialog = qs(0xb202cc8b)
xenon_invite_confirm_yes = qs(0xb73cb78f)
xenon_invite_confirm_no = qs(0xf7723015)
xenon_invite_disallowed_title = qs(0xf3c9603f)
xenon_invite_disallowed_dialog = qs(0xc9d447ca)
xenon_invite_disallowed_ok = qs(0x0e41fe46)
ps3_non_primary_controller_id = qs(0xee4339cd)
ps3_invite_postion = (255.0, 96.0)

script net_autolaunch_spawned 
	change game_mode = ($autolaunch_gamemode)
	netoptions :pref_choose name = game_modes checksum = ($game_mode)
	generic_event_choose event = <event> no_sound state = uistate_signin data = {device_num = 0 primary = 1 allow_back = 1 new_state = uistate_net_setup require_live = 1 net_auto_launch = 1}
	block \{type = online_menu_created}
	add_active_controllers
	begin
	printf \{qs(0xee7c4887)}
	if screenelementexists \{id = current_menu}
		if all_clients_are_ready
			wait \{0.5
				seconds}
			break
		endif
	endif
	wait \{0.5
		seconds}
	repeat
	printf \{qs(0xdabc8077)}
	change \{online_to_setlist_count = 5}
	start_matchmaking device_num = ($primary_controller)
	change \{matchmaking_countdown_complete_callback = autolaunch_goto_setlist}
endscript

script autolaunch_goto_setlist 
	scriptassert \{qs(0x4fcdb2ee)}
	ui_event_block \{event = menu_add
		state = uistate_songlist
		data = {
			base_name = 'songlist'
		}}
	if local_player_is_choosing_song
		change current_level = ($net_autolaunch_level)
		playlist_setcurrentsong \{song = $net_autolaunch_song}
		wait \{2.0
			seconds}
		if ishost
			host_proceed_to_online_play
		endif
	endif
endscript

script quit_network_game 
	printf \{qs(0xffb8716a)}
	killspawnedscript \{name = audio_crowd_play_loading_screen_swell}
	killspawnedscript \{name = audio_crowd_loading_whistle}
	killspawnedscript \{name = net_career_gig_info_continue_for_clients}
	leaveserver
	removetimesynctask
	removematchmakinghandofftask
	songlistmatch \{func = quit_network_game}
	call_it = 1
	if gotparam \{no_unpost}
		if (<no_unpost> = 1)
			call_it = 0
		endif
	endif
	if (<call_it> = 1)
		netsessionfunc \{obj = session
			func = unpost_game}
	else
		netsessionfunc \{obj = session
			func = stop_singleplayer_session}
	endif
	netoptions :pref_choose \{name = private_slots
		value = 0}
	netoptions :pref_choose \{name = ranked
		checksum = player}
endscript

script postgame_lobby_quit \{confirm_script = confirm_quit_online
		confirm_params = {
		}}
	if gotparam \{device_num}
		if (<device_num> = $primary_controller)
			if gotparam \{id}
				launchevent type = unfocus target = <id>
			endif
			gamemode_gettype
			if (<type> = career)
				addparam \{structure_name = confirm_params
					name = save
					value = 1}
			endif
			ui_event_wait_for_safe
			ui_event_get_top
			if gotparam \{is_popup}
				ui_sfx \{menustate = generic
					uitype = select}
				generic_event_replace state = uistate_online_quit_warning data = {is_popup confirm_script = <confirm_script> confirm_params = <confirm_params>}
			else
				ui_sfx \{menustate = generic
					uitype = select}
				generic_event_choose state = uistate_online_quit_warning data = {is_popup confirm_script = <confirm_script> confirm_params = <confirm_params>}
			endif
		endif
	endif
endscript

script net_clear_player_info \{player = !i1768515945
		on_screen = 1
		is_local_client = 1
		async_io_status = busy}
	player_index = (<player> - 1)
	printf qs(0x7500e57a) d = <player>
	setplayerinfo <player> is_local_client = <is_local_client>
	setplayerinfo <player> net_id_first = 0
	setplayerinfo <player> net_id_second = 0
	setplayerinfo <player> net_obj_id = -1
	setplayerinfo <player> band = 1
	setplayerinfo <player> party_id = -1
	setplayerinfo <player> is_onscreen = <on_screen>
	setplayerinfo <player> in_game = 0
	setplayerinfo <player> total_award_points = 0
	setplayerinfo <player> recent_award_points = 0
	setplayerinfo <player> async_io_status = <async_io_status>
	formattext checksumname = gamertag 'gamertag_%d' d = (<player_index>)
	change globalname = <gamertag> newvalue = qs(0x00000000)
	controller = (<player_index>)
	if (<controller> > 3)
		controller = 3
	endif
	setplayerinfo <player> controller = <controller>
endscript

script net_clear_all_remote_player_info 
	player = 1
	begin
	if playerinfoequals <player> is_local_client = 0
		net_clear_player_info player = <player>
	else
		setplayerinfo <player> band = 1
	endif
	<player> = (<player> + 1)
	repeat 8
endscript

script shut_down_net_play 
	change \{net_pause = 0}
	change \{is_network_game = 0}
	setnetworkmode
	netsessionfunc \{obj = match
		func = stop_server_list}
	netsessionfunc \{obj = match
		func = free_server_list}
	netsessionfunc \{func = stats_uninit}
	if ($net_popup_active = 1)
		destroy_net_popup
	endif
	cleanup_sessionfuncs
	setup_sessionfuncs
	net_clear_all_remote_player_info
	setplayerinfo \{1
		highway_layout = default_highway}
	setplayerinfo \{2
		highway_layout = default_highway}
	destroy_player_drop_events
endscript

script select_quit_network_game \{from_fail_menu = 0
		confirm_script = confirm_quit_online
		confirm_params = {
		}}
	if screenelementexists \{id = yourock_text}
		destroyscreenelement \{id = yourock_text}
	endif
	if screenelementexists \{id = yourock_text_2}
		destroyscreenelement \{id = yourock_text_2}
	endif
	if ($net_popup_active = 0)
		gamemode_gettype
		if (<type> = career)
			if ishost
				if (<from_fail_menu> = 1)
					quit_online_now \{new_state = uistate_band_lobby
						save = 1}
				else
					if (<quit_type> = none)
						quit_online_now \{new_state = uistate_mainmenu
							save = 1}
					else
						sendstructure callback = net_career_quit_song data_to_send = {quit_type = <quit_type>}
						net_career_quit_song quit_type = <quit_type>
					endif
				endif
			else
				quit_online_now \{save = 1}
			endif
		else
			ui_sfx \{menustate = generic
				uitype = select}
			if (quickplay = <type>)
				generic_event_choose state = uistate_online_quit_warning data = {player_device = <device_num> confirm_script = <confirm_script> confirm_params = {save = 1}}
			elseif (competitive = <type>)
				generic_event_choose state = uistate_online_quit_warning data = {player_device = <device_num> confirm_script = <confirm_script> confirm_params = {save = 0}}
			endif
		endif
	endif
endscript

script quit_network_game_early 
	if NOT ($is_network_game)
		return
	endif
	wait_for_start_gem_scroller_completion
	quit_network_game no_unpost = <no_unpost>
	if gotparam \{signin_change}
		shut_down_net_play
	else
		if ($playing_song = 1)
			kill_gem_scroller
		endif
	endif
endscript

script generic_net_sync 
	cleargameover
	syncandlaunchnetgame
	begin
	if ($net_ready_to_start)
		if gotparam \{callback}
			if NOT gotparam \{callback_params}
				callback_params = {}
			endif
			<callback> <callback_params>
		endif
		break
	endif
	wait \{1
		gameframe}
	repeat
	if ishost
		resetclientsloading
	endif
endscript

script start_first_net_song 
	ui_event_get_top
	if NOT (<base_name> = 'gameplay')
		ui_event \{event = menu_replace
			data = {
				state = uistate_gameplay
			}}
	endif
endscript

script continue_between_net_songs 
	printf \{qs(0xf792eb5e)}
	if screenelementexists \{id = song_breakdown_noncompetitive_id}
		change \{song_breakdown_countdown_time = 5}
		ui_song_breakdown_setup_handler_scripts \{add_setlist_continue_handlers
			continue_to_next_song}
	elseif screenelementexists \{id = song_breakdown_competitive_id}
		change \{song_breakdown_countdown_time = 5}
		ui_song_breakdown_competitive_setup_handler_scripts \{continue_setlist_transition
			add_setlist_continue_handlers}
	else
		scriptassert \{'unpausing song when we should start the timer'}
		gman_startgamemodegoal
		change \{songtime_paused = 0}
	endif
endscript

script cancel_join_server 
	printf \{qs(0x8a62650c)}
	leaveserver
	netsessionfunc \{obj = session
		func = unpost_game}
	netsessionfunc \{obj = match
		func = free_server_list}
endscript

script set_match_values 
	set_network_preferences \{dont_set}
	net_dummy_get_needed_search_params
	getfirstplayer
	getplayerinfo <player> difficulty
	gamemode_gettype
	if checksumequals a = <type> b = career
		difficulty = expert
	elseif checksumequals a = <type> b = quickplay
		difficulty = expert
	endif
	return {
		difficulty = <difficulty>
		gamemode = <gamemode>
		num_songs = ($num_songs)
		scoring_mode = <scoring_mode>
	}
endscript

script set_network_preferences 
	printf \{qs(0x6cf9bcf7)}
	<leader_player> = ($g_leader_player_num)
	if (<leader_player> < 1)
		getfirstplayer \{local}
		<leader_player> = <player>
	endif
	if NOT gotparam \{dont_set}
		getplayerinfo <leader_player> part
		<is_instrument_specific> = 0
		if checksumequals a = ($game_mode) b = compmega
			<is_instrument_specific> = 1
		elseif checksumequals a = ($game_mode) b = fest_mode
			<is_instrument_specific> = 1
		elseif checksumequals a = ($game_mode) b = fest_mode_team
			<is_instrument_specific> = 1
		endif
		if (<is_instrument_specific> = 1)
			switch <part>
				case bass
				extendcrc ($game_mode) '_bass' out = game_checksum
				case drum
				extendcrc ($game_mode) '_drum' out = game_checksum
				case guitar
				extendcrc ($game_mode) '_guitar' out = game_checksum
				case vocals
				extendcrc ($game_mode) '_vocals' out = game_checksum
			endswitch
		else
			<game_checksum> = ($game_mode)
		endif
		if checksumequals a = ($game_mode) b = compmega_team
			if checksumequals a = ($competitive_rules) b = band_vs_band
				<game_checksum> = band_vs_band
			endif
		endif
		netoptions :pref_choose name = game_modes checksum = <game_checksum>
		netoptions :pref_choose \{name = ranked
			checksum = player}
		netoptions :pref_getstruct \{name = game_modes}
		gamemode_getmaxplayers
		netoptions :pref_choose name = num_players value = <max_players>
	endif
	netoptions :pref_getstruct \{name = game_modes}
	getplayerinfo <leader_player> difficulty
	search_checksum = (<pref_struct>.num)
	printf \{qs(0x40859cd0)}
	<game_mode> = ($game_mode)
	printstruct <...>
	return {
		gamemode = <search_checksum>
		difficulty = <difficulty>
		num_songs = dont_care
	}
endscript
g_tmr_collect = 0

script tmr_collect \{on = 1}
	change g_tmr_collect = <on>
endscript

script console_is_net_career_client 
	gamemode_gettype
	if (<type> = career)
		if innetgame
			if NOT ishost
				return \{true}
			endif
		endif
	endif
	return \{false}
endscript

script set_netgame_globals 
	printf \{qs(0xc7b8dbb0)}
	printstruct <...>
	change game_mode = <game_mode>
	change current_level = <level>
endscript

script cleanup_sessionfuncs 
	printf \{qs(0x7abbf921)}
	netsessionfunc \{func = match_uninit}
	netsessionfunc \{func = stats_uninit}
endscript

script setup_sessionfuncs 
	printf \{qs(0x6deffbba)}
	netsessionfunc \{func = match_init}
	netsessionfunc \{func = stats_init}
	netsessionfunc \{func = voice_init}
	netsessionfunc \{func = motd_init}
	netsessionfunc \{obj = voice
		func = enable}
endscript

script launch_game 
	gamemode_gettype
	if (<type> = career)
		playlist_getcurrentsong
		ui_event event = menu_change data = {state = uistate_play_song song_checksum = <current_song> song_index = ($net_career_song_index)}
	else
		generic_event_choose \{state = uistate_play_song}
	endif
endscript

script load_and_sync_timing \{start_delay = 3000}
	printf \{qs(0x73081805)}
	printf \{qs(0x5b6fd41c)
		i = $current_level}
	gamemode_gettype
	getplayerinfo \{1
		controller}
	if (<type> != career)
		change \{current_transition = fastintro}
		restart_gem_scroller starttime = 0 endtime = 999999999 device_num = <controller>
	else
		transition_selecttransition
		restart_gem_scroller starttime = 0 endtime = 999999999 device_num = <controller> loading_transition = 0
		($default_loading_screen.destroy)
	endif
endscript

script launch_network_game 
	change \{net_ready_to_start = 1}
endscript

script net_control_whammy_pitch_loop 
	change \{pitch_dirty = 1}
	formattext checksumname = net_update_event 'net_button_check_p%d' d = <player> addtostringlookup = true
	begin
	getsongtime
	start_time = <songtime>
	block type = <net_update_event>
	getsongtime
	delta_time = (<songtime> - <start_time>)
	<time> = (<time> - (<delta_time> * 1000))
	killspawnedscript \{name = net_whammy_pitch_shift}
	spawnscriptnow net_whammy_pitch_shift params = {song = <song> array_entry = <array_entry> pattern = <pattern> player = <player> net_whammy_length = (<event_data>.net_whammy_length) time = <time>}
	repeat
	killspawnedscript \{name = net_whammy_pitch_shift}
endscript
pitch_dirty = 1
prev_len = 0

script net_whammy_pitch_shift 
	if ($pitch_dirty = 1)
		change \{pitch_dirty = 0}
		change prev_len = <net_whammy_length>
		begin
		controlwhammypitchshift player = <player> net_whammy_length = <net_whammy_length> time = <time>
		wait \{1
			gameframe}
		repeat
	else
		<len_delta> = (<net_whammy_length> - $prev_len)
		<len_base> = ($prev_len)
		change prev_len = <net_whammy_length>
		<frames> = 5
		<scale> = (1.0 / <frames>)
		<scale_step> = <scale>
		begin
		<len> = (<len_base> + (<len_delta> * <scale>))
		songaudiosetwhammy control = <len> player = <player>
		<whammy_scale> = (((<len> * 0.5) + 0.5) * 2.0)
		setnewwhammyvalue value = <whammy_scale> time_remaining = <time> player = <player>
		<scale> = (<scale> + <scale_step>)
		wait \{1
			gameframe}
		repeat <frames>
		begin
		songaudiosetwhammy control = <net_whammy_length> player = <player>
		<whammy_scale> = (((<net_whammy_length> * 0.5) + 0.5) * 2.0)
		setnewwhammyvalue value = <whammy_scale> time_remaining = <time> player = <player>
		wait \{1
			gameframe}
		repeat
	endif
endscript

script net_init 
	change \{is_network_game = 1}
	setnetworkmode \{$internet_mode}
	cleanup_sessionfuncs
	setup_sessionfuncs
	netsessionfunc \{func = getnumplayers}
	spawn_player_drop_listeners
endscript

script wait_for_dw_init 
	begin
	if ($demonware_is_ready = 1)
		break
	endif
	wait \{1
		frame}
	repeat
	add_active_controllers
	menu_net_matchmaking_init
	destroy_dialog_box
endscript

script add_active_controllers 
	getactivecontrollers
	getarraysize <active_controllers>
	controller_index = 0
	begin
	if (<active_controllers> [<controller_index>] = 1)
		if checkforsignin controller_index = <controller_index>
			netsessionfunc func = addcontrollers params = {controller = <controller_index>}
		endif
	endif
	<controller_index> = (<controller_index> + 1)
	repeat <array_size>
endscript

script add_active_controllers_local 
	getactivecontrollers
	getarraysize <active_controllers>
	controller_index = 0
	begin
	if (<active_controllers> [<controller_index>] = 1)
		if checkforsignin local controller_index = <controller_index>
			netsessionfunc func = addcontrollers params = {controller = <controller_index>}
		endif
	endif
	<controller_index> = (<controller_index> + 1)
	repeat <array_size>
endscript

script update_ingame_controllers 
	if musicstudio_mainobj :musicstudio_isinmusicstudio
		return
	endif
	if ($is_network_game = 0)
		if NOT ui_event_exists_in_stack \{name = 'band_lobby'}
			if gotparam \{controller}
				netsessionfunc \{func = removeallcontrollers}
				if isarray <controller>
					getarraysize <controller>
					if (<array_size> > 0)
						<i> = 0
						begin
						<c> = (<controller> [<i>])
						netsessionfunc func = addcontrollers params = {controller = <c>}
						<i> = (<i> + 1)
						repeat <array_size>
					endif
				else
					netsessionfunc func = addcontrollers params = {controller = <controller>}
				endif
			else
				add_active_controllers_local
			endif
		endif
	endif
endscript

script start_network_game 
	if ishost
		startnetworkgame
	endif
endscript

script online_fail_song 
	printf \{qs(0x34e995d3)}
	if ((gameisover) || (sessionisover))
		return
	endif
	netfailsong
endscript

script broadcast_received_winner_stats 
	setplayerinfo <player> best_run = <note_streak>
	setplayerinfo <player> total_notes = <total_notes>
	setplayerinfo <player> notes_hit = <notes_hit>
endscript

script set_rich_presence_game_mode 
	gamemode_gettype
	if ($calibrate_lag_enabled = 1)
		rich_presence_context = context_menus
	elseif ($is_network_game)
		change \{rich_presence_context = presence_online}
	elseif ($rich_presence_context != presence_music_studio)
		switch <type>
			case practice
			change \{rich_presence_context = presence_practice}
			case tutorial
			change \{rich_presence_context = presence_tutorial}
			case freeplay
			change \{rich_presence_context = presence_party_play}
			case quickplay
			change \{rich_presence_context = presence_quickplay}
			case career
			change \{rich_presence_context = presence_career}
			case competitive
			change \{rich_presence_context = presence_head_to_head}
		endswitch
	endif
endscript

script start_up_in_game_ads 
	if should_we_record_dynamic_ads_for_this_song
		dynamicadmanagercommand \{func = issuecue
			cue = connect}
	else
	endif
endscript
bps3singlesignoncheckcomplete = 0

script xenon_singleplayer_session_init \{ps3_signin_callback = xenon_singleplayer_session_init}
	if checkforsignin
		netsessionfunc \{func = stats_uninit}
		netsessionfunc \{func = stats_init}
		netsessionfunc \{func = motd_init}
		if isxenonorwindx
			netsessionfunc \{func = start_singleplayer_session
				obj = session}
		endif
	else
		if NOT isxenonorwindx
			if NOT gotparam \{from_callback}
				if (0 = $bps3singlesignoncheckcomplete)
					netsessionfunc func = onlinesignin params = {callback = <ps3_signin_callback>}
					change \{bps3singlesignoncheckcomplete = 1}
				endif
			else
				printf \{qs(0x2d9e8584)}
				change \{ps3_signin_complete = 1}
			endif
		endif
	endif
endscript

script begin_singleplayer_game 
	if ($is_network_game = 1)
		if ishost
			if netsessionfunc \{obj = session
					func = has_active_session}
				netsessionfunc \{obj = session
					func = begin_singleplayer_game}
			endif
		endif
	else
		if netsessionfunc \{obj = session
				func = has_active_session}
			netsessionfunc \{obj = session
				func = begin_singleplayer_game}
		endif
	endif
endscript

script end_singleplayer_game 
	if netsessionfunc \{obj = session
			func = has_active_session}
		netsessionfunc \{obj = session
			func = end_singleplayer_game}
	endif
	netsessionfunc \{obj = session
		func = end_party_session}
endscript

script deinit_all_for_invite 
	end_practice_song_slomo
endscript

script xenon_singleplayer_session_begin_uninit 
	if isxenonorwindx
		if netsessionfunc \{obj = session
				func = is_singleplayer_session}
			netsessionfunc \{func = stop_singleplayer_session
				obj = session}
		endif
	endif
endscript

script xenon_singleplayer_session_complete_uninit 
	if NOT gotparam \{song_failed}
		wait \{3
			seconds}
	endif
	netsessionfunc \{obj = session
		func = unpost_game}
endscript

script net_pausegh 
	printf \{qs(0x13c91937)}
	change \{net_pause = 1}
	broadcastevent \{type = event_pause_game}
	generic_event_choose \{state = uistate_pausemenu}
	wait \{1
		gameframe}
endscript

script net_unpausegh 
	printf \{qs(0x8609ed1f)}
	ui_event \{event = menu_back
		data = {
			state = uistate_gameplay
		}}
	wait \{1
		gameframe}
	change \{net_pause = 0}
endscript

script create_net_popup \{title = qs(0x00000000)
		popup_text = qs(0x00000000)}
	destroy_net_popup
	change \{net_popup_active = 1}
	create_dialog_box {
		dlg_z_priority = 10000
		heading_text = <title>
		body_text = <popup_text>
		dlg_z_priority = 5010
		no_background
	}
endscript

script destroy_net_popup 
	change \{net_popup_active = 0}
	destroy_dialog_box
endscript

script net_get_character_name \{player = 1
		check_profanity = 1}
	requireparams \{[
			player
		]
		all}
	getplayerinfo <player> character_id
	getplayerinfo <player> character_savegame
	if (<check_profanity> = 1)
		get_fullname_of_character id = <character_id> savegame = <character_savegame>
	else
		get_fullname_of_character id = <character_id> savegame = <character_savegame> profanity_allowed
	endif
	return display_name = <fullname> character_id = <character_id>
endscript

script fake_invite 
	if ($primary_controller = -1)
		threadsafesetglobalinteger \{global_name = primary_controller
			new_value = 0}
	endif
	invite_accepted controllerid = ($primary_controller) fake_invite
endscript

script invite_accepted 
	if scriptisrunning \{do_join_invite_stuff}
		printf 'invite_accepted - replaced old invite for controller %c' c = ($invite_controller)
		killspawnedscript \{name = do_join_invite_stuff}
	endif
	printf 'invite_accepted - controllerID %c' c = <controllerid>
	change invite_controller = <controllerid>
	if ($primary_controller_assigned = 0)
		printf \{'invite_accepted - primary controller not yet assigned!'}
		printf \{qs(0x0d1bb516)}
		assign_new_primary_controller device_num = <controllerid>
	else
		printf 'invite_accepted - $primary_controller %p' p = ($primary_controller)
	endif
	do_join_invite_stuff <...> accepted_invite
endscript
join_invite_fail_reason = none

script do_join_invite_stuff 
	printf \{'do_join_invite_stuff'}
	setscriptcannotpause
	if isps3
		if NOT netsessionfunc \{func = isoldenoughforonline}
			if gotparam \{accepted_invite}
				printf \{'**** invite_accepted - Ignoring invite because signed in user is not old enough ****'}
				removeparameter \{accepted_invite}
			endif
		endif
	endif
	if gotparam \{accepted_invite}
		audio_kill_cutscene_audio
		change g_leader_player_num = (<controllerid> + 1)
		if (($primary_controller_assigned = 1) && ($invite_controller = $primary_controller))
			<invited_primary_controller> = true
		else
			<invited_primary_controller> = false
		endif
		printf qs(0x867bec5c) i = <invited_primary_controller>
		change \{online_signin_autoload_required = 0}
		wait_for_safe_shutdown
		printf \{qs(0x1c9bd5e2)}
		disable_pause
		if isps3
			netsessionfunc \{obj = party
				func = leave_party}
		else
			netsessionfunc \{obj = party
				func = stop_party_session}
		endif
		quit_network_game_early
		begin
		if ($start_gem_scroller_running = 0)
			break
		elseif ($songtime_paused = 1)
			change \{songtime_paused = 0}
		endif
		wait \{1
			gameframe}
		repeat
		unpausespawnedscript \{ui_event_block}
		destroy_friend_feed
		invite_wait_for_existing_signin_memcard_dlc_stuff_to_complete
		if (<invited_primary_controller> = true)
			create_loading_screen \{loading_screen_type = static
				for_invite = 1}
		endif
		ui_event_wait_for_safe
		if (($invite_controller) = -1)
			return
		endif
		gman_shutdowngamemodegoal
		end_singleplayer_game
		if NOT gotparam \{fake_invite}
			if islocallysignedin controller = ($primary_controller)
				if checkforsignin controller_index = ($primary_controller)
					net_init
				endif
			endif
		endif
		change \{has_invite_join_result_callback_completed = 0}
		startrendering
		destroy_dialog_box
		if (<invited_primary_controller> = true)
			setbuttoneventmappings \{block_menu_input}
			ui_event_block \{event = menu_replace
				data = {
					state = uistate_mainmenu
					selected_index = 1
					clear_previous_stack
					ignore_camera = 1
				}}
			ui_event_remove_params \{param = ignore_camera}
			ui_event_remove_params \{param = state_device}
			setbuttoneventmappings \{unblock_menu_input}
		else
			unpausegame
			ui_event_block {
				event = menu_replace
				data = {
					state = uistate_signin
					device_num = ($invite_controller)
					clear_previous_stack
					new_state = uistate_invite_continue
					new_data = {
						controllerid = ($invite_controller)
					}
				}
			}
			ui_event_remove_params \{param = state_device}
			return
		endif
		if NOT netsessionfunc func = iscontrolleringame params = {controller = ($invite_controller)}
			netsessionfunc func = addcontrollers params = {controller = ($invite_controller)}
		endif
		xenon_singleplayer_session_begin_uninit
		deinit_all_for_invite
		unpausegame
		if NOT isps3
			<controller_idx> = 0
			begin
			if netsessionfunc func = iscontrolleringame params = {controller = <controller_idx>}
				if checkforsignin controller_index = <controller_idx>
					if netsessionfunc func = ismultiplayerallowed params = {controller_index = <controller_idx>}
					else
						printf 'do_join_invite_stuff - removed controller %c, signed in but not multiplayer enabled' c = <controller_idx>
						netsessionfunc func = removecontroller params = {controller = <controller_idx>}
					endif
				else
					printf 'do_join_invite_stuff - removed controller %c, not signed in' c = <controller_idx>
					netsessionfunc func = removecontroller params = {controller = <controller_idx>}
				endif
			endif
			<controller_idx> = (<controller_idx> + 1)
			repeat 4
		endif
		if gotparam \{fake_invite}
			destroy_loading_screen
			ui_event_block \{event = menu_replace
				data = {
					state = uistate_mainmenu
					base_name = 'mainmenu'
					selected_index = 3
					clear_previous_stack
				}}
			ui_event_remove_params \{param = state_device}
		else
			printf \{qs(0x3bfdde01)}
			begin
			if netsessionfunc \{func = does_single_player_session_exist}
				printf \{qs(0xa228f423)}
				wait \{1
					frame}
			else
				printf \{qs(0xb8eee285)}
				break
			endif
			repeat
			printf \{qs(0x458b2072)}
			wait \{0.5
				seconds}
			if NOT joininviteserver
				change g_net_leader_player_num = ($g_leader_player_num)
				if isps3
					destroy_loading_screen
					sysnotify_handle_connection_loss \{cable_unplugged = cable_unplugged}
				endif
				if ($join_invite_fail_reason = non_matching_users)
					change \{respond_to_signin_changed = 1}
					change \{respond_to_signin_changed_func = ui_signin_changed_func}
					destroy_loading_screen
					sysnotify_handle_signin_change controller = ($invite_controller) message = user_changed
				elseif ($join_invite_fail_reason = session_find_error)
					destroy_loading_screen
					sysnotify_handle_connection_loss \{cable_unplugged = cable_unplugged}
					change \{join_invite_fail_reason = none}
				endif
				return
			endif
		endif
	else
		printf \{'do_join_invite_stuff - not accepted'}
		ui_event_block \{event = menu_replace
			data = {
				state = uistate_mainmenu
				base_name = 'mainmenu'
				selected_index = 3
				clear_previous_stack
			}}
		ui_event_remove_params \{param = state_device}
		change \{invite_controller = -1}
		netsessionfunc \{func = flushallinvitesessions}
	endif
endscript

script invite_wait_for_existing_signin_memcard_dlc_stuff_to_complete 
	printf \{'invite_wait_for_existing_signin_memcard_dlc_stuff_to_complete'}
	ui_event_wait_for_safe
	begin
	if ($signin_state_working = 0)
		break
	endif
	printf \{'invite_wait_for_existing_signin_memcard_dlc_stuff_to_complete - waiting for signin state to finish'}
	wait \{1
		gameframe}
	repeat
	ui_event_wait_for_safe
	begin
	if NOT ui_event_exists_in_stack \{name = 'memcard'}
		break
	endif
	if NOT is_ui_event_running
		if isshutdownsafe
			printf \{'invite_wait_for_existing_signin_memcard_dlc_stuff_to_complete - jumped out of the loop, memcard error'}
			break
		endif
	endif
	printf \{'invite_wait_for_existing_signin_memcard_dlc_stuff_to_complete - waiting for memcard state to finish'}
	wait \{1
		gameframe}
	repeat
	ui_event_wait_for_safe
	begin
	if NOT ui_event_exists_in_stack \{name = 'boot_download_scan'}
		break
	endif
	printf \{'invite_wait_for_existing_signin_memcard_dlc_stuff_to_complete - waiting for boot_download_scan state to finish'}
	wait \{1
		gameframe}
	repeat
	ui_event_wait_for_safe
endscript

script menu_show_gamercard_from_netid 
	requireparams \{[
			device_num
		]
		all}
	if checkforsignin controller_index = <device_num>
		if NOT ($is_network_game = 1)
			return
		endif
		if gotparam \{net_id}
			netsessionfunc func = showgamercard params = {player_xuid = <net_id> controller_index = <device_num>}
		endif
	endif
endscript

script win_now 
	extendcrc \{song_won
		'p1'
		out = type}
	broadcastevent type = <type>
endscript
new_message_of_the_day = 0

script splash_callback 
	printf \{qs(0x7cd3e629)}
	printstruct <...>
	if gotparam \{motd_text}
		change \{new_message_of_the_day = 1}
	else
		change \{new_message_of_the_day = 0}
	endif
endscript

script removeobserverbg 
endscript

script net_disable_pause 
	if NOT gotparam \{no_unpause}
		if ($net_pause = 1)
			net_unpausegh
		endif
	endif
	disable_pause
endscript

script net_fail_coop_song 
	printf \{qs(0x4a48ff2b)}
	sfx_backgrounds_new_area \{bg_sfx_area = frontend
		fadeintime = 5
		fadeintype = linear
		fadeouttime = 5
		fadeouttype = linear}
	net_disable_pause
	change \{recovered_dropped_players = 0}
	change \{net_num_players_data_ack = 0}
	killspawnedscript \{name = guitarevent_songwon_spawned}
	spawnscriptnow \{guitarevent_songfailed_spawned}
endscript
demonware_is_ready = 1
demonware_stun_failed = 0

script set_ready_for_input 
	change \{demonware_is_ready = 1}
	change \{demonware_stun_failed = 0}
endscript

script set_demonware_failed 
	change \{demonware_is_ready = 1}
	change \{demonware_stun_failed = 1}
endscript

script set_disable_demonware_input 
	change \{demonware_is_ready = 0}
endscript

script online_end_song 
	printf \{qs(0xdf6f59ee)}
	if ((gameisover) || (sessionisover))
		printf \{qs(0x27fd2f0c)}
		return
	endif
	change \{net_num_players_data_ack = 0}
	change \{recovered_dropped_players = 0}
	if (ishost)
		sendendsong
		client_handle_end_song
	endif
	gamemode_gettype
	if (<type> = quickplay)
		gman_getgoalsbyplayer \{player = 0}
		if (0 != <goals_by_player_size>)
			index = 0
			begin
			<goal_name> = (<goal_strings_by_player> [<index>])
			if (<goal_name> != qp_score_points_stdband && <goal_name> != qp_score_points_band)
				gman_pausegoal goal = (<goals_by_player> [<index>])
			endif
			index = (<index> + 1)
			repeat <goals_by_player_size>
		endif
	endif
	printf qs(0x8110ad7a) d = ($net_num_players_data_ack)
endscript

script client_handle_end_song 
	printf \{qs(0xb4527a20)}
	extendcrc \{song_won
		'p1'
		out = type}
	broadcastevent type = <type>
	gamemode_gettype
	change \{recovered_dropped_players = 0}
endscript

script net_load_preferences 
	netoptions :pref_add \{name = private_slots
		array = $num_private_slots
		index = 0
		value_field = num
		display_string_field = name}
	netoptions :pref_add \{name = ranked
		array = $ranked_info
		index = 0
		display_string_field = name}
	netoptions :pref_add \{name = join_in_progress
		array = $join_in_progress_info
		index = 0
		value_field = num
		display_string_field = name}
	netoptions :pref_add \{name = num_players
		array = $num_players_info
		index = 1
		value_field = num
		display_string_field = name}
	netoptions :pref_add \{name = game_modes
		array = $net_game_type_info
		index = 0
		display_string_field = name}
endscript

script new_net_player 
	printf \{qs(0xcc13a237)}
	formattext checksumname = gamertag_global 'gamertag_%d' d = (<player_num> - 1)
	printstruct <...>
	change globalname = <gamertag_global> newvalue = <gamertag_string>
	setplayerinfo <player_num> gamertag = <gamertag_global>
	setplayerinfo <player_num> net_id_first = <net_id_first>
	setplayerinfo <player_num> net_id_second = <net_id_second>
	setplayerinfo <player_num> is_local_client = <local_client>
	setplayerinfo <player_num> net_obj_id = <obj_id>
	setplayerinfo <player_num> part = <part>
	setplayerinfo <player_num> band = <band>
	setplayerinfo <player_num> in_game = 1
	setplayerinfo <player_num> difficulty = <difficulty>
	setplayerinfo <player_num> is_onscreen = <player_on_screen>
	setplayerinfo <player_num> console_id = <console_id>
	setplayerinfo <player_num> net_player_handle = <net_player_handle>
	if (<local_client> = 1)
		transfer_controller_value_for_local_player <...>
	else
		setplayerinfo <player_num> controller = 5
	endif
	setbandinfo <band> in_game = 1
endscript

script adjust_rest_of_on_stage_characters 
	gamemode_gettype
	if ((<type> != quickplay) && (<type> != competitive) && (<type> != career))
		return
	endif
	if NOT ininternetmode
		return
	endif
	getnumplayersingame \{out = num_players}
	if (<num_players> >= 4)
		return
	endif
	getfirstplayer \{local}
	getplayerinfo <player> band out = local_band
	get_player_infos_in_use
	begin
	removeparameter \{found_player}
	getarraysize <player_infos_in_use>
	i = 0
	begin
	player = (<player_infos_in_use> [<i>])
	getplayerinfo <player> in_game
	getplayerinfo <player> band
	getplayerinfo <player> is_local_client
	if (<in_game> = 0 || (<type> = competitive && <band> != <local_band> && <is_local_client> = 0))
		getplayerinfo <player> stored_character_index
		if (<stored_character_index> = 0)
			found_player = <player>
			break
		endif
	endif
	<i> = (<i> + 1)
	repeat <array_size>
	if gotparam \{found_player}
		removeparameter \{found_index}
		i = 1
		begin
		getarraysize <player_infos_in_use>
		j = 0
		begin
		player = (<player_infos_in_use> [<j>])
		getplayerinfo <player> in_game
		if (<in_game> = 0 || (<type> = competitive && <band> != <local_band> && <is_local_client> = 0))
			getplayerinfo <player> stored_character_index
			if (<stored_character_index> = <i>)
				break
			endif
		endif
		<j> = (<j> + 1)
		repeat <array_size>
		if (<j> = <array_size>)
			found_index = <i>
			break
		endif
		<i> = (<i> + 1)
		repeat 3
		if gotparam \{found_index}
			setplayerinfo <found_player> stored_character_index = <found_index>
			if ($g_leader_player_num > 0)
				savegame_player = ($g_leader_player_num)
			else
				savegame_player = <found_player>
			endif
			get_savegame_from_player player = <savegame_player>
			get_saved_band_member index = <found_index> savegame = <savegame>
			if NOT characterprofileexists savegame = <character_savegame> name = <character_id>
				setplayerinfo <found_player> character_id = ($failsafe_car_profile)
				setplayerinfo <found_player> character_savegame = <savegame>
			else
				setplayerinfo <found_player> character_id = <character_id>
				setplayerinfo <found_player> character_savegame = <character_savegame>
			endif
		endif
	else
		break
	endif
	repeat 4
endscript

script adjust_rest_of_on_stage_characters_and_instruments 
	gamemode_gettype
	if ((<type> != quickplay) && (<type> != competitive) && (<type> != career))
		return
	endif
	if NOT ininternetmode
		return
	endif
	getnumplayersingame \{out = num_players}
	if (<num_players> >= 4)
		return
	endif
	instruments_we_need = []
	getarraysize ($part_priority)
	if (<array_size> > 0)
		i = 0
		begin
		item = {part = ($part_priority [<i>])}
		addarrayelement array = <instruments_we_need> element = <item>
		<instruments_we_need> = <array>
		i = (<i> + 1)
		repeat <array_size>
	endif
	getfirstplayer \{out = player}
	begin
	getplayerinfo <player> part
	found = -1
	getarraysize \{instruments_we_need}
	if (<array_size> > 0)
		i = 0
		begin
		if ((<found> = -1) && (<part> = (<instruments_we_need> [<i>].part)))
			found = <i>
			break
		endif
		i = (<i> + 1)
		repeat <array_size>
	endif
	if (<found> != -1)
		removearrayelement array = <instruments_we_need> index = <found>
		<instruments_we_need> = <array>
	endif
	getnextplayer player = <player> out = player
	repeat <num_players>
	player = 1
	dirty = 0
	begin
	getplayerinfo <player> in_game
	if (<in_game> = 0)
		getarraysize \{instruments_we_need}
		if (<array_size> > 0)
			setplayerinfo <player> part = (<instruments_we_need> [0].part)
			removearrayelement array = <instruments_we_need> index = 0
			<instruments_we_need> = <array>
			dirty = 1
		endif
	endif
	player = (<player> + 1)
	repeat 4
	if (<dirty> = 1)
	endif
endscript

script net_start_character_silhouette 
	requireparams \{[
			player
		]
		all}
	printf \{qs(0xba320f4c)}
	formattext checksumname = submenu_data 'band_lobby_submenu_data_%i' i = <submenu_index>
	set_chosen_character_id player = <player> id = silhouette
endscript

script net_stop_character_silhouette 
	requireparams \{[
			player
		]
		all}
	printf \{qs(0xc3035321)}
	set_chosen_character_id player = <player> id = none
endscript

script check_for_net_appearance_arrival 
	requireparams \{[
			player
		]
		all}
	begin
	getplayerinfo <player> chosen_character_id
	if checksumequals a = <chosen_character_id> b = none
		break
	elseif net_appearance_is_valid player = <player>
		net_stop_character_silhouette player = <player>
		break
	endif
	wait \{0.5
		seconds}
	repeat
endscript

script net_appearance_is_valid 
	requireparams \{[
			player
		]
		all}
	getplayerinfo <player> character_id
	switch (<character_id>)
		case temporary_netprofile_0
		case temporary_netprofile_1
		case temporary_netprofile_2
		case temporary_netprofile_3
		case temporary_netprofile_4
		case temporary_netprofile_5
		case temporary_netprofile_6
		case temporary_netprofile_7
		return \{true}
		default
		return \{false}
	endswitch
endscript

script host_proceed_to_online_play 
	printf \{qs(0xb2b28b68)}
	startnetworkgame
endscript

script setautolaunchhostnetlevel 
	printf \{qs(0xb5e0a9a1)}
	change \{net_autolaunch_role = host}
endscript

script setautolaunchclient 
	printf \{qs(0xc9e66c76)}
	change \{net_autolaunch_role = client}
endscript

script get_controller_type 
	if NOT gotparam \{controller_index}
		return \{controller_type = controller}
	endif
	getcontrollertype controller = <controller_index>
	return controller_type = <controller_type>
endscript

script get_player_num_from_controller 
	requireparams \{[
			controller_index
		]
		all}
	num_local_controllers = 4
	player_num = -1
	i = 1
	begin
	getplayerinfo <i> controller
	if (<controller_index> = <controller>)
		player_num = <i>
		break
	endif
	i = (<i> + 1)
	repeat <num_local_controllers>
	return player_num = <player_num>
endscript

script get_local_player_num_from_controller 
	requireparams \{[
			controller_index
		]
		all}
	num_local_controllers = 4
	player = 1
	begin
	getplayerinfo <player> controller
	if (<controller_index> = <controller>)
		break
	endif
	player = (<player> + 1)
	repeat <num_local_controllers>
	return local_player_num = <player>
endscript

script net_dummy_get_needed_search_params 
	if ($g_lobby_state = career)
		guitars = 2
		drums = 1
		microphones = 1
		scoring_mode = career
	elseif ($g_lobby_state = quickplay)
		guitars = 2
		drums = 1
		microphones = 1
		scoring_mode = coop
	elseif ($g_lobby_state = vs)
		guitars = 1
		drums = 0
		microphones = 0
		scoring_mode = competitive
	endif
	return needed_guitars = <guitars> needed_drums = <drums> needed_microphones = <microphones> scoring_mode = <scoring_mode>
endscript

script net_get_player_instrument 
	requireparams \{[
			controller_index
		]
		all}
	get_controller_type controller_index = <controller_index>
	rb_drums = 0
	if checksumequals a = <controller_type> b = drum
		if isrbdrum controller = <controller_index>
			rb_drums = 1
		endif
	endif
	return instrument = <controller_type> <...>
endscript

script net_get_player_guitar_flag 
	printf \{qs(0xde0d8e43)}
	requireparams \{[
			controller_index
		]
		all}
	get_local_in_game_player_num_from_controller controller_index = <controller_index>
	getplayerinfo <player_num> part
	if (<part> = bass)
		return \{flag = 1}
	else
		return \{flag = 0}
	endif
endscript

script net_get_player_cash 
	return \{career_cash = 0}
endscript

script net_get_player_difficulty 
	requireparams \{[
			controller_index
		]
		all}
	get_local_in_game_player_num_from_controller controller_index = <controller_index>
	if (<player_num> != -1)
		getplayerinfo <player_num> difficulty
	else
		printf \{qs(0x87ee2a4c)}
		difficulty = easy
	endif
	return difficulty = <difficulty>
endscript

script get_local_players_in_game 
	printf \{qs(0xfccab215)}
	if isxenonorwindx
		max_local_players = 4
	else
		max_local_players = 7
	endif
	i = 0
	array = []
	num_local_players = 0
	begin
	netsessionfunc func = iscontrolleringame params = {controller = <i>}
	if gotparam \{isingame}
		addarrayelement array = <array> element = 1
		num_local_players = (<num_local_players> + 1)
		removeparameter \{isingame}
	else
		addarrayelement array = <array> element = 0
	endif
	i = (<i> + 1)
	repeat <max_local_players>
	return local_players = <array> num_local_players = <num_local_players>
endscript

script transfer_controller_value_for_local_player 
	printf \{qs(0x70e88519)}
	if isps3
		num_local_controllers = 7
	else
		num_local_controllers = 4
	endif
	<player_found> = 0
	i = 0
	begin
	if (($temp_net_id [<i>].net_id_first) = <net_id_first> && ($temp_net_id [<i>].net_id_second) = <net_id_second>)
		if isps3
			if localizedstringequals a = ($temp_net_id [<i>].name) b = <gamertag_string>
				<player_found> = 1
			endif
		else
			<player_found> = 1
		endif
		if (<player_found> = 1)
			printf qs(0x2c292f86) d = <i> p = <player_num> h = ($temp_net_id [<i>].cheat_hyperspeed) v = ($temp_net_id [<i>].cheat_hyperspeed_value)
			setplayerinfo <player_num> controller = <i>
			setplayerinfo <player_num> lefty_flip = ($temp_net_id [<i>].lefty_flip)
			setplayerinfo <player_num> mic_type = ($temp_net_id [<i>].mic_type)
			setplayerinfo <player_num> mic_preference = ($temp_net_id [<i>].mic_preference)
			setplayerinfo <player_num> character_id = ($temp_net_id [<i>].character_id)
			setplayerinfo <player_num> character_savegame = ($temp_net_id [<i>].character_savegame)
			setplayerinfo <player_num> double_kick_drum = ($temp_net_id [<i>].double_kick)
			setplayerinfo <player_num> difficulty = ($temp_net_id [<i>].difficulty)
			setplayerinfo <player_num> stored_character_index = ($temp_net_id [<i>].stored_character_index)
			setplayerinfo <player_num> part = ($temp_net_id [<i>].part)
			setplayerinfo <player_num> cheat_hyperspeed = ($temp_net_id [<i>].cheat_hyperspeed)
			setplayerinfo <player_num> cheat_hyperspeed_value = ($temp_net_id [<i>].cheat_hyperspeed_value)
			setplayerinfo <player_num> vocals_highway_view = ($temp_net_id [<i>].vocals_highway_view)
			setplayerinfo <player_num> enable_touch_strip = ($temp_net_id [<i>].enable_touch_strip)
			setplayerinfo <player_num> use_tilt_for_starpower = ($temp_net_id [<i>].use_tilt_for_starpower)
			setplayerinfo <player_num> solo_highway_mode = ($temp_net_id [<i>].solo_highway_mode)
			setplayerinfo <player_num> cheat_colorshuffle = ($temp_net_id [<i>].cheat_colorshuffle)
			getsavegamefromcontroller controller = <i>
			get_current_progression_award_points savegame = <savegame>
			setplayerinfo <player_num> recent_award_points = 0
			setplayerinfo <player_num> total_award_points = <total_award_points>
			break
		endif
	endif
	i = (<i> + 1)
	repeat <num_local_controllers>
	if (<player_found> = 0)
		setplayerinfo <player_num> controller = 3
	endif
endscript

script net_choose_gamemode_from_players 
	printf \{qs(0x330f85fe)}
	gamemode_gettype
	printstruct <...>
	if checksumequals a = <type> b = career
		printf \{qs(0xd1270c2d)}
	elseif checksumequals a = <type> b = quickplay
	endif
	if checksumequals \{a = $game_mode
			b = band_vs_band}
		printf qs(0xc4b880c5) d = <total_players>
	endif
endscript

script do_ps3_signin_state_change 
	printf \{qs(0x05f43ed9)}
	printstruct <...>
	jam = 0
	if gotparam \{fail_params}
		if structurecontains \{structure = fail_params
				jam}
			<jam> = (<fail_params>.jam)
		endif
	endif
	if gotparam \{age_restricted}
		ui_event_wait event = menu_replace data = {state = <state> <params> require_live jam = <jam>}
	elseif checkforsignin
		if gotparam \{going_to_career}
			change \{game_mode = career}
			netoptions :pref_choose \{name = game_modes
				checksum = career}
		endif
		netsessionfunc \{func = stats_init}
		netsessionfunc \{func = motd_uninit}
		netsessionfunc \{func = motd_init}
		netsessionfunc \{func = live_settings_init}
		netsessionfunc \{obj = live_settings
			func = get_settings}
		ui_event_wait event = menu_replace state = $signin_continue_state data = ($signin_continue_data)
	else
		ui_event_wait event = menu_replace data = {state = <state> <params> require_live jam = <jam>}
	endif
endscript

script net_matchmaking_ask_accept_lower_difficulty 
	printf \{qs(0x1b35246c)}
	if screenelementexists \{id = dialog_box_container}
		printf \{qs(0x6e40243e)}
		return
	endif
	<leader_player> = ($g_leader_player_num)
	if (<leader_player> < 1)
		getfirstplayer \{local}
		<leader_player> = <player>
	endif
	getplayerinfo <leader_player> difficulty
	if checksumequals a = <difficulty> b = beginner
		printf \{qs(0xbbf82744)}
		return
	endif
	band_lobby_change_focus_submenu_all \{focus_type = unfocus}
	change \{g_matchmaking_difficulty_difference = 0}
	getplayerinfo <leader_player> controller
	create_dialog_box {
		dlg_z_priority = 1000
		heading_text = qs(0x92fadeaa)
		body_text = qs(0x1cf929c6)
		parent = root_window
		no_background
		options = [
			{
				func = net_matchmaking_ask_return
				text = qs(0xd2915c27)
			}
			{
				func = net_matchmaking_loosen_difficulty
				text = qs(0x58e0a1fb)
			}
		]
		player_device = <controller>
	}
	assignalias id = <menu_id> alias = matchmaking_difficulty_loosen_menu
	launchevent \{type = focus
		target = matchmaking_difficulty_loosen_menu}
	runscriptonscreenelement \{id = matchmaking_difficulty_loosen_menu
		net_matchmaking_ask_late_found_players}
endscript

script net_matchmaking_ask_late_found_players 
	printf \{qs(0x30424fac)}
	begin
	if netsessionfunc \{obj = match
			func = has_found_players}
		netsessionfunc \{obj = match
			func = get_num_matchmaking_players}
		netsessionfunc \{obj = party
			func = get_party_members}
		getarraysize <connections>
		if (<num_matchmaking_players> > <array_size>)
			net_matchmaking_ask_return
			break
		endif
	endif
	wait \{1
		gameframe}
	repeat
endscript

script net_matchmaking_ask_return 
	printf \{qs(0x04b3371e)}
	if screenelementexists \{id = matchmaking_difficulty_loosen_menu}
		destroy_dialog_box
	endif
	if NOT user_control_helper_exists \{button = gamertag}
		add_gamertag_helper exclusive_device = <device_num>
	endif
	band_lobby_update_button_helpers \{menu = matchmaking}
	band_lobby_change_focus_submenu_all \{focus_type = focus}
endscript

script net_matchmaking_loosen_difficulty 
	printf \{qs(0x705bcaa3)}
	change \{g_matchmaking_difficulty_difference = 1}
	net_matchmaking_ask_return <...>
endscript

script net_matchmaking_check_accept_difficulty 
	bret = false
	if screenelementexists \{id = matchmaking_difficulty_loosen_menu}
	else
		bret = true
	endif
	return <bret> difference = ($g_matchmaking_difficulty_difference)
endscript

script is_accepting_invite_or_sigining_out 
	if (($invite_controller != -1) || ($shutdown_game_for_signin_change_flag = 1))
		return \{true}
	endif
	return \{false}
endscript

script is_accepting_invite 
	if ($invite_controller != -1)
		return \{true}
	endif
	return \{false}
endscript

script is_signing_out 
	if ($shutdown_game_for_signin_change_flag = 1)
		return \{true}
	endif
	return \{false}
endscript

script flowsync_sync_blockingforhost 
	flowsync_sync_notblockingforhost
	if ishost
		begin
		if flowsync_queryreadytocontinue
			break
		endif
		printf \{qs(0x03b05ec3)}
		wait \{1
			gameframe}
		repeat
	endif
	printf \{qs(0x8044462c)}
endscript

script flowsync_sync_blockingforall \{display_script = none
		display_params = {
		}
		callback = none
		callback_params = {
		}
		wait_count = 180}
	printf \{qs(0x16b7ee54)}
	flowsync_sync_notblockingforhost
	<count> = 0
	begin
	if flowsync_queryreadytocontinueall
		break
	endif
	if (<wait_count> = <count> && none != <display_script>)
		printf \{qs(0x8cb8fc01)}
		spawnscriptnow <display_script> params = <display_params>
	endif
	printf \{qs(0x3399d6c4)}
	<count> = (1 + <count>)
	waitonegameframe
	repeat
	if (none != <callback>)
		printf \{qs(0xdb03c029)}
		<callback> <callback_params>
	endif
	printf \{qs(0xb0fa07d8)}
endscript

script flowsync_sync_notblockingforhost 
	getnumplayersingame \{local}
	if (<num_players> > 0)
		getfirstplayer \{local}
		begin
		setplayerinfo <player> sync_point_status = ready_to_continue
		getnextplayer local player = <player>
		if (<player> = -1)
			break
		endif
		repeat
	endif
endscript

script flowsync_queryreadytocontinue 
	if NOT ishost
		scriptassert \{qs(0xe34e779e)}
	endif
	everyone_ready_to_continue = true
	getnumplayersingame
	if (<num_players> > 0)
		getfirstplayer
		begin
		getplayerinfo <player> sync_point_status
		if (<sync_point_status> = not_ready_to_continue)
			everyone_ready_to_continue = false
			break
		endif
		getnextplayer player = <player>
		if (<player> = -1)
			break
		endif
		repeat
	endif
	return <everyone_ready_to_continue>
endscript

script flowsync_queryreadytocontinueall 
	<everyone_ready_to_continue> = true
	getnumplayersingame
	if (<num_players> > 0)
		getfirstplayer
		begin
		getplayerinfo <player> sync_point_status
		if (<sync_point_status> = not_ready_to_continue)
			<everyone_ready_to_continue> = false
			break
		endif
		getnextplayer player = <player>
		if (<player> = -1)
			break
		endif
		repeat
	endif
	return <everyone_ready_to_continue>
endscript

script flowsync_cleanup 
	if NOT ishost
		scriptassert \{qs(0xdc63c03a)}
	endif
	getnumplayersingame
	if (<num_players> > 0)
		getfirstplayer
		begin
		setplayerinfo <player> sync_point_status = not_ready_to_continue
		getnextplayer player = <player>
		if (<player> = -1)
			break
		endif
		repeat
	endif
endscript

script flowsync_localcleanup 
	getnumplayersingame \{local}
	if (<num_players> > 0)
		getfirstplayer \{local}
		begin
		setplayerinfo <player> sync_point_status = not_ready_to_continue
		getnextplayer local player = <player>
		if (<player> = -1)
			break
		endif
		repeat
	endif
endscript

script net_save_and_uistate_change \{event = menu_back
		state = uistate_songlist}
	flowsync_localcleanup
	if gotparam \{is_popup}
		ui_memcard_autosave_all_players event = <event> state = <state> is_popup
	else
		ui_memcard_autosave_all_players event = <event> state = <state>
	endif
endscript

script common_start_matchmaking_setup 
	marketplacepersistencefunc \{func = pause}
	marketplacebgmonitorfunc \{func = set_background_download
		off}
	marketplacebgmonitorfunc \{func = stop_scan}
	band = 1
	begin
	setbandinfo <band> in_game = 0
	<band> = (<band> + 1)
	repeat 8
	if ($game_mode = compmega || $game_mode = fest_mode || $game_mode = fest_mode_team)
		if ($g_net_leader_player_num > 0)
			getplayerinfo ($g_net_leader_player_num) part out = force_part
			getnumplayersingame \{local}
			if (<num_players> > 0)
				getfirstplayer \{local}
				begin
				setplayerinfo <player> part = <force_part>
				getnextplayer local player = <player>
				repeat <num_players>
			endif
		endif
	endif
	netsessionfunc \{obj = party
		func = get_party_members}
	getarraysize <connections> param = num_party_members
	getactivecontrollers
	getarraysize <active_controllers> param = num_controllers
	if (<num_controllers> > 0)
		i = 0
		begin
		if netsessionfunc func = iscontrolleringame params = {controller = <i>}
			controller_found = 0
			if (<num_party_members> > 0)
				j = 0
				begin
				if (((<connections> [<j>].is_local) = 1) && ((<connections> [<j>].controller_index) = <i>))
					controller_found = 1
					break
				endif
				j = (<j> + 1)
				repeat <num_party_members>
			endif
			if (<controller_found> = 0)
				netsessionfunc func = removecontroller params = {controller = <i>}
			endif
		endif
		<i> = (<i> + 1)
		repeat <num_controllers>
	endif
	clear_temp_net_id_array
	setup_temp_net_id_array
endscript

script lock_player_parts 
	printf \{qs(0x861fd6e0)}
	if ishost
		getnumplayersingame
		if (<num_players> > 0)
			getfirstplayer \{out = index}
			num_bass = [0 0 0 0 0 0 0 0]
			num_guitar = [0 0 0 0 0 0 0 0]
			begin
			getplayerinfo <index> part
			getplayerinfo <index> band
			<team> = (<band> - 1)
			if (<part> = guitar || <part> = bass)
				if (<part> = guitar)
					setarrayelement arrayname = num_guitar index = <team> newvalue = (<num_guitar> [<team>] + 1)
					if (<num_guitar> [<team>] > 1)
						setplayerinfo <index> part = bass
					else
						setplayerinfo <index> part = guitar
					endif
				elseif (<part> = bass)
					setarrayelement arrayname = num_bass index = <team> newvalue = (<num_bass> [<team>] + 1)
					if (<num_bass> [<team>] > 1)
						setplayerinfo <index> part = guitar
					else
						setplayerinfo <index> part = bass
					endif
				endif
			endif
			getnextplayer player = <index> out = index
			repeat (<num_players>)
		endif
	endif
endscript

script match_team_player_parts 
	printf \{qs(0x79960405)}
	if ((ishost) || ($is_network_game = 0))
		getnumplayersingame
		if (<num_players> > 0)
			getfirstplayer \{out = index}
			num_bass = [0 0 0 0 0 0 0 0]
			num_guitar = [0 0 0 0 0 0 0 0]
			begin
			getplayerinfo <index> part
			getplayerinfo <index> band
			<team> = (<band> - 1)
			if (<part> = guitar || <part> = bass)
				if (<part> = guitar)
					setarrayelement arrayname = num_guitar index = <team> newvalue = (<num_guitar> [<team>] + 1)
				elseif (<part> = bass)
					setarrayelement arrayname = num_bass index = <team> newvalue = (<num_bass> [<team>] + 1)
				endif
			endif
			getnextplayer player = <index> out = index
			repeat (<num_players>)
			<num_extra_bassists> = 0
			getarraysize \{num_bass}
			<i> = 0
			begin
			if ((<num_bass> [<i>]) < (<num_bass> [(<i> + 1)]))
				<num_extra_bassists> = ((<num_bass> [(<i> + 1)]) - (<num_bass> [<i>]))
				<team> = (<i> + 1)
			elseif ((<num_bass> [<i>]) > (<num_bass> [(<i> + 1)]) && (((<num_bass> [(<i> + 1)]) > 0) || ((<num_guitar> [(<i> + 1)]) > 0)))
				<num_extra_bassists> = ((<num_bass> [<i>]) - (<num_bass> [(<i> + 1)]))
				<team> = <i>
			endif
			if (<num_extra_bassists> > 0)
				getfirstplayer
				begin
				getplayerinfo <player> band
				if playerinfoequals <player> band = (<team> + 1)
					if playerinfoequals <player> part = bass
						setplayerinfo <player> part = guitar
						<num_extra_bassists> = (<num_extra_bassists> - 1)
						setarrayelement arrayname = num_bass index = <team> newvalue = (<num_bass> [<team>] - 1)
						setarrayelement arrayname = num_guitar index = <team> newvalue = (<num_guitar> [<team>] + 1)
					endif
				endif
				if (<num_extra_bassists> <= 0)
					break
				endif
				getnextplayer player = <player>
				repeat (<num_players>)
			endif
			<i> = (<i> + 1)
			repeat (<array_size> - 1)
		endif
	endif
endscript

script update_ui_total_players 
	printf \{qs(0xdbe11d09)}
	gamemode_gettype
	if scriptisrunning \{bl_private_match_ui_timeout}
		killspawnedscript \{name = bl_private_match_ui_timeout}
	endif
	change \{g_career_search = null}
	if (<type> = career)
		printf \{qs(0x810d64d1)}
		getnumplayersingame \{local}
		if (<total_players> = <num_players>)
			wait \{5
				gameframes}
			finalizejoinprocesslocalonly
		endif
	else
		get_local_players_in_game
		netsessionfunc \{obj = party
			func = get_party_members}
		getarraysize <connections>
		if ((<array_size> = <num_local_players>) && (<array_size> = <total_players>))
			wait \{1
				second}
			finalizejoinprocesslocalonly
		endif
	endif
	bl_toggle_player_menu_representation \{action = off}
	change net_num_players = <total_players>
endscript

script net_clear_all_player_infos 
	<player> = 1
	begin
	net_clear_player_info player = <player>
	<player> = (<player> + 1)
	repeat 8
endscript

script net_msg_update_joining_ui 
	printf \{qs(0x1adf4bb7)}
	if isps3
		netsessionfunc \{func = setoutputdestination
			params = {
				value = log_tty
			}}
		netsessionfunc \{func = setoutputlevel
			params = {
				value = channel
			}}
	endif
	change \{debug_matchmaking_early_desirable = 0}
	gamemode_gettype
	if scriptisrunning \{band_lobby_matchmaking_update_loop}
		killspawnedscript \{name = band_lobby_matchmaking_update_loop}
	endif
	temp_clear_upper_player_infos
	<player> = 1
	begin
	formattext checksumname = musician_value 'musician%p' p = <player>
	setplayerinfo <player> band_member = <musician_value>
	<player> = (<player> + 1)
	repeat 4
	adjust_rest_of_on_stage_characters_and_instruments
	if (<type> = career)
		band_lobby_update_career_players
	else
		if screenelementexists \{id = band_lobby_desc_id}
			band_lobby_desc_id :obj_spawnscriptnow \{band_lobby_display_final_matchmaking_players}
		endif
	endif
	bl_toggle_player_menu_representation \{action = on}
	adjust_rest_of_on_stage_characters
	persistent_band_refresh_changed_characters
	spawn_player_drop_listeners \{drop_player_script = band_lobby_drop_player
		end_game_script = band_lobby_end_game}
	if (<type> = career)
		if screenelementexists \{id = band_lobby_desc_id}
			runscriptonscreenelement \{id = band_lobby_desc_id
				band_lobby_watchdog_all_player_appearance_change}
		endif
	endif
	netsessionfunc \{obj = voice
		func = turnteamtalkoff}
	if ishost
		if (<type> != career)
			start_dlc_songlist_sync
			sendstructure \{callback = start_dlc_songlist_sync
				data_to_send = {
					none
				}}
		endif
	endif
endscript

script start_dlc_songlist_sync 
	songlistmatch \{func = send_local}
endscript

script invite_to_game 
	requireparams \{[
			instrument
		]
		all}
	invite_title = qs(0xd3aaa0b4)
	base_msg = qs(0x22f1cef3)
	if isps3
		base_msg = qs(0x8bad7ab4)
	endif
	switch (<instrument>)
		case guitar
		formattext textname = invite_msg qs(0xb3a143ba) s = <base_msg> i = qs(0x00000000)
		case drum
		formattext textname = invite_msg qs(0xb3a143ba) s = <base_msg> i = qs(0x00000000)
		case mic
		formattext textname = invite_msg qs(0xb3a143ba) s = <base_msg> i = qs(0x00000000)
	endswitch
	userlist = [
		{
			name = <name>
			id = <net_id>
		}
	]
	invite_successful = 0
	if netsessionfunc func = createcustominvite params = {
			userlist = <userlist>
			game_msg = <invite_msg>
			title = <invite_title>
			game_specific = <instrument>
			device_num = <device_num>
		}
		invite_successful = 1
		dgsrecorddata_sendgameinvite controller = <device_num> userlist = <userlist> invite_msg = <invite_msg> invite_title = <invite_title> invite_instrument = <instrument>
	endif
	if screenelementexists \{id = current_band_lobby_popup}
		if isxenonorwindx
			current_band_lobby_popup :obj_spawnscriptnow create_invite_sent_dialog params = {invite_successful = <invite_successful>}
		endif
	endif
	if (<invite_successful> = 1)
		change \{g_lobby_invite_flag = 1}
	endif
	j = 0
	begin
	band_lobby_add_menu_update_to_queue submenu_index = <j> focus = 0
	j = (<j> + 1)
	repeat ($g_num_lobby_local_submenus)
endscript

script create_invite_sent_dialog 
	requireparams \{[
			invite_successful
		]
		all}
	getscreenelementzpriority \{id = band_lobby_popup_menu}
	begin
	if NOT (screenelementexists id = invite_sent_container)
		break
	endif
	wait \{1
		gameframe}
	repeat
	createscreenelement {
		type = containerelement
		id = invite_sent_container
		parent = current_band_lobby_popup
		pos = (640.0, 120.0)
		alpha = 1.0
		z_priority = (<z_priority> + 10)
		just = [center , center]
	}
	createscreenelement \{parent = invite_sent_container
		id = invitesentinterface
		type = descinterface
		desc = 'container_gamer_invite'
		pos = (0.0, 0.0)
		dims = (100.0, 100.0)
		scale = 1.0
		just = [
			center
			center
		]}
	if (<invite_successful> = 0)
		<id> :se_setprops text_popup_text = ($band_lobby_strings.invite_failed)
	endif
	invite_sent_container :se_setprops \{alpha = 1.0
		time = 1.0}
	invite_sent_container :se_waitprops
	wait \{1.0
		second}
	invite_sent_container :se_setprops \{alpha = 0.0
		time = 1.0}
	invite_sent_container :se_waitprops
	if screenelementexists \{id = invite_sent_container}
		destroyscreenelement \{id = invite_sent_container}
	endif
endscript

script test_send 
	test1 = 'does this get sent?'
	test2 = doesthisgetsent
	test3 = doesthisgetsent2
	printstruct <...>
	sendstructure callback = test_callback data_to_send = <...>
endscript

script test_callback 
	printf \{qs(0xebc04aee)}
	printstruct <...>
endscript

script test_sequenced_msgs 
	sendstructure \{callback = callback_test_sequenced_msgs
		data_to_send = {
			number = 1
		}}
endscript

script callback_test_sequenced_msgs 
	printf qs(0x848da1e2) i = <number>
endscript

script test_retrieve_friends_list 
	netsessionfunc \{func = friends_init}
	netsessionfunc \{obj = friends
		func = begin_retrieve_friends_list
		params = {
			callback = test_friends_callback
			callback_params = {
				none
			}
		}}
endscript

script test_friends_callback 
	printf \{qs(0x1336825d)}
	printstruct <...>
	netsessionfunc \{func = createcustommessage
		params = {
			devicenum = 0
			title = qs(0x88482835)
			game_msg = qs(0x1a7c6769)
			button_text = qs(0x054c661b)
			game_specific = guitar
		}}
endscript

script print_current_net_prefs 
	netoptions :pref_get \{name = game_modes}
	printstruct <...>
	netoptions :pref_get \{name = ranked}
	printstruct <...>
endscript

script check_signin_wrapper 
	printstruct <...>
	if checkforsignin local controller controller_index = <device_num>
		netsessionfunc \{func = showsigninui
			params = {
				convert_offline_to_guest
			}}
	else
		netsessionfunc \{func = showsigninui4pane
			params = {
				online_only
			}}
	endif
	wait_for_blade_complete
	if checkforsignin controller_index = <device_num>
		printf \{qs(0x08ec2e8b)}
	else
		if isxenonorwindx
			if checkforsignin local controller controller_index = <device_num>
				netsessionfunc \{func = showsigninui
					params = {
						convert_offline_to_guest
					}}
			else
				netsessionfunc \{func = showsigninui4pane
					params = {
						online_only
					}}
			endif
			wait_for_blade_complete
		endif
	endif
endscript

script debug_4player_signin 
	if isxenonorwindx
		netsessionfunc \{func = showsigninui4pane}
		wait_for_blade_complete
	endif
endscript

script print_player_net_info 
	printf \{qs(0x75bc108d)}
	i = 1
	begin
	formattext checksumname = gamertag 'gamertag_%i' i = (<i> - 1)
	name = $<gamertag>
	dumpplayerinfo <i>
	getplayerinfo <i> is_local_client
	getplayerinfo <i> net_id_first
	getplayerinfo <i> net_id_second
	getplayerinfo <i> net_obj_id
	getplayerinfo <i> part
	getplayerinfo <i> net_difficulty
	getplayerinfo <i> controller
	getplayerinfo <i> band
	printf qs(0x8eca38c7) d = <is_local_client>
	printf qs(0xa5bccced) d = <net_id_first>
	printf qs(0x084465d1) d = <net_id_second>
	printf qs(0x5b7377e6) g = <name>
	printf qs(0xdd16850f) d = <net_obj_id>
	printf qs(0xb8cf5ed6) d = <band>
	printf <part>
	printf <net_difficulty>
	printf <controller>
	i = (<i> + 1)
	repeat 8
endscript

script sync_host_and_client \{callback = !q1768515945}
	sendstructure callback = generic_net_sync data_to_send = {callback = <callback>}
	generic_net_sync callback = <callback>
endscript
g_motdimagepak1_loaded = 0

script callback_motdimagepak1_loaded 
	change \{g_motdimagepak1_loaded = 1}
endscript

script callback_motdimagepak1_unloaded 
	change \{g_motdimagepak1_loaded = 0}
endscript
g_motdimagepak2_loaded = 0

script callback_motdimagepak2_loaded 
	change \{g_motdimagepak2_loaded = 1}
endscript

script callback_motdimagepak2_unloaded 
	change \{g_motdimagepak2_loaded = 0}
endscript
g_motdimagepak3_loaded = 0

script callback_motdimagepak3_loaded 
	change \{g_motdimagepak3_loaded = 1}
endscript

script callback_motdimagepak3_unloaded 
	change \{g_motdimagepak3_loaded = 0}
endscript

script callback_motd 
	netsessionfunc obj = live_settings func = trace params = {msg = 'callback_motd CALLED!!!' <...>}
	if ($g_motdimagepak1_loaded != 1)
		return
	endif
	if ($g_motdimagepak2_loaded != 1)
		return
	endif
	if ($g_motdimagepak3_loaded != 1)
		return
	endif
	motd_text = ($motd_subject_1)
	change message_of_the_day = ($motd_subject_1)
	if screenelementexists \{id = motdinterface}
		motdinterface :se_setprops \{event_handlers = [
				{
					pad_option
					main_menu_select_motd
				}
			]
			replace_handlers}
	endif
	if screenelementexists \{id = motdinterface}
		if NOT user_control_helper_exists \{button = blue}
			add_user_control_helper \{text = qs(0x3e13521a)
				button = blue
				z = 100
				all_buttons}
		endif
		launchevent \{type = focus
			target = motdinterface}
	endif
endscript

script callback_motd_unloaded 
	netsessionfunc obj = live_settings func = trace params = {msg = 'callback_motd_unloaded CALLED!!!' <...>}
endscript
