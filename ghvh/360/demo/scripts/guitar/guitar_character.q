guitarist_info = {
	anim_set = judy_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_frontend
	finger_anims = guitarist_finger_anims_large
	fret_anims = fret_anims_rocker
	strum = normal
	guitar_model = none
	string_start_properties = default_guitar_string_start_properties
	string_end_properties = default_guitar_string_end_properties
	playing_missed_note = false
	last_strum_length = short
	current_anim = idle
	anim_repeat_count = 1
	arms_disabled = 0
	disable_arms = 0
	cycle_anim = false
	next_stance = stance_frontend
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	target_node = none
	facial_anim = idle
	scale = 1.0
	playing = true
	part = guitar
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
bassist_info = {
	anim_set = axel_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_frontend
	finger_anims = guitarist_finger_anims_large
	fret_anims = fret_anims_rocker
	strum = normal
	bass_model = none
	string_start_properties = default_guitar_string_start_properties
	string_end_properties = default_guitar_string_end_properties
	playing_missed_note = false
	last_strum_length = short
	current_anim = idle
	anim_repeat_count = 1
	arms_disabled = 0
	disable_arms = 0
	cycle_anim = false
	next_stance = stance_frontend
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	target_node = none
	facial_anim = idle
	scale = 1.0
	playing = true
	part = bass
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
vocalist_info = {
	anim_set = vocalist_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_a
	finger_anims = guitarist_finger_anims_large
	fret_anims = fret_anims_rocker
	strum = normal
	guitar_model = none
	string_start_properties = default_guitar_string_start_properties
	string_end_properties = default_guitar_string_end_properties
	playing_missed_note = false
	last_strum_length = short
	current_anim = idle
	anim_repeat_count = 1
	arms_disabled = 0
	disable_arms = 0
	cycle_anim = false
	next_stance = stance_frontend
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	target_node = none
	facial_anim = idle
	scale = 1.0
	playing = true
	part = vocals
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
vocalist2_info = {
	anim_set = vocalist_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_a
	finger_anims = guitarist_finger_anims_large
	fret_anims = fret_anims_rocker
	strum = normal
	guitar_model = none
	string_start_properties = default_guitar_string_start_properties
	string_end_properties = default_guitar_string_end_properties
	playing_missed_note = false
	last_strum_length = short
	current_anim = idle
	anim_repeat_count = 1
	arms_disabled = 0
	disable_arms = 0
	cycle_anim = false
	next_stance = stance_frontend
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	target_node = none
	facial_anim = idle
	scale = 1.0
	playing = true
	part = vocals
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
drummer_info = {
	twist = 0.0
	desired_twist = 0.0
	anim_set = drummer_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_a
	current_anim = idle
	anim_repeat_count = 1
	disable_arms = 0
	arms_disabled = 0
	cycle_anim = false
	next_stance = stance_a
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	playing_missed_note = false
	target_node = none
	facial_anim = idle
	last_left_arm_note = 0
	last_right_arm_note = 0
	scale = 1.0
	playing = true
	part = drum
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
drummer2_info = {
	twist = 0.0
	desired_twist = 0.0
	anim_set = drummer_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_a
	current_anim = idle
	anim_repeat_count = 1
	disable_arms = 0
	arms_disabled = 0
	cycle_anim = false
	next_stance = stance_a
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	playing_missed_note = false
	target_node = none
	facial_anim = idle
	last_left_arm_note = 0
	last_right_arm_note = 0
	scale = 1.0
	playing = true
	part = drum
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
cas_musician1_info = {
	anim_set = judy_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_frontend
	finger_anims = guitarist_finger_anims_large
	fret_anims = fret_anims_rocker
	strum = normal
	guitar_model = none
	string_start_properties = default_guitar_string_start_properties
	string_end_properties = default_guitar_string_end_properties
	playing_missed_note = false
	last_strum_length = short
	current_anim = idle
	anim_repeat_count = 1
	arms_disabled = 0
	disable_arms = 0
	cycle_anim = false
	next_stance = stance_frontend
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	target_node = none
	facial_anim = idle
	scale = 1.0
	playing = true
	part = guitar
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
cas_musician2_info = {
	anim_set = judy_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_frontend
	finger_anims = guitarist_finger_anims_large
	fret_anims = fret_anims_rocker
	strum = normal
	guitar_model = none
	string_start_properties = default_guitar_string_start_properties
	string_end_properties = default_guitar_string_end_properties
	playing_missed_note = false
	last_strum_length = short
	current_anim = idle
	anim_repeat_count = 1
	arms_disabled = 0
	disable_arms = 0
	cycle_anim = false
	next_stance = stance_frontend
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	target_node = none
	facial_anim = idle
	scale = 1.0
	playing = true
	part = guitar
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
cas_musician3_info = {
	anim_set = judy_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_frontend
	finger_anims = guitarist_finger_anims_large
	fret_anims = fret_anims_rocker
	strum = normal
	guitar_model = none
	string_start_properties = default_guitar_string_start_properties
	string_end_properties = default_guitar_string_end_properties
	playing_missed_note = false
	last_strum_length = short
	current_anim = idle
	anim_repeat_count = 1
	arms_disabled = 0
	disable_arms = 0
	cycle_anim = false
	next_stance = stance_frontend
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	target_node = none
	facial_anim = idle
	scale = 1.0
	playing = true
	part = guitar
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
cas_musician4_info = {
	anim_set = judy_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_frontend
	finger_anims = guitarist_finger_anims_large
	fret_anims = fret_anims_rocker
	strum = normal
	guitar_model = none
	string_start_properties = default_guitar_string_start_properties
	string_end_properties = default_guitar_string_end_properties
	playing_missed_note = false
	last_strum_length = short
	current_anim = idle
	anim_repeat_count = 1
	arms_disabled = 0
	disable_arms = 0
	cycle_anim = false
	next_stance = stance_frontend
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	target_node = none
	facial_anim = idle
	scale = 1.0
	playing = true
	part = guitar
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}
animtreepreviewobject_info = {
	anim_set = judy_animations
	facial_anims = none
	facial_anims_default = none
	stance = stance_frontend
	finger_anims = guitarist_finger_anims_large
	fret_anims = fret_anims_rocker
	strum = normal
	guitar_model = none
	string_start_properties = default_guitar_string_start_properties
	string_end_properties = default_guitar_string_end_properties
	playing_missed_note = false
	last_strum_length = short
	current_anim = idle
	anim_repeat_count = 1
	arms_disabled = 0
	disable_arms = 0
	cycle_anim = false
	next_stance = stance_frontend
	next_anim = none
	next_anim_repeat_count = 1
	next_anim_disable_arms = 0
	cycle_next_anim = false
	last_anim_name = none
	waiting_for_cameracut = false
	allow_movement = true
	target_node = none
	facial_anim = idle
	scale = 1.0
	playing = true
	part = guitar
	intro_anim_name = none
	win_anim_name = none
	lose_anim_name = none
	playing_special_anim = false
}

script create_band \{async = 0}
	printf \{channel = animinfo
		qs(0xb66fb5d8)}
	if ($disable_band = 1)
		mpm_load_pak \{pak = highway_axel}
		return \{true}
	endif
	band_clearanimtempo
	band_builder_create_band async = <async> min_time = <min_time>
	set_bandvisible
	killspawnedscript \{name = preparebandforrenderupdateloop}
	spawnscriptnow \{preparebandforrenderupdateloop}
	debug_toggle_band_visiblity
	change \{enable_guitarist_camera_swapping = false}
	if (($game_mode != p2_faceoff) && ($game_mode != p2_pro_faceoff) && ($game_mode != p2_battle))
		if is_guitaronly_song
			if compositeobjectexists \{bassist}
				bassist :hide
			endif
			if compositeobjectexists \{vocalist}
				vocalist :hide
			endif
			if compositeobjectexists \{drummer}
				drummer :hide
			endif
		elseif ($current_song = eruption)
			if compositeobjectexists \{vocalist}
				vocalist :hide
			endif
		endif
	endif
	getglobaltags \{user_options
		attract_mode_fix = 1}
	if gotparam \{airinstruments}
		if (<airinstruments> = 1)
			change \{cheat_airinstruments = 1}
		else
			change \{cheat_airinstruments = 2}
		endif
	endif
	if gotparam \{invisiblecharacters}
		if (<invisiblecharacters> = 1)
			change \{cheat_invisiblecharacters = 1}
		else
			change \{cheat_invisiblecharacters = 2}
		endif
	endif
	bandmanager_airguitarcheat
	bandmanager_invisiblecharacterscheat
	return \{true}
endscript

script create_frontend_musician \{instrument = none}
	requireparams \{[
			profile
			name
			async
		]
		all}
	extendcrc <name> '_Info' out = info_struct
	cleareventhandlergroup \{hand_events}
	if NOT create_band_member name = <name> profile = <profile> instrument = <instrument> async = <async> pos = <pos> dir = <dir>
		return \{false}
	endif
	guitarist_start_anims profile_struct = <profile> name = <name> instrument = guitar
	return \{true}
endscript

script create_guitarist \{name = guitarist
		profile_id = judy
		async = 0}
	extendcrc <name> '_Info' out = info_struct
	printf channel = animinfo qs(0x3372ff6a) a = <name>
	get_musician_profile_struct_by_id id = <profile_id> savegame = <savegame>
	if gotparam \{node_name}
		waypoint_id = <node_name>
	else
		get_start_node_id member = <name>
	endif
	if doeswaypointexist name = <waypoint_id>
		change structurename = <info_struct> target_node = <waypoint_id>
	else
		printf qs(0xa84ca33d) a = <name>
	endif
	cleareventhandlergroup \{hand_events}
	set_guitar_string_properties <...>
	killspawnedscript \{name = preparebandforrenderupdateloop}
	spawnscriptnow \{preparebandforrenderupdateloop}
	if NOT create_band_member name = <name> profile = <profile_struct> start_node = <waypoint_id> instrument = guitar <...>
		return \{false}
	endif
	return \{true}
endscript

script alt_set_guitar_string_props 
	<part> = cas_guitar_bridges
	if structurecontains structure = <new_instrument> <part>
		if structurecontains structure = (<new_instrument>.<part>) desc_id
			if getactualcasoptionstruct part = <part> desc_id = ((<new_instrument>.<part>).desc_id)
				if gotparam \{guitar_string_start}
					printf channel = animinfo qs(0x1fc9f26c) s = <guitar_string_start>
					change structurename = <info_struct> string_start_properties = <guitar_string_start>
				endif
				if gotparam \{guitar_string_end}
					printf channel = animinfo qs(0xda200821) s = <guitar_string_end>
					change structurename = <info_struct> string_end_properties = <guitar_string_end>
				endif
			endif
		endif
	endif
endscript

script set_guitar_string_properties 
	if get_part_key_from_appearance key = guitar_string_start appearance = (<profile_struct>.appearance) part = cas_guitar_bridges
		printf channel = animinfo qs(0xa5e6723d) a = <name>
		change structurename = <info_struct> string_start_properties = <guitar_string_start>
	else
		printf channel = animinfo qs(0x95a4b190) a = <name>
		change structurename = <info_struct> string_start_properties = default_guitar_string_start_properties
	endif
	if get_part_key_from_appearance key = guitar_string_end appearance = (<profile_struct>.appearance) part = cas_guitar_bridges
		printf channel = animinfo qs(0xa4714cd4) a = <name>
		change structurename = <info_struct> string_end_properties = <guitar_string_end>
	else
		printf channel = animinfo qs(0x1f376d79) a = <name>
		change structurename = <info_struct> string_end_properties = default_guitar_string_end_properties
	endif
endscript

script set_bass_string_properties 
	if get_part_key_from_appearance key = bass_string_start appearance = (<profile_struct>.appearance) part = cas_bass_bridges
		printf channel = animinfo qs(0x8b6be807) a = <name>
		change structurename = <info_struct> string_start_properties = <bass_string_start>
	else
		printf channel = animinfo qs(0x0970b810) a = <name>
		change structurename = <info_struct> string_start_properties = default_bass_string_start_properties
	endif
	if get_part_key_from_appearance key = bass_string_end appearance = (<profile_struct>.appearance) part = cas_bass_bridges
		printf channel = animinfo qs(0x26832880) a = <name>
		change structurename = <info_struct> string_end_properties = <bass_string_end>
	else
		printf channel = animinfo qs(0x7e4aa083) a = <name>
		change structurename = <info_struct> string_end_properties = default_bass_string_end_properties
	endif
endscript

script create_bassist \{name = bassist
		profile_id = bassist
		async = 0}
	extendcrc <name> '_Info' out = info_struct
	printf channel = animinfo qs(0x678ae1fa) a = <name> p = <profile_id>
	get_musician_profile_struct_by_id id = <profile_id> savegame = <savegame>
	get_start_node_id member = <name>
	if doeswaypointexist name = <waypoint_id>
		getwaypointpos name = <waypoint_id>
		change structurename = <info_struct> target_node = <waypoint_id>
	else
		printf qs(0xa84ca33d) a = <name>
	endif
	set_bass_string_properties <...>
	killspawnedscript \{name = preparebandforrenderupdateloop}
	spawnscriptnow \{preparebandforrenderupdateloop}
	if NOT create_band_member name = <name> profile = <profile_struct> start_node = <waypoint_id> instrument = bass <...>
		return \{false}
	endif
	return \{true}
endscript

script create_vocalist \{name = vocalist
		profile_id = singer
		async = 0}
	extendcrc <name> '_Info' out = info_struct
	printf qs(0xcc1eca18) a = <name> p = <profile_id>
	get_musician_profile_struct_by_id id = <profile_id> savegame = <savegame>
	get_start_node_id member = <name>
	if doeswaypointexist name = <waypoint_id>
		getwaypointpos name = <waypoint_id>
		change structurename = <info_struct> target_node = <waypoint_id>
	else
		printf qs(0xa84ca33d) a = <name>
	endif
	if NOT create_band_member name = <name> profile = <profile_struct> start_node = <waypoint_id> instrument = vocals <...>
		return \{false}
	endif
	return \{true}
endscript

script create_drummer \{name = drummer
		profile_id = drummer
		async = 0}
	extendcrc <name> '_Info' out = info_struct
	printf qs(0x5a201a40) a = <name> p = <profile_id>
	get_musician_profile_struct_by_id id = <profile_id> savegame = <savegame>
	get_start_node_id member = <name>
	if doeswaypointexist name = <waypoint_id>
		getwaypointpos name = <waypoint_id>
		change structurename = <info_struct> target_node = <waypoint_id>
	else
		printf qs(0xa84ca33d) a = <name>
	endif
	if NOT create_band_member name = <name> profile = <profile_struct> start_node = <waypoint_id> instrument = drum <...>
		return \{false}
	endif
	return \{true}
endscript

script guitarist_start_anims 
	extendcrc <name> '_Info' out = info_struct
	setup_character_anims {
		profile_struct = <profile_struct>
		character_id = <character_id>
		info_struct = <info_struct>
		instrument = <instrument>
		loading_into_song = <loading_into_song>
	}
	stance = ($<info_struct>.stance)
	finger_anims = ($<info_struct>.finger_anims)
	fret_anims = ($<info_struct>.fret_anims)
	strum_type = ($<info_struct>.strum)
	extendcrc <strum_type> '_Strums' out = strum_anims
	if compositeobjectexists name = <name>
		if NOT ($cas_heap_state = in_cas)
			<name> :hero_play_strum_anim anim = ($<strum_anims>.no_strum_anim)
			<name> :hero_play_fret_anim anim = ($<fret_anims>.track_119)
			<name> :hero_play_finger_anim anim = ($<finger_anims>.track_none)
		endif
		bandmanager_addguitarist name = <name> player = 1
		bandmanager_changestance name = <name> stance = <stance> no_wait
		<name> :obj_spawnscriptnow facial_anim_loop
		<name> :obj_forceupdate
	endif
endscript

script bassist_start_anims 
	extendcrc <name> '_Info' out = info_struct
	setup_character_anims {
		profile_struct = <profile_struct>
		character_id = <character_id>
		info_struct = <info_struct>
		instrument = <instrument>
		loading_into_song = <loading_into_song>
	}
	finger_anims = ($<info_struct>.finger_anims)
	fret_anims = ($<info_struct>.fret_anims)
	strum_type = ($<info_struct>.strum)
	extendcrc <strum_type> '_Strums' out = strum_anims
	if compositeobjectexists name = <name>
		<name> :hero_play_strum_anim anim = ($<strum_anims>.no_strum_anim)
		<name> :hero_play_fret_anim anim = ($<fret_anims>.track_96)
		<name> :hero_play_finger_anim anim = ($<finger_anims>.track_none)
		bandmanager_addbassist name = <name>
		<name> :obj_spawnscriptnow facial_anim_loop
		<name> :obj_forceupdate
	endif
endscript

script vocalist_start_anims 
	extendcrc <name> '_Info' out = info_struct
	setup_character_anims {
		profile_struct = <profile_struct>
		character_id = <character_id>
		info_struct = <info_struct>
		instrument = <instrument>
		loading_into_song = <loading_into_song>
	}
	if compositeobjectexists name = <name>
		bandmanager_addvocalist name = <name>
		<name> :obj_spawnscriptnow facial_anim_loop
		<name> :ragdoll_markforreset
	endif
endscript
use_drummer_events = 0

script drummer_start_anims 
	extendcrc <name> '_Info' out = info_struct
	setup_character_anims {
		profile_struct = <profile_struct>
		character_id = <character_id>
		info_struct = <info_struct>
		instrument = <instrument>
		loading_into_song = <loading_into_song>
	}
	if NOT compositeobjectexists name = <name>
		return
	endif
	<name> :anim_command target = moment_blend command = partialswitch_setstate params = {off blendduration = 0.0}
	if ($use_drummer_events = 1)
		<name> :obj_switchscript bandmember_idle
	else
		<name> :obj_spawnscriptnow initial_drummer_anim
	endif
	<name> :obj_spawnscriptnow facial_anim_loop
	change \{structurename = drummer_info
		last_left_arm_note = 0}
	change \{structurename = drummer_info
		last_right_arm_note = 0}
	bandmanager_adddrummer name = <name>
	<name> :ragdoll_markforreset
endscript

script initial_drummer_anim 
	if ($current_song = jamsession)
		anim = drum_andy_standardlp_hs_100_01
	elseif is_current_band_vanhalen
		anim = drum_lars_standardlp_notempo
	else
		anim = drum_andy_standardlp_notempo
	endif
	if NOT anim_animexists anim = <anim>
		anim = drum_andy_standardlp_notempo
	endif
	hero_play_anim {anim = <anim> cycle}
endscript

script hero_play_random_anim \{blendduration = 0.2}
	getarraysize <anims>
	getrandomvalue name = newindex integer a = 0 b = (<array_size> - 1)
	anim_name = (<anims> [<newindex>])
	if gotparam \{cycle}
		hero_play_anim anim = <anim_name> blendduration = <blendduration> cycle
	else
		hero_play_anim anim = <anim_name> blendduration = <blendduration>
	endif
endscript

script should_display_debug_info 
	obj_getid
	display_info = false
	switch (<objid>)
		case guitarist
		if ($display_guitarist_anim_info = true)
			display_info = true
		endif
		case bassist
		if ($display_bassist_anim_info = true)
			display_info = true
		endif
		case vocalist
		if ($display_vocalist_anim_info = true)
			display_info = true
		endif
		case drummer
		if ($display_drummer_anim_info = true)
			display_info = true
		endif
	endswitch
	return <display_info>
endscript

script hero_play_random_anims 
	count = 0
	begin
	hero_play_random_anim anims = <anim_array>
	hero_wait_until_anim_finished
	count = (<count> + 1)
	if gotparam \{repeat_count}
		if (<count> = <repeat_count>)
			break
		endif
	endif
	repeat
endscript

script hero_play_adjusting_random_anims \{blend_time = 0.2
		random_start_time = false}
	obj_getid
	extendcrc <objid> '_Info' out = info_struct
	count = 0
	begin
	anim = ($<info_struct>.current_anim)
	cycle = ($<info_struct>.cycle_anim)
	repeat_count = ($<info_struct>.anim_repeat_count)
	if (<objid> = guitarist || <objid> = bassist)
		if (($<info_struct>.disable_arms) = 2)
			if ($<info_struct>.arms_disabled != 2)
				printf channel = animinfo qs(0x6c19ede3) a = ($<info_struct>.arms_disabled)
				hero_toggle_arms num_arms = 0 prev_num_arms = (2 - ($<info_struct>.arms_disabled))
				change structurename = <info_struct> arms_disabled = 2
			endif
		elseif (($<info_struct>.disable_arms) = 1)
			if ($<info_struct>.arms_disabled != 1)
				hero_toggle_arms num_arms = 1 prev_num_arms = (2 - ($<info_struct>.arms_disabled))
				change structurename = <info_struct> arms_disabled = 1
			endif
		else
			if ($<info_struct>.arms_disabled != 0)
				hero_toggle_arms num_arms = 2 prev_num_arms = (2 - ($<info_struct>.arms_disabled))
				change structurename = <info_struct> arms_disabled = 0
			endif
		endif
	endif
	if (<objid> = guitarist)
		if NOT (<anim> = idle)
			change structurename = <info_struct> facial_anim = <anim>
		endif
	endif
	if hero_play_tempo_anim_cfunc anim = <anim> blendduration = <blend_time>
		start = 0.0
		if anim_animexists anim = <anim_to_run>
			anim_getanimlength anim = <anim_to_run>
			if (<random_start_time> = true)
				getrandomvalue a = 0.0 b = <length> name = start
				printf channel = clip qs(0xaccc0146) a = <objid> b = <start> c = <length>
			endif
		else
			printf channel = animinfo qs(0xe32a6fe1) a = <anim_to_run>
		endif
		random_start_time = false
		hero_play_anim anim = <anim_to_run> blendduration = <blend_time> usemotionextraction = <use_motion_extraction> start = <start>
		hero_wait_until_anim_finished
		blend_time = 0.2
	else
		wait \{1
			gameframe}
	endif
	display_debug_info = false
	if (should_display_debug_info)
		display_debug_info = true
	endif
	anim_set = ($<info_struct>.anim_set)
	stance = ($<info_struct>.stance)
	next_stance = ($<info_struct>.next_stance)
	stance_changed = false
	if NOT (<next_stance> = <stance>)
		if (<display_debug_info> = true)
			printf channel = animinfo qs(0x6ad5be49) c = <objid> a = <stance> b = <next_stance>
		endif
		if play_stance_transition_cfunc anim_set = <anim_set> old_stance = <stance> new_stance = <next_stance>
			hero_play_anim anim = <anim_to_run>
			hero_wait_until_anim_finished
		endif
		change structurename = <info_struct> stance = <next_stance>
		stance = <next_stance>
		stance_changed = true
	endif
	next_anim = ($<info_struct>.next_anim)
	if (<next_anim> = none && <stance_changed> = false)
		if (<cycle> = false)
			repeat_count = (<repeat_count> - 1)
			if (<repeat_count> < 1)
				if (<display_debug_info> = true)
					printf channel = animinfo qs(0x89bd16bc) a = <objid> b = <anim>
				endif
				repeat_count = 0
			endif
		endif
		change structurename = <info_struct> anim_repeat_count = <repeat_count>
		if (<cycle> = false && <repeat_count> <= 0)
			change structurename = <info_struct> current_anim = idle
			change structurename = <info_struct> cycle_anim = true
			if (<next_stance> = intro || <next_stance> = intro_smstg || <next_stance> = stance_frontend || <next_stance> = stance_frontend_guitar)
			else
				change structurename = <info_struct> disable_arms = 0
			endif
			blend_time = 0.2
			if (<display_debug_info> = true)
				printf channel = animinfo qs(0x26553816) a = <objid>
			endif
		else
			blend_time = 0.2
			if (<display_debug_info> = true)
				if (<cycle> = false)
					printf channel = animinfo qs(0x7bc6a2eb) c = <anim> a = <objid> b = <repeat_count>
				else
					printf channel = animinfo qs(0x71a75032) a = <objid> b = <anim>
				endif
			endif
		endif
	else
		repeat_count = ($<info_struct>.next_anim_repeat_count)
		if ((<display_debug_info> = true) && (<next_anim> != none))
			if (<repeat_count> > 1)
				printf channel = animinfo qs(0x34368870) a = <objid> b = <next_anim> c = <repeat_count>
			else
			endif
		endif
		if (<next_anim> = none)
			if (<display_debug_info> = true)
				printf channel = animinfo qs(0x26553816) a = <objid>
			endif
			next_anim = idle
			cycle_next_anim = true
		else
			cycle_next_anim = ($<info_struct>.cycle_next_anim)
		endif
		if (<next_stance> = intro || <next_stance> = intro_smstg || <next_stance> = stance_frontend || <next_stance> = stance_frontend_guitar)
			disable_arms_next_anim = 2
		else
			disable_arms_next_anim = ($<info_struct>.next_anim_disable_arms)
		endif
		change structurename = <info_struct> stance = <next_stance>
		change structurename = <info_struct> current_anim = <next_anim>
		change structurename = <info_struct> cycle_anim = <cycle_next_anim>
		change structurename = <info_struct> disable_arms = <disable_arms_next_anim>
		change structurename = <info_struct> next_anim = none
		change structurename = <info_struct> cycle_next_anim = true
		change structurename = <info_struct> anim_repeat_count = <repeat_count>
		change structurename = <info_struct> next_anim_disable_arms = 0
		blend_time = 0.2
	endif
	repeat
endscript

script crowd_play_adjusting_random_anims \{anim = idle
		blend_time = 0.2
		startwithnoblend = 0}
	obj_getid
	old_speed = undefined
	previous_anim_name = no_anim
	begin
	hero_get_skill_level_cfunc
	get_anim_speed_for_tempo_cfunc
	if gotparam \{anim_set}
		anims = ($<anim_set>.<anim>.<skill>.<anim_speed>)
	else
		anims = ($crowd_animations.<anim>.<skill>.<anim_speed>)
	endif
	getarraysize <anims>
	if (<array_size> = 0)
		printstruct 'Warning! missing crowd anim!' <...>
		wait \{10
			seconds}
	else
		getrandomvalue name = newindex integer a = 0 b = (<array_size> - 1)
		anim_name = (<anims> [<newindex>])
		if (<startwithnoblend> = 1)
			blend_time = 0.0
			startwithnoblend = 0
		elseif (<anim_speed> != <old_speed>)
			blend_time = $crowd_blendtime_tempochange
		elseif (<skill> = bad)
			blend_time = $crowd_blendtime_bad
		elseif (<anim> = special)
			blend_time = $crowd_blendtime_special
		elseif (<anim_speed> = slow)
			blend_time = $crowd_blendtime_slow
		elseif (<anim_speed> = med)
			blend_time = $crowd_blendtime_med
		elseif (<anim_speed> = fast)
			blend_time = $crowd_blendtime_fast
		else
			blend_time = -1.0
		endif
		if ($display_crowd_anim_info = true)
			printf channel = crowd qs(0x0a0eb2da) a = <objid> b = <anim> c = <anim_name> d = <blend_time>
		endif
		if NOT (<anim_name> = <previous_anim_name>)
			gameobj_playanim anim = <anim_name> blendduration = <blend_time> timertype = tempocycle animevents = on
			previous_anim_name = <anim_name>
		else
			anim_command \{target = bodytimer
				command = timer_resetanimcompleteflag}
		endif
		gameobj_waitanimfinished
		old_speed = <anim_speed>
	endif
	repeat
endscript

script hero_strum_guitar \{note_length = 150}
	if (<note_length> < $short_strum_max_gem_length)
		anim_length = short
	elseif (<note_length> < $med_strum_max_gem_length)
		anim_length = med
	else
		anim_length = long
	endif
	obj_getid
	extendcrc <objid> '_Info' out = info_struct
	change structurename = <info_struct> last_strum_length = <anim_length>
	strum_type = ($<info_struct>.strum)
	extendcrc <strum_type> '_Strums' out = strum_anims
	if (($<info_struct>.playing_missed_note = false) || ($always_strum = true))
		getarraysize ($<strum_anims>.<anim_length>)
		getrandomvalue name = newindex integer a = 0 b = (<array_size> - 1)
		strum_anim = ($<strum_anims>.<anim_length> [<newindex>])
		hero_play_strum_anim anim = <strum_anim> blendduration = 0.1
	endif
	hero_wait_until_anim_finished \{timer = strumtimer}
	hero_play_strum_anim anim = (($<strum_anims>).no_strum_anim)
endscript

script hero_play_chord \{chord = track_none}
	obj_getid
	extendcrc <objid> '_Info' out = info_struct
	finger_anims = ($<info_struct>.finger_anims)
	if NOT globalexists name = <finger_anims> type = structure
		return
	endif
	if structurecontains structure = $<finger_anims> name = <chord>
		finger_anim = ($<finger_anims>.<chord>)
		if (<chord> = none)
			blend_time = $finger_release_blend_time
		else
			blend_time = $finger_press_blend_time
		endif
	else
		finger_anim = ($<finger_anims>.none)
		blend_time = $finger_release_blend_time
	endif
	if (<finger_anim> != none)
		hero_play_finger_anim anim = <finger_anim> blendduration = <blend_time>
	endif
endscript

script setup_character_anims 
	if NOT gotparam \{profile_struct}
		scriptassert \{'problem here..., no profile struct'}
	endif
	if NOT get_body_key_from_appearance key = anim_struct appearance = (<profile_struct>.appearance)
		scriptassert \{'anim_struct missing from appearance'}
	endif
	printf 'setup_character_anims : %s' s = <instrument>
	if get_anim_struct_member anim_struct = <anim_struct> loading_into_song = <loading_into_song> member = <instrument>
		if NOT gotparam \{loading_into_song}
			get_anim_struct_member anim_struct = <anim_struct> member = frontend
			if NOT structurecontains structure = <anim_struct_member> finger_anims
				use_default_finger_fret_strum = 1
			endif
		endif
		if structurecontains structure = <anim_struct_member> anim_set
			printf 'Using anim_set : %s' s = (<anim_struct_member>.anim_set) donotresolve
			change structurename = <info_struct> anim_set = (<anim_struct_member>.anim_set)
			if ((<instrument> = guitar) || (<instrument> = bass) || (<instrument> = rhythm))
				change structurename = <info_struct> part = <instrument>
				if gotparam \{use_default_finger_fret_strum}
					change structurename = <info_struct> finger_anims = guitarist_finger_anims_car_female
					change structurename = <info_struct> fret_anims = fret_anims_rocker
					change structurename = <info_struct> strum = car_female_normal
				else
					if is_current_band_vanhalen
						change structurename = <info_struct> finger_anims = guitarist_finger_anims_vh
					else
						change structurename = <info_struct> finger_anims = (<anim_struct_member>.finger_anims)
					endif
					change structurename = <info_struct> fret_anims = (<anim_struct_member>.fret_anims)
					change structurename = <info_struct> strum = (<anim_struct_member>.strum_anims)
				endif
			endif
		else
			printf 'Anim_set not found for %s' s = (<profile_struct>.name)
			change structurename = <info_struct> anim_set = car_female_animations
		endif
		if structurecontains structure = <anim_struct_member> facial_anims
			printf channel = animinfo qs(0x01e34256) s = (<profile_struct>.name)
			change structurename = <info_struct> facial_anims = (<anim_struct_member>.facial_anims)
			change structurename = <info_struct> facial_anims_default = (<anim_struct_member>.facial_anims)
		else
			printf channel = animinfo qs(0x578cc9b0) s = (<profile_struct>.name)
			change structurename = <info_struct> facial_anims = none
			change structurename = <info_struct> facial_anims_default = none
			printstruct <anim_struct_member>
		endif
	endif
	change structurename = <info_struct> allow_movement = true
	change structurename = <info_struct> arms_disabled = 0
	change structurename = <info_struct> disable_arms = 0
	change structurename = <info_struct> playing_special_anim = false
	if gotparam \{stance}
		change structurename = <info_struct> stance = <stance>
	endif
	change structurename = <info_struct> next_stance = ($<info_struct>.stance)
endscript

script get_waypoint_id \{index = 0}
	getpakmancurrent \{map = zones}
	getpakmancurrentname \{map = zones}
	if (<index> < 10)
		formattext textname = suffix '_TRG_Waypoint_0%a' a = <index>
	else
		formattext textname = suffix '_TRG_Waypoint_%a' a = <index>
	endif
	waypoint_name = (<pakname> + <suffix>)
	appendsuffixtochecksum base = <pak> suffixstring = <suffix>
	return waypoint_id = <appended_id> waypoint_name = <waypoint_name>
endscript

script get_start_node_id \{character = qs(0x5c2c7d0c)}
	getstartnodeid member = <member>
	return waypoint_id = <waypoint_id> waypoint_name = <waypoint_name>
endscript

script get_skill_level 
	health = ($player1_status.current_health)
	skill = normal
	if (<health> < 0.66)
		skill = bad
	elseif (<health> > 1.3299999)
		skill = good
	endif
	return skill = <skill>
endscript

script get_target_node 
	obj_getid
	extendcrc <objid> '_Info' out = info_struct
	return target_node = ($<info_struct>.target_node)
endscript

script frontend_anim_paks_are_loaded 
	if mpm_find_existing_loaded_pak \{pak = frontend_perm_anims}
		if mpm_find_existing_loaded_pak \{pak = frontend_anims_guit1}
			if mpm_find_existing_loaded_pak \{pak = frontend_anims_guit2}
				if mpm_find_existing_loaded_pak \{pak = frontend_anims_sing}
					if mpm_find_existing_loaded_pak \{pak = frontend_anims_drum}
						return \{true}
					endif
				endif
			endif
		endif
	endif
	return \{false}
endscript

script load_frontend_anim_paks 
	if frontend_anim_paks_are_loaded
		return
	endif
	guitar_force_unload_anim_paks
	unload_songqpak
	mpm_load_pak pak = frontend_perm_anims async = <async>
	mpm_load_pak pak = frontend_anims_guit1 async = <async>
	mpm_load_pak pak = frontend_anims_guit2 async = <async>
	mpm_load_pak pak = frontend_anims_sing async = <async>
	mpm_load_pak pak = frontend_anims_drum async = <async>
	mpm_unload_pak pak = frontend_perm_anims async = <async> already_unloaded_is_okay
	mpm_unload_pak pak = frontend_anims_guit1 async = <async> already_unloaded_is_okay
	mpm_unload_pak pak = frontend_anims_guit2 async = <async> already_unloaded_is_okay
	mpm_unload_pak pak = frontend_anims_sing async = <async> already_unloaded_is_okay
	mpm_unload_pak pak = frontend_anims_drum async = <async> already_unloaded_is_okay
endscript
bandmember_idle_eventtable = [
	{
		response = call_script
		event = play_anim
		scr = handle_play_anim
	}
	{
		response = call_script
		event = change_stance
		scr = handle_change_stance
	}
]

script bandmember_idle \{blend_time = 0.2
		random_start_time = false}
	reseteventhandlersfromtable \{bandmember_idle_eventtable
		group = hand_events}
	obj_killspawnedscript \{name = hero_play_adjusting_random_anims}
	obj_spawnscriptnow hero_play_adjusting_random_anims params = {anim = idle blend_time = <blend_time> random_start_time = <random_start_time>}
	block
endscript

script play_special_facial_anim \{blendduration = 0.0}
	if NOT gotparam \{anim}
		return
	endif
	obj_killspawnedscript \{name = facial_anim_loop}
	obj_getid
	if (<objid> = guitarist)
		printf \{channel = animinfo
			qs(0x95f334b8)}
	endif
	hero_play_facial_anim anim = <anim> blendduration = <blendduration>
	hero_wait_until_anim_finished \{timer = facialtimer}
	if (<objid> = guitarist)
		printf \{channel = animinfo
			qs(0x07754075)}
	endif
	obj_spawnscriptnow facial_anim_loop params = {blend_duration = <blendduration>}
endscript

script facial_anim_loop \{blend_duration = 0}
	obj_getid
	extendcrc <objid> '_Info' out = info_struct
	facial_anims = ($<info_struct>.facial_anims)
	if (<facial_anims> = none)
		printf channel = animinfo qs(0x86d9843c) a = <objid>
		return
	endif
	if NOT globalexists name = <facial_anims> type = structure
		printf \{qs(0x989b10a0)}
		return
	endif
	if NOT structurecontains structure = $<facial_anims> name = idle
		return
	endif
	begin
	anim = ($<info_struct>.facial_anim)
	if NOT structurecontains structure = $<facial_anims> name = <anim>
		if ($display_facial_anim_info = true)
			printf channel = animinfo qs(0x88ae47d6) a = <anim>
		endif
		anim = idle
	endif
	anims = ($<facial_anims>.<anim>)
	getarraysize <anims>
	getrandomvalue name = index integer a = 0 b = (<array_size> - 1)
	anim_name = (<anims> [<index>])
	if ($display_facial_anim_info = true)
		printf channel = animinfo qs(0xab9f8ab8) a = <anim> b = <anim_name> c = <objid>
	endif
	change structurename = <info_struct> facial_anim = idle
	hero_play_facial_anim anim = <anim_name> blendduration = <blend_duration>
	blend_duration = 0
	hero_wait_until_anim_finished \{timer = facialtimer}
	wait \{1
		gameframe}
	repeat
endscript
guitarist_idle_eventtable = [
	{
		response = call_script
		event = strum_guitar
		scr = handle_strum_event
	}
	{
		response = call_script
		event = pose_fret
		scr = handle_fret_event
	}
	{
		response = call_script
		event = pose_fingers
		scr = handle_finger_event
	}
	{
		response = call_script
		event = anim_missednote
		scr = handle_missed_note
	}
	{
		response = call_script
		event = anim_hitnote
		scr = handle_hit_note
	}
	{
		response = call_script
		event = play_anim
		scr = handle_play_anim
	}
	{
		response = call_script
		event = play_battle_anim
		scr = handle_play_anim
	}
	{
		response = call_script
		event = change_stance
		scr = handle_change_stance
	}
]

script guitarist_idle \{blend_time = 0.2
		random_start_time = false}
	reseteventhandlersfromtable \{guitarist_idle_eventtable
		group = hand_events}
	obj_getid
	if (($player1_status.band_member) = <objid>)
		seteventhandler \{response = call_script
			event = star_power_onp1
			scr = handle_star_power
			group = hand_events}
	else (($player2_status.band_member) = <objid>)
		seteventhandler \{response = call_script
			event = star_power_onp2
			scr = handle_star_power
			group = hand_events}
	endif
	obj_killspawnedscript \{name = hero_play_adjusting_random_anims}
	obj_spawnscriptnow hero_play_adjusting_random_anims params = {anim = idle blend_time = <blend_time> random_start_time = <random_start_time> cycle}
	block
endscript

script guitarist_idle_animpreview 
	cleareventhandlergroup \{hand_events}
endscript
guitarist_walking_eventtable = [
	{
		response = call_script
		event = strum_guitar
		scr = handle_strum_event
	}
	{
		response = call_script
		event = pose_fret
		scr = handle_fret_event
	}
	{
		response = call_script
		event = pose_fingers
		scr = handle_finger_event
	}
	{
		response = call_script
		event = anim_missednote
		scr = handle_missed_note
	}
	{
		response = call_script
		event = anim_hitnote
		scr = handle_hit_note
	}
	{
		response = call_script
		event = change_stance
		scr = queue_change_stance
	}
]

script guitarist_walking 
	reseteventhandlersfromtable \{guitarist_walking_eventtable
		group = hand_events}
	obj_killspawnedscript \{name = hero_play_adjusting_random_anims}
	spawnscriptnow \{start_walk_camera}
	walk_to_waypoint <...>
	spawnscriptnow \{kill_walk_camera}
	obj_switchscript \{guitarist_idle}
endscript

script play_special_anim \{stance = stance_a
		disable_arms = 2
		blendduration = 0.2}
	obj_getid
	extendcrc <objid> '_Info' out = info_struct
	cleareventhandlergroup \{hand_events}
	if gotparam \{respond_to_hand_events}
		reseteventhandlersfromtable \{guitarist_walking_eventtable
			group = hand_events}
	else
		seteventhandler \{response = call_script
			event = change_stance
			scr = queue_change_stance
			group = hand_events}
	endif
	obj_killspawnedscript \{name = hero_play_adjusting_random_anims}
	if gotparam \{wait}
		hero_wait_until_anim_finished
	endif
	if (<disable_arms> = 0)
		if (<info_struct>.arms_disabled = 2)
			hero_toggle_arms \{prev_num_arms = 0
				num_arms = 2}
			change structurename = <info_struct> arms_disabled = 0
			change structurename = <info_struct> disable_arms = 0
			change structurename = <info_struct> next_anim_disable_arms = 0
			change structurename = <info_struct> current_anim = idle
			change structurename = <info_struct> cycle_anim = idle
			change structurename = <info_struct> next_anim = idle
			change structurename = <info_struct> cycle_next_anim = true
		endif
	endif
	if (<disable_arms> = 2)
		if (<objid> = guitarist || <objid> = bassist || <objid> = drummer)
			hero_disable_arms \{blend_time = 0.0}
		endif
	endif
	change structurename = <info_struct> stance = <stance>
	if hero_play_tempo_anim_cfunc anim = <anim> blendduration = <blendduration>
		hero_play_anim anim = <anim_to_run> blendduration = <blend_duration> usemotionextraction = <use_motion_extraction>
	endif
	if (<stance> = win || <stance> = win_smstg || <stance> = lose || <stance> = lose_smstg || <anim> = starpower)
		ragdoll_markforreset
	endif
	if (<objid> = guitarist || <objid> = bassist)
		if (<disable_arms> = 2)
			hero_wait_until_anim_near_end \{time_from_end = 0.25}
			hero_enable_arms \{blend_time = 0.25}
		endif
	endif
	hero_wait_until_anim_finished
	change structurename = <info_struct> stance = stance_a
	if (<objid> = guitarist || <objid> = bassist)
		obj_switchscript \{guitarist_idle}
	else
		obj_switchscript \{bandmember_idle}
	endif
endscript

script play_simple_anim \{disable_arms = 2
		blendduration = 0.0
		blendoutduration = 0.2
		start = 0.0
		end = 0.0}
	obj_getid
	extendcrc <objid> '_Info' out = info_struct
	cleareventhandlergroup \{hand_events}
	obj_killspawnedscript \{name = hero_play_adjusting_random_anims}
	if (<disable_arms> = 2)
		if (<objid> = guitarist || <objid> = bassist)
			hero_disable_arms blend_time = <blendduration>
		endif
	endif
	hero_play_anim {anim = <anim> blendduration = <blendduration> start = <start> end = <end> tempomatching = <tempomatching>}
	if (blendduration = 0.0)
		ragdoll_markforreset
	endif
	if (<objid> = guitarist || <objid> = bassist)
		hero_wait_until_anim_near_end \{time_from_end = 0.25}
		hero_enable_arms \{blend_time = 0.25}
	endif
	hero_wait_until_anim_finished
	handle_change_stance \{stance = stance_a
		no_wait}
	if ($display_clip_info = true)
		clip_get_time_and_frame
		printf channel = clip qs(0x01edf488) a = <objid> b = <time_string>
	endif
	band_movetostartnode name = <objid>
	extendcrc <objid> '_Info' out = info_struct
	change structurename = <info_struct> playing_special_anim = false
	if (<objid> = guitarist || <objid> = bassist)
		obj_switchscript guitarist_idle params = {blend_time = <blendoutduration> random_start_time = true}
	else
		obj_switchscript bandmember_idle params = {blend_time = <blendoutduration> random_start_time = true}
	endif
endscript

script handle_star_power 
	return
	obj_getid
	extendcrc <objid> '_Info' out = info_struct
	if NOT (<objid> = guitarist || <objid> = bassist)
		return
	endif
	change structurename = <info_struct> waiting_for_cameracut = true
	begin
	if ($<info_struct>.waiting_for_cameracut = false)
		break
	endif
	wait \{1
		gameframe}
	repeat
	obj_switchscript \{play_special_anim
		params = {
			stance = stance_a
			anim = starpower
			blendduration = 0.0
			disable_arms = 0
			respond_to_hand_events = 1
		}}
endscript
band_character_names = [
	guitarist
	bassist
	vocalist
	drummer
	drummer2
	guitarist2
	bassist2
]
playing_win_lose_anims = false

script wait_done_playing_win_lose_anim 
	wait \{10
		seconds}
	set_playing_win_lose_anims \{isplaying = false}
endscript

script set_playing_win_lose_anims \{isplaying = false}
	change playing_win_lose_anims = <isplaying>
	printf channel = animinfo qs(0x21da345a) s = <isplaying>
endscript

script play_intro_anims 
	set_playing_win_lose_anims \{isplaying = false}
	band_restartidles
	printf \{channel = pop
		qs(0xcebd4098)}
	printf \{channel = animinfo
		qs(0xa8952581)}
	bandmanager_turnoffallarmanims
	foreachin \{$band_character_names
		do = play_intro_anims_foreach}
	wait \{1
		gameframe}
	bandmanager_setplayingintroanims
endscript

script play_intro_anims_foreach 
	if compositeobjectexists name = <checksum>
		if NOT bandmanager_isplayingsimpleanim name = <checksum>
			extendcrc <checksum> '_Info' out = info_struct
			intro_anim = ($<info_struct>.intro_anim_name)
			if (<intro_anim> != none)
				band_playsimpleanim {name = <checksum> anim = <intro_anim> blendduration = 0.3}
				bandmanager_changeik name = <checksum> enabled = false
				bandmanager_stopfacialanims name = <checksum>
				stop_loop_cameras name = <checksum>
			endif
		endif
	endif
endscript

script play_win_anims 
	printf \{channel = band
		qs(0xd0b94ba9)}
	printf \{channel = animinfo
		qs(0x4b8358e5)}
	killspawnedscript \{name = return_characters_to_idle_at_song_time}
	bandmanager_turnoffallarmanims
	set_playing_win_lose_anims \{isplaying = true}
	spawnscript \{wait_done_playing_win_lose_anim}
	if NOT ($game_mode = p2_faceoff || $game_mode = p2_pro_faceoff || $game_mode = p2_battle || $boss_battle = 1)
		foreachin \{$band_character_names
			do = play_win_anims_foreach}
		return
	endif
	if ($boss_battle = 1)
		play_win_anims_foreach \{checksum = guitarist}
		play_lose_anims_foreach \{checksum = bassist}
		play_win_anims_foreach \{checksum = vocalist}
		play_win_anims_foreach \{checksum = drummer}
	else
		p1_won = true
		if ($game_mode = p2_battle)
			if (($player2_status.current_health) > ($player1_status.current_health))
				p1_won = false
			endif
		else
			if (($player2_status.score) > ($player1_status.score))
				p1_won = false
			endif
		endif
		p1_character = ($player1_status.band_member)
		p2_character = ($player2_status.band_member)
		if (<p1_won> = true)
			play_win_anims_foreach checksum = <p1_character>
			play_lose_anims_foreach checksum = <p2_character>
		else
			play_lose_anims_foreach checksum = <p1_character>
			play_win_anims_foreach checksum = <p2_character>
		endif
		if NOT (<p1_character> = vocalist || <p1_character> = vocalist2)
		endif
		if NOT (<p1_character> = drummer || <p1_character> = drummer2)
			play_win_anims_foreach \{checksum = drummer}
		else
			<p1_character> :anim_command target = faceoff_blend command = partialswitch_setstate params = {off blendduration = 0.1}
		endif
		if (<p2_character> = drummer || <p2_character> = drummer2)
			<p2_character> :anim_command target = faceoff_blend command = partialswitch_setstate params = {off blendduration = 0.1}
		endif
	endif
endscript

script play_win_anims_foreach 
	if gotparam \{checksum}
		if compositeobjectexists name = <checksum>
			extendcrc <checksum> '_Info' out = info_struct
			band_movetostartnode name = <checksum> allow_in_2player = true
			band_changefacialanims name = <checksum>
			win_anim = ($<info_struct>.win_anim_name)
			if (<win_anim> != none)
				bandmanager_changeik name = <checksum> enabled = false
				band_playsimpleanim {name = <checksum> anim = <win_anim> blendduration = 0.3}
				printf channel = animinfo 'Playing win anim %a on %b' a = <win_anim> b = <checksum> donotresolve
			else
				printf channel = animinfo qs(0x553d6959) a = <checksum>
			endif
		else
		endif
	endif
endscript

script play_lose_anims 
	printf \{channel = band
		qs(0xfd1cde30)}
	printf \{channel = animinfo
		qs(0x0bf8dcb9)}
	band_showmic_stand \{name = vocalist}
	killspawnedscript \{name = return_characters_to_idle_at_song_time}
	bandmanager_turnoffallarmanims
	set_playing_win_lose_anims \{isplaying = true}
	spawnscript \{wait_done_playing_win_lose_anim}
	if NOT ($game_mode = p2_faceoff || $game_mode = p2_pro_faceoff || $game_mode = p2_battle || $boss_battle = 1)
		foreachin \{$band_character_names
			do = play_lose_anims_foreach}
		return
	endif
	if ($boss_battle = 1)
		play_lose_anims_foreach \{checksum = guitarist}
		play_win_anims_foreach \{checksum = bassist}
		play_lose_anims_foreach \{checksum = vocalist}
		play_lose_anims_foreach \{checksum = drummer}
	else
		printf \{channel = animinfo
			qs(0x3411a4ef)}
		p1_won = true
		if ($game_mode = p2_battle)
			if (($player2_status.current_health) > ($player1_status.current_health))
				p1_won = false
			endif
		else
			if (($player2_status.score) > ($player1_status.score))
				p1_won = false
			endif
		endif
		p1_character = ($player1_status.band_member)
		p2_character = ($player2_status.band_member)
		if (<p1_won> = true)
			play_win_anims_foreach checksum = <p1_character>
			play_lose_anims_foreach checksum = <p2_character>
		else
			play_win_anims_foreach checksum = <p2_character>
			play_lose_anims_foreach checksum = <p1_character>
		endif
		if NOT (<p1_character> = vocalist || <p1_character> = vocalist2)
		endif
		if NOT (<p1_character> = drummer || <p1_character> = drummer2)
		else
			<p1_character> :anim_command target = faceoff_blend command = partialswitch_setstate params = {off blendduration = 0.1}
		endif
		if (<p2_character> = drummer || <p2_character> = drummer2)
			<p2_character> :anim_command target = faceoff_blend command = partialswitch_setstate params = {off blendduration = 0.1}
		endif
	endif
endscript

script play_lose_anims_foreach 
	if gotparam \{checksum}
		if compositeobjectexists name = <checksum>
			extendcrc <checksum> '_Info' out = info_struct
			band_movetostartnode name = <checksum> allow_in_2player = true
			band_changefacialanims name = <checksum>
			lose_anim = ($<info_struct>.lose_anim_name)
			if (<lose_anim> != none)
				bandmanager_changeik name = <checksum> enabled = false
				band_playsimpleanim {name = <checksum> anim = <lose_anim> blendduration = 0.3}
				printf channel = animinfo 'Playing lose anim %a on %b' a = <lose_anim> b = <checksum> donotresolve
			else
				printf channel = animinfo qs(0x283913b7) a = <checksum>
			endif
		endif
	endif
endscript

script restore_idle_faces 
	if compositeobjectexists \{name = guitarist}
		guitarist :obj_killspawnedscript \{name = facial_anim_loop}
		guitarist :obj_spawnscriptnow \{facial_anim_loop}
	endif
	if compositeobjectexists \{name = bassist}
		bassist :obj_killspawnedscript \{name = facial_anim_loop}
		bassist :obj_spawnscriptnow \{facial_anim_loop}
	endif
	if compositeobjectexists \{name = vocalist}
		vocalist :obj_killspawnedscript \{name = facial_anim_loop}
		vocalist :obj_spawnscriptnow \{facial_anim_loop}
	endif
	if compositeobjectexists \{name = drummer}
		drummer :obj_killspawnedscript \{name = facial_anim_loop}
		drummer :obj_spawnscriptnow \{facial_anim_loop}
	endif
endscript

script hide_band 
	if compositeobjectexists \{guitarist}
		guitarist :hide
	endif
	if compositeobjectexists \{guitarist2}
		guitarist :hide
	endif
	if compositeobjectexists \{bassist}
		bassist :hide
	endif
	if compositeobjectexists \{bassist2}
		bassist :hide
	endif
	if compositeobjectexists \{vocalist}
		vocalist :hide
	endif
	if compositeobjectexists \{vocalist2}
		vocalist :hide
	endif
	if compositeobjectexists \{drummer}
		drummer :hide
	endif
	if compositeobjectexists \{drummer2}
		drummer :hide
	endif
endscript

script unhide_band 
	if compositeobjectexists \{guitarist}
		guitarist :unhide
	endif
	if compositeobjectexists \{guitarist2}
		guitarist :unhide
	endif
	if compositeobjectexists \{bassist}
		bassist :unhide
	endif
	if compositeobjectexists \{bassist2}
		bassist :unhide
	endif
	if compositeobjectexists \{vocalist}
		vocalist :unhide
	endif
	if compositeobjectexists \{vocalist2}
		vocalist :unhide
	endif
	if compositeobjectexists \{drummer}
		drummer :unhide
	endif
	if compositeobjectexists \{drummer2}
		drummer :unhide
	endif
endscript
using_walk_camera = false

script start_walk_camera 
	if ($using_walk_camera = true || $using_starpower_camera = true || $game_mode = training)
		return
	endif
	change \{using_walk_camera = true}
	change \{cameracuts_allownotescripts = false}
	cameracuts_setarrayprefix \{prefix = 'cameras_walk'
		changetime = $max_walk_camera_cut_delay}
	wait \{7
		seconds}
	cameracuts_setarrayprefix \{prefix = 'cameras'}
	change \{cameracuts_allownotescripts = true}
	change \{using_walk_camera = false}
endscript

script kill_walk_camera \{changecamera = 1}
	if ($using_walk_camera = false || $game_mode = training)
		return
	endif
	killspawnedscript \{name = start_walk_camera}
	if (<changecamera> = 1)
		cameracuts_setarrayprefix \{prefix = 'cameras'}
	endif
	change \{cameracuts_allownotescripts = true}
	change \{using_walk_camera = false}
endscript

script create_vocalist_dummy 
	if NOT compositeobjectexists \{vocalist}
		createcompositeobjectinstance \{priority = $coim_priority_permanent
			heap = generic
			components = [
				{
					component = motion
				}
			]
			params = {
				name = vocalist_head_dummy
			}}
		get_start_node_id \{member = vocalist}
		getwaypointpos name = <waypoint_id>
		getwaypointdir name = <waypoint_id>
		<pos> = (<pos> + ($vocalist_height) * (0.0, 1.0, 0.0))
		vocalist_head_dummy :obj_setposition position = <pos>
		vocalist_head_dummy :obj_setorientation dir = <dir>
		createcompositeobjectinstance \{priority = $coim_priority_permanent
			heap = generic
			components = [
				{
					component = motion
				}
			]
			params = {
				name = vocalist_dummy
			}}
		get_start_node_id \{member = vocalist}
		getwaypointpos name = <waypoint_id>
		getwaypointdir name = <waypoint_id>
		vocalist_dummy :obj_setposition position = <pos>
		vocalist_dummy :obj_setorientation dir = <dir>
	endif
endscript

script destroy_vocalist_dummy 
	if compositeobjectexists \{vocalist_dummy}
		vocalist_dummy :die
	endif
	if compositeobjectexists \{vocalist_head_dummy}
		vocalist_head_dummy :die
	endif
endscript

script create_all_camera_lock_targets 
	destroy_all_camera_lock_targets
	create_camera_lock_target \{name = moment_cam_lock_target_01}
	create_camera_lock_target \{name = moment_cam_lock_target_02}
	create_camera_lock_target \{name = moment_cam_lock_target_03}
	create_camera_lock_target \{name = moment_cam_lock_target_04}
	create_camera_lock_target \{name = moment_cam_lock_target_05}
	create_camera_lock_target \{name = moment_cam_lock_target_06}
	create_camera_lock_target \{name = moment_cam_lock_target_07}
	create_camera_lock_target \{name = moment_cam_lock_target_08}
	create_camera_lock_target \{name = moment_cam_lock_target_09}
	create_camera_lock_target \{name = moment_cam_lock_target_10}
	create_camera_lock_target \{name = guitarist_mocap_lock_target_01}
	create_camera_lock_target \{name = guitarist_mocap_lock_target_02}
	create_camera_lock_target \{name = bassist_mocap_lock_target_01}
	create_camera_lock_target \{name = bassist_mocap_lock_target_02}
	create_camera_lock_target \{name = vocalist_mocap_lock_target_01}
	create_camera_lock_target \{name = vocalist_mocap_lock_target_02}
	create_camera_lock_target \{name = vocalist2_mocap_lock_target_01}
	create_camera_lock_target \{name = vocalist2_mocap_lock_target_02}
	create_camera_lock_target \{name = drummer_mocap_lock_target_01}
	create_camera_lock_target \{name = drummer_mocap_lock_target_02}
	create_camera_lock_target \{name = drummer2_mocap_lock_target_01}
	create_camera_lock_target \{name = drummer2_mocap_lock_target_02}
	create_camera_lock_target \{name = venue_cam_lock_target}
endscript

script create_frontend_lock_targets 
	destroy_frontend_lock_targets
	printf \{channel = animinfo
		qs(0xc22b676e)}
	create_camera_lock_target \{name = frontend_mocap_lock_target_01}
	create_camera_lock_target \{name = frontend_mocap_lock_target_02}
endscript

script create_camera_lock_target 
	createfromstructure {
		name = <name>
		pos = (0.0, 0.0, 0.0)
		angles = (0.0, 1.0, 0.0)
		class = gameobject
		type = ghost
		createdatstart
		disableshadowcasting = false
		profile = $profile_ven_camera_obj
		only_animate_if_locked_to_by_active_cinematic_camera = true
	}
endscript

script destroy_all_camera_lock_targets 
	destroy_camera_lock_target \{name = moment_cam_lock_target_01}
	destroy_camera_lock_target \{name = moment_cam_lock_target_02}
	destroy_camera_lock_target \{name = moment_cam_lock_target_03}
	destroy_camera_lock_target \{name = moment_cam_lock_target_04}
	destroy_camera_lock_target \{name = moment_cam_lock_target_05}
	destroy_camera_lock_target \{name = moment_cam_lock_target_06}
	destroy_camera_lock_target \{name = moment_cam_lock_target_07}
	destroy_camera_lock_target \{name = moment_cam_lock_target_08}
	destroy_camera_lock_target \{name = moment_cam_lock_target_09}
	destroy_camera_lock_target \{name = moment_cam_lock_target_10}
	destroy_camera_lock_target \{name = guitarist_mocap_lock_target_01}
	destroy_camera_lock_target \{name = guitarist_mocap_lock_target_02}
	destroy_camera_lock_target \{name = bassist_mocap_lock_target_01}
	destroy_camera_lock_target \{name = bassist_mocap_lock_target_02}
	destroy_camera_lock_target \{name = vocalist_mocap_lock_target_01}
	destroy_camera_lock_target \{name = vocalist_mocap_lock_target_02}
	destroy_camera_lock_target \{name = drummer_mocap_lock_target_01}
	destroy_camera_lock_target \{name = drummer_mocap_lock_target_02}
	destroy_camera_lock_target \{name = vocalist2_mocap_lock_target_01}
	destroy_camera_lock_target \{name = vocalist2_mocap_lock_target_02}
	destroy_camera_lock_target \{name = drummer2_mocap_lock_target_01}
	destroy_camera_lock_target \{name = drummer2_mocap_lock_target_02}
	destroy_camera_lock_target \{name = venue_cam_lock_target}
	specialcamera_cleanupallobjects
endscript

script destroy_frontend_lock_targets 
	printf \{channel = animinfo
		qs(0xb86dea08)}
	destroy_camera_lock_target \{name = frontend_mocap_lock_target_01}
	destroy_camera_lock_target \{name = frontend_mocap_lock_target_02}
endscript

script destroy_camera_lock_target 
	if compositeobjectexists <name>
		<name> :die
	endif
endscript
drumcam_params = {
	start_node = '_TRG_Waypoint_Drummer_Start'
}

script start_drummer_cameras 
	printf \{channel = band
		qs(0xd3661dee)}
	if NOT compositeobjectexists \{name = drummer}
		return
	endif
	if anim_animexists \{anim = drum_andy_standardlp_c01}
		momentcamera_playanim \{anim = drum_andy_standardlp_c01
			start_node = '_TRG_Waypoint_Drummer_Start'
			lock_target = drummer_mocap_lock_target_01
			cycle = 1}
	endif
	if anim_animexists \{anim = drum_andy_standardlp_c02}
		momentcamera_playanim \{anim = drum_andy_standardlp_c02
			start_node = '_TRG_Waypoint_Drummer_Start'
			lock_target = drummer_mocap_lock_target_02
			cycle = 1}
	endif
endscript

script preparebandforrenderupdateloop 
	begin
	bandmanager_preparebandforrender
	wait \{1
		gameframe}
	repeat
endscript

script all_players_using_starpower 
	i = 1
	begin
	formattext checksumname = player_status 'player%a_status' a = <i>
	if (($<player_status>.star_power_used) = 0)
		return \{false}
	endif
	i = (<i> + 1)
	repeat $current_num_players
	return \{true}
endscript
playing_group_starpower_anim = false

script play_group_star_power_animation 
	return
	printf \{channel = animinfo
		qs(0x8772e70c)}
	band_builder_get_band_global
	if (<band> != default_band)
		return
	endif
	if ($playing_group_starpower_anim = true)
		printf \{channel = animinfo
			qs(0x65c79e61)}
		return
	endif
	printf \{channel = animinfo
		qs(0x70a89b40)}
	if ($group_starpower = none)
		printf \{channel = animinfo
			qs(0xdf4c1b2b)}
		return
	endif
	starpower_clip = $group_starpower
	anims = ($<starpower_clip>.anims)
	guitarist_anim = (<anims>.guitarist)
	setsearchallassetcontexts
	if anim_animexists anim = <guitarist_anim>
		anim_getanimlength anim = <guitarist_anim>
	endif
	setsearchallassetcontexts \{off}
	starttime = 0
	if structurecontains structure = $<starpower_clip> name = startframe
		startframe = ($<starpower_clip>.startframe)
		starttime = ((<startframe> / 30.0) * 1000)
	endif
	starpower_length_ms = ((<length> * 1000) - <starttime> - 50)
	if (<starpower_length_ms> < 0)
		return
	endif
	band_playclip clip = ($group_starpower) override_special = true
	change \{playing_group_starpower_anim = true}
	change \{cameracuts_allownotescripts = false}
	cameracuts_setarrayprefix prefix = 'cameras_moments' name = moment01 length = <time_ms> changenow
	getsongtimems
	song_time = <time>
	end_time = (<song_time> + <starpower_length_ms>)
	camera_index = $last_camera_array_entry
	next_camera_value = -1
	get_song_prefix song = ($current_song)
	formattext checksumname = event_array '%s_cameras_notes' s = <song_prefix> addtostringlookup
	getarraysize $<event_array>
	array_size = (<array_size> / 2)
	begin
	if (<camera_index> >= <array_size>)
		break
	endif
	next_camera_time = ($<event_array> [<camera_index>])
	time_from_cameracut = (<next_camera_time> - <end_time>)
	abs_time_from_camercut = <time_from_cameracut>
	if (<abs_time_from_camercut> < 0)
		abs_time_from_camercut = (<abs_time_from_camercut> * -1)
	endif
	if (<abs_time_from_camercut> < $starpower_end_camera_threshold)
		if (<time_from_cameracut> < 0)
			end_time = <next_camera_time>
			next_camera_value = ($<event_array> [(<camera_index> + 1)])
			break
		else
			end_time = (<next_camera_time> - $starpower_end_camera_threshold)
		endif
	endif
	if (<time_from_cameracut> > $starpower_end_camera_threshold)
		break
	endif
	camera_index = (<camera_index> + 2)
	repeat
	change \{cameracuts_allownotescripts = false}
	cameracuts_setarrayprefix prefix = 'cameras_moments' name = moment01 length = <time_ms> changenow
	begin
	getsongtimems
	if (<time> >= <end_time>)
		break
	endif
	wait \{1
		gameframe}
	repeat
	clip_get_time_and_frame
	printf channel = clip qs(0x85f947aa) a = <time_string>
	use_generic_shot = true
	if (<next_camera_value> != -1)
		decompressnotevalue note_value = <next_camera_value>
		if getnotemapping section = cameras note = <note>
			if structurecontains structure = (<note_data>.params) name
				camera_prefix = ((<note_data>.params).prefix)
				if (<camera_prefix> != 'cameras_moments')
					spawnscriptnow (<note_data>.scr) params = {(<note_data>.params) length = <length>}
					use_generic_shot = false
				else
				endif
			endif
		endif
	endif
	if (<use_generic_shot> = true)
		cameracuts_setarrayprefix \{prefix = 'cameras'
			changenow
			type = generic_stage_shot}
	endif
	cameracuts_setarrayprefix \{prefix = 'cameras'}
	change \{cameracuts_allownotescripts = true}
	wait \{1
		gameframe}
	band_forcealltoidle \{all_modes = true
		restart
		no_wait}
	band_movealltostartnodes \{restart}
	change \{playing_group_starpower_anim = false}
endscript

script kill_group_starpower_anim \{changecamera = 1}
	if ($playing_group_starpower_anim = false)
		return
	endif
	killspawnedscript \{name = play_group_star_power_animation}
	if (<changecamera> = 1)
		cameracuts_setarrayprefix \{prefix = 'cameras'}
	endif
	change \{cameracuts_allownotescripts = true}
	change \{playing_group_starpower_anim = false}
endscript

script debug_toggle_band_visiblity 
	debug_toggle_character_visiblity \{name = guitarist}
	debug_toggle_character_visiblity \{name = bassist}
	debug_toggle_character_visiblity \{name = drummer}
	debug_toggle_character_visiblity \{name = vocalist}
endscript

script debug_toggle_character_visiblity 
	printf channel = animinfo qs(0xa418ab1c) a = <name>
	if NOT gotparam \{name}
		printf \{channel = animinfo
			qs(0x2b50edbe)}
		return
	endif
	if NOT compositeobjectexists name = <name>
		printf channel = animinfo qs(0xd9dcffd1) a = <name>
		return
	endif
	switch (<name>)
		case guitarist
		debug_hide = hide_guitarist
		case bassist
		debug_hide = hide_bassist
		case vocalist
		debug_hide = hide_vocalist
		case drummer
		debug_hide = hide_drummer
		default
		printf \{channel = animinfo
			qs(0x45f3f560)}
		return
	endswitch
	if ($<debug_hide> = true)
		printf channel = animinfo qs(0xfacf2177) a = <name>
		<name> :hide
	else
		printf channel = animinfo qs(0x758bccc3) a = <name>
		<name> :unhide
	endif
endscript
